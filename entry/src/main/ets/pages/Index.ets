import { promptAction } from '@kit.ArkUI'
import { photoAccessHelper } from '@kit.MediaLibraryKit'
import { image } from '@kit.ImageKit'
import { fileIo } from '@kit.CoreFileKit'
import { common } from '@kit.AbilityKit'
import { BusinessError } from '@kit.BasicServicesKit'
import { effectKit } from '@kit.ArkGraphics2D'


// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
interface ErrorWithCode {
  code?: number | string
  message?: string
}

// æ¯ä¸€æ­¥ç”»å¸ƒçŠ¶æ€å¿«ç…§ï¼Œç”¨äºæ’¤é”€
// interface CanvasSnapshot {
//   pixelMap?: image.PixelMap
//   zoom: number
//   offsetX: number
//   offsetY: number
//   brightnessLevel: number
//   contrastLevel: number
//   accumulatedRotate: number
// }
interface CanvasSnapshot {
  pixelMap?: image.PixelMap // åº•å›¾å¿«ç…§
  drawPixelMap?: image.PixelMap // â­ æ–°å¢ï¼šç»˜åˆ¶å›¾å±‚å¿«ç…§
  zoom: number
  offsetX: number
  offsetY: number
  brightnessLevel: number
  contrastLevel: number
  accumulatedRotate: number
}


enum TopMenu {
  None,
  Image, // å›¾ç‰‡æ“ä½œ
  Shape, // å½¢çŠ¶
  Brush // ç”»ç¬”
}

enum ShapeTool {
  None,
  Point,
  Line,
  Rect,
  Circle,
  Ellipse,
  FreeDraw
}

enum BrushTool {
  None,
  Pen,
  Highlighter,
  Eraser
}


@Entry
@Component
struct Index {
  // ç”»å¸ƒçŠ¶æ€
  @State pixelMap?: image.PixelMap = undefined
  @State zoom: number = 1.0
  @State offsetX: number = 0
  @State offsetY: number = 0
  @State pixelVersion: number = 0
  // ================= æ–°å¢ï¼šç»˜åˆ¶å›¾å±‚ =================
  // ä¸“é—¨ç”¨æ¥ç”»çº¿æ¡/å½¢çŠ¶ï¼Œæ©¡çš®æ“¦åªæ“¦è¿™ä¸ªå±‚
  @State drawPixelMap?: image.PixelMap = undefined
  @State drawPixelVersion: number = 0
  // ==================================================
  // æ—‹è½¬ä¸­æ ‡å¿—ï¼Œé˜²æ­¢è¿ç‚¹å¯¼è‡´ä¸¤æ¬¡å³æ—‹
  private isRotating: boolean = false
  private accumulatedRotate: number = 0 // ä¹‹å‰æ—‹è½¬çš„æ€»åº¦æ•°
  // æ—‹è½¬ / äº®åº¦ / å¯¹æ¯”åº¦
  @State rotateDeg: number = 0 // æ—‹è½¬è§’åº¦
  @State brightnessLevel: number = 0.0 // -0.5 ~ 0.5 å·¦å³ï¼Œ0 æ˜¯åŸå›¾
  @State contrastLevel: number = 0.0 // -1.0 ~ 1.0ï¼ˆ0 æ˜¯åŸå›¾å¯¹æ¯”åº¦ï¼‰
  @State showLeftPanel: boolean = false // å·¦ä¾§å·¥å…·æ æ˜¯å¦å±•å¼€
  @State currentTool: string = '' // å½“å‰é€‰æ‹©çš„å·¥å…·ç±»å‹ï¼ˆpoint/line/rect...ï¼‰
  @State activeMenu: TopMenu = TopMenu.None // å½“å‰å±•å¼€çš„é¡¶æ èœå•
  @State currentShape: ShapeTool = ShapeTool.None
  @State currentBrush: BrushTool = BrushTool.None
  // é¡¶éƒ¨èœå•å½“å‰é€‰ä¸­çš„ä¸€çº§èœå•ï¼šimage / shape / brush / ''(ä¸æ˜¾ç¤ºäºŒçº§)
  @State currentMenu: string = 'image'
  // å½“å‰äºŒçº§èœå•ï¼ˆå½¢çŠ¶ / ç”»ç¬”æ‰ä¼šä½¿ç”¨ï¼‰
  @State currentSubTool: string = ''
  // æ‰‹åŠ¿å†…éƒ¨çŠ¶æ€
  private lastPanX: number = 0
  private lastPanY: number = 0
  private lastZoom: number = 1.0
  // è£å‰ªæ¨¡å¼ å¼€/å…³
  @State cropMode: boolean = false
  // æ‰‹åŠ¿é€‰æ‹©æ¡†ï¼ˆUI åæ ‡ï¼‰
  @State cropStartX: number = 0
  @State cropStartY: number = 0
  @State cropEndX: number = 0
  @State cropEndY: number = 0
  // ç”»å¸ƒå¤§å°ï¼ˆä¸ºäº†æŠŠ UI åæ ‡æ¯”ä¾‹æ˜ å°„æˆåƒç´ åæ ‡ï¼‰
  @State canvasWidth: number = 0
  @State canvasHeight: number = 0
  // æ’¤é”€ç”¨çš„å†å²æ ˆï¼ˆä¸éœ€è¦å“åº”å¼ï¼‰
  private history: Array<CanvasSnapshot> = []
  private historyIndex: number = -1
  private readonly historyLimit: number = 10
  // æ–°å¢ï¼šè®°å½•â€œæ‰“å¼€å›¾ç‰‡æ—¶çš„åŸå›¾å¿«ç…§â€
  private originalPixelMap?: image.PixelMap = undefined
  //å…¨å±€ç”»ç¬”æ ·å¼ï¼ˆå½¢çŠ¶ + ç”»ç¬”å…±äº«ï¼‰
  @State strokeWidth: number = 4 // åƒç´ åŠå¾„ï¼Œç»†ç¬”/ç²—ç¬”ä¸€èµ·æ”¹è¿™ä¸ª
  @State strokeR: number = 0 // é»˜è®¤é»‘è‰²
  @State strokeG: number = 0
  @State strokeB: number = 0
  @State strokeOpacity: number = 1.0 // 0.0 ~ 1.0 ç”»ç¬”é€æ˜åº¦ï¼ˆæš‚æ—¶åªä½œä¸º UIï¼‰
  // å½“å‰æ˜¯å¦æ­£åœ¨ç»˜åˆ¶ä¸€ä¸ªå½¢çŠ¶ï¼ˆçº¿ã€çŸ©å½¢ã€åœ†ç­‰ï¼‰
  private isShapeDrawing: boolean = false
  // é€šç”¨å½¢çŠ¶ç»˜åˆ¶çš„èµ·ç‚¹ï¼ˆUI åæ ‡ï¼‰
  private shapeStartUiX: number = 0
  private shapeStartUiY: number = 0
  // è‡ªç”±ç»˜åˆ¶çŠ¶æ€ï¼ˆå½¢çŠ¶ = ShapeTool.FreeDraw æ—¶ä½¿ç”¨ï¼‰
  private isFreeDrawing: boolean = false
  private freeLastUiX: number = 0
  private freeLastUiY: number = 0
  // è‡ªç”±ç”»å¼€å§‹æ—¶ç¼“å­˜åŸå›¾åƒç´ 
  private freeDrawBuffer: Uint8Array | null = null
  private freeDrawArrayBuffer: ArrayBuffer | null = null
  private freeDrawByteLength: number = 0
  private freeBufferReady: boolean = false

  build() {
    Column() {
      // é¡¶éƒ¨å·¥å…·æ 
      Column() {
        Column() {
          // é¡¶éƒ¨å·¥å…·æ 
          Column() {
            // === ä¸€çº§èœå•ï¼šå›¾ç‰‡æ“ä½œ / å½¢çŠ¶ / ç”»ç¬” / æ’¤é”€ ===
            Row({ space: 8 }) {
              // ä¸€çº§æŒ‰é’®ï¼šå›¾ç‰‡æ“ä½œ
              Button('å›¾ç‰‡æ“ä½œ', { type: ButtonType.Capsule })
                .height(32)
                .fontSize(12)
                .backgroundColor(this.currentMenu === 'image' ? '#2563EB' : '#EFF6FF')
                .fontColor(this.currentMenu === 'image' ? '#FFFFFF' : '#1D4ED8')
                .onClick(() => {
                  this.currentMenu = this.currentMenu === 'image' ? '' : 'image'
                })

              // ä¸€çº§æŒ‰é’®ï¼šå½¢çŠ¶
              Button('å½¢çŠ¶', { type: ButtonType.Capsule })
                .height(32)
                .fontSize(12)
                .backgroundColor(this.currentMenu === 'shape' ? '#2563EB' : '#EFF6FF')
                .fontColor(this.currentMenu === 'shape' ? '#FFFFFF' : '#1D4ED8')
                .onClick(() => {
                  this.currentMenu = this.currentMenu === 'shape' ? '' : 'shape'
                })

              // ä¸€çº§æŒ‰é’®ï¼šç”»ç¬”
              Button('ç”»ç¬”', { type: ButtonType.Capsule })
                .height(32)
                .fontSize(12)
                .backgroundColor(this.currentMenu === 'brush' ? '#2563EB' : '#EFF6FF')
                .fontColor(this.currentMenu === 'brush' ? '#FFFFFF' : '#1D4ED8')
                .onClick(() => {
                  this.currentMenu = this.currentMenu === 'brush' ? '' : 'brush'
                })

              // ä¸€çº§æŒ‰é’®ï¼šæ’¤é”€ï¼ˆè¿™é‡Œå…ˆå ä½ï¼Œåé¢ä½ æ¥å…¥çœŸæ­£çš„æ’¤é”€é€»è¾‘ï¼‰
              Button('æ’¤é”€', { type: ButtonType.Capsule })
                .height(32)
                .fontSize(12)
                .backgroundColor('#fff31818')
                .onClick(async () => {
                  await this.undo()
                })
            }
            .width('100%')
            .padding({
              left: 4,
              right: 4,
              top: 4,
              bottom: 4
            })
            .justifyContent(FlexAlign.Center)

            // === äºŒçº§èœå•åŒºåŸŸï¼šæ ¹æ® currentMenu å†³å®šæ˜¾ç¤ºå“ªä¸€è¡Œ ===
            if (this.currentMenu === 'image') {
              // å›¾ç‰‡æ“ä½œï¼šå¸¦æ¨ªå‘æ»šåŠ¨æ¡
              Scroll() {
                Row({ space: 8 }) {
                  Button('è£å‰ª', { type: ButtonType.Capsule })
                    .height(32)
                    .fontSize(12)
                    .backgroundColor(this.cropMode ? '#EF4444' : '#EFF6FF')
                    .fontColor(this.cropMode ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => {
                      if (!this.pixelMap) {
                        // ä¸è¿›å…¥è£å‰ªæ¨¡å¼ï¼Œä½†è°ƒç”¨ doCropï¼Œè®© doCrop è‡ªå·±å¼¹å‡º toast
                        this.doCrop()
                        return
                      }

                      this.cropMode = !this.cropMode
                      if (this.cropMode) {
                        this.cropStartX = 0
                        this.cropStartY = 0
                        this.cropEndX = 0
                        this.cropEndY = 0
                      }
                    })

                  // äºŒçº§æŒ‰é’®ç»Ÿä¸€ç”¨ Normal + æµ…ç°èƒŒæ™¯ï¼Œä¸ä¸€çº§åŒºåˆ†
                  Button('å¯¹æ¯”åº¦+', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.adjustContrast(0.1))

                  Button('å¯¹æ¯”åº¦-', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.adjustContrast(-0.1))

                  Button('å·¦æ—‹90Â°', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.rotateLeft90())

                  Button('å³æ—‹90Â°', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.rotateRight90())

                  Button('å˜äº®', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.adjustBrightness(0.05))

                  Button('å˜æš—', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.adjustBrightness(-0.05))
                }
                .height(32)
                .padding({ left: 4, right: 4 })
              }
              .scrollable(ScrollDirection.Horizontal)
              .width('100%')
              .padding({ bottom: 8 }) // äºŒçº§èœå•å’Œç”»å¸ƒä¹‹é—´ç•™ä¸€ç‚¹ç©ºéš™
            } else if (this.currentMenu === 'shape') {
              Scroll() {
                Row({ space: 8 }) {

                  Button('ç‚¹', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Point ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Point ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.currentShape = ShapeTool.Point)

                  Button('ç›´çº¿', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Line ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Line ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.currentShape = ShapeTool.Line)

                  Button('çŸ©å½¢', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Rect ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Rect ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.currentShape = ShapeTool.Rect)

                  Button('åœ†', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Circle ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Circle ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.currentShape = ShapeTool.Circle)

                  Button('æ¤­åœ†', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Ellipse ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Ellipse ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.currentShape = ShapeTool.Ellipse)

                  Button('çº¿æ¡', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.FreeDraw ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.FreeDraw ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.currentShape = ShapeTool.FreeDraw)

                }
                .height(32)
                .padding({ left: 4, right: 4 })
              }
              .scrollable(ScrollDirection.Horizontal)
              .width('100%')
              .padding({ bottom: 8 })

            } else if (this.currentMenu === 'brush') {
              Scroll() {
                Column() {

                  // ===== ç¬¬ 1 è¡Œï¼šæ©¡çš®æ“¦ =====
                  Row({ space: 8 }) {
                    Button('æ©¡çš®æ“¦', { type: ButtonType.Normal })
                      .height(28)
                      .fontSize(11)
                      .backgroundColor(this.currentBrush === BrushTool.Eraser ? '#FB923C' : '#FEF3C7')
                      .fontColor(this.currentBrush === BrushTool.Eraser ? '#FFFFFF' : '#92400E')
                      .onClick(() => {
                        this.currentBrush = BrushTool.Eraser
                      })
                  }
                  .height(32)
                  .padding({ left: 4, right: 4, bottom: 4 })


                  // ===== ç¬¬ 2 è¡Œï¼šç²—ç»†è°ƒèŠ‚ Slider =====
                  Row({ space: 8 }) {
                    Text('ç²—ç»†')
                      .fontSize(11)
                      .fontColor('#4B5563')
                      .width(36)

                    Slider({
                      value: this.strokeWidth,
                      min: 1,
                      max: 40,
                      step: 1
                    })
                      .width('60%')
                      .onChange((value: number) => {
                        this.strokeWidth = value
                      })

                    Text(`${this.strokeWidth.toFixed(0)} px`)
                      .fontSize(10)
                      .fontColor('#6B7280')
                      .width(40)
                  }
                  .height(32)
                  .padding({ left: 4, right: 4, bottom: 4 })
                  .alignItems(VerticalAlign.Center)


                  // ===== ç¬¬ 3 è¡Œï¼šé€æ˜åº¦ Slider =====
                  Row({ space: 8 }) {
                    Text('é€æ˜åº¦')
                      .fontSize(11)
                      .fontColor('#4B5563')
                      .width(36)

                    Slider({
                      value: this.strokeOpacity,
                      min: 0.1, // æœ€ä½ 10%ï¼Œé˜²æ­¢å®Œå…¨çœ‹ä¸è§
                      max: 1.0,
                      step: 0.05
                    })
                      .width('60%')
                      .onChange((value: number) => {
                        this.strokeOpacity = value
                      })

                    Text(`${Math.round(this.strokeOpacity * 100)}%`)
                      .fontSize(10)
                      .fontColor('#6B7280')
                      .width(40)
                  }
                  .height(32)
                  .padding({ left: 4, right: 4, bottom: 4 })
                  .alignItems(VerticalAlign.Center)


                  // ===== ç¬¬ 4 è¡Œï¼šé¢œè‰²é€‰æ‹©ï¼ˆå…¨å±€é¢œè‰²ï¼Œå½¢çŠ¶ + ç”»ç¬”å…±ç”¨ï¼‰ =====
                  Row({ space: 8 }) {
                    // é»‘è‰²
                    Button('', { type: ButtonType.Normal })
                      .width(24)
                      .height(24)
                      .backgroundColor('#000000')
                      .borderRadius(12)
                      .border({ width: 1, color: '#E5E7EB' })
                      .onClick(() => {
                        this.strokeR = 0
                        this.strokeG = 0
                        this.strokeB = 0
                      })

                    // çº¢è‰²
                    Button('', { type: ButtonType.Normal })
                      .width(24)
                      .height(24)
                      .backgroundColor('#EF4444')
                      .borderRadius(12)
                      .border({ width: 1, color: '#E5E7EB' })
                      .onClick(() => {
                        this.strokeR = 239
                        this.strokeG = 68
                        this.strokeB = 68
                      })

                    // ç»¿è‰²
                    Button('', { type: ButtonType.Normal })
                      .width(24)
                      .height(24)
                      .backgroundColor('#22C55E')
                      .borderRadius(12)
                      .border({ width: 1, color: '#E5E7EB' })
                      .onClick(() => {
                        this.strokeR = 34
                        this.strokeG = 197
                        this.strokeB = 94
                      })

                    // è“è‰²
                    Button('', { type: ButtonType.Normal })
                      .width(24)
                      .height(24)
                      .backgroundColor('#3B82F6')
                      .borderRadius(12)
                      .border({ width: 1, color: '#E5E7EB' })
                      .onClick(() => {
                        this.strokeR = 59
                        this.strokeG = 130
                        this.strokeB = 246
                      })
                  }
                  .height(32)
                  .padding({ left: 4, right: 4 })

                }
              }
              .scrollable(ScrollDirection.Horizontal)
              .width('100%')
              .padding({ bottom: 8 })
            }
          }

          // ç”»å¸ƒ
          Stack() {
            if (!this.pixelMap) {
              Column() {
                Text('ç‚¹å‡»â€œæ‰“å¼€å›¾ç‰‡â€å¼€å§‹ç¼–è¾‘')
                  .fontSize(14)
                  .fontColor('#9AA1A8')
                  .letterSpacing(0.5)
              }
              .width('100%').height('100%')
              .justifyContent(FlexAlign.Center)
              .alignItems(HorizontalAlign.Center)
            } else {
              // =======================
              // 1. å›¾ç‰‡æ˜¾ç¤ºå±‚ï¼ˆåº•å›¾ï¼‰
              // =======================
              Image(this.pixelMap)
                .id(`img-${this.pixelVersion}`)
                .objectFit(ImageFit.Contain)
                .width('100%')
                .height('100%')
                .scale({ x: this.zoom, y: this.zoom })
                .translate({ x: this.offsetX, y: this.offsetY })
                .colorFilter(this.buildToneMatrix())

              // =======================
              // 1.5 ç»˜åˆ¶å›¾å±‚ï¼ˆå åŠ ï¼‰
              // =======================
              if (this.drawPixelMap) {
                Image(this.drawPixelMap)
                  .id(`draw-${this.drawPixelVersion}`)
                  .objectFit(ImageFit.Contain)
                  .width('100%')
                  .height('100%')
                  .scale({ x: this.zoom, y: this.zoom })
                  .translate({ x: this.offsetX, y: this.offsetY })
              }


              // ==========================
              // 2. æ‹–æ‹½ & ç¼©æ”¾æ‰‹åŠ¿å±‚ï¼ˆä¸æ˜¯è£å‰ªæ—¶ç”Ÿæ•ˆï¼‰
              // ==========================
              if (!this.cropMode) {
                Stack()
                  .width('100%')
                  .height('100%')
                  .backgroundColor(Color.Transparent)
                  .hitTestBehavior(HitTestMode.Transparent)
                  .gesture(
                    GestureGroup(GestureMode.Parallel,

                      // ç‚¹å‡»ï¼šç”»ç‚¹
                      TapGesture()
                        .onAction((ev: GestureEvent) => {
                          if (!ev.fingerList || ev.fingerList.length === 0) {
                            return
                          }
                          const finger = ev.fingerList[0]
                          const x: number = finger.localX
                          const y: number = finger.localY

                          console.info(`>>> tap at x=${x}, y=${y}`)

                          if (this.currentShape === ShapeTool.Point) {
                            this.drawPointAtUi(x, y)
                          }
                        }),

                      // æ‹–æ‹½ï¼šå¹³ç§» / ç›´çº¿ / çŸ©å½¢ / åœ† / æ¤­åœ† / è‡ªç”±ç”»
                      PanGesture({ direction: PanDirection.All })
                        .onActionStart(e => {
                          if (!e.fingerList || e.fingerList.length === 0) {
                            return
                          }
                          const f = e.fingerList[0]

                          if (this.currentShape === ShapeTool.FreeDraw) {
                            this.isFreeDrawing = true
                            this.freeLastUiX = f.localX
                            this.freeLastUiY = f.localY

                            // å¼‚æ­¥å‡†å¤‡ bufferï¼ˆä¸èƒ½ awaitï¼‰
                            this.prepareFreeDrawBuffer()

                            // å­˜ä¸€æ¬¡å¿«ç…§æ–¹ä¾¿æ’¤é”€æ•´ç¬”
                            if (this.pixelMap) {
                              this.clonePixelMap(this.pixelMap as image.PixelMap)
                                .then(pmBackup => this.pushHistorySnapshot(true, pmBackup))
                            }
                            return
                          }


                          // âœ… æƒ…å†µ 2ï¼šç›´çº¿ / çŸ©å½¢ / åœ† / æ¤­åœ†ï¼šæ‹–å‡ºä¸€ä¸ªå½¢çŠ¶
                          if (this.currentShape === ShapeTool.Line ||
                            this.currentShape === ShapeTool.Rect ||
                            this.currentShape === ShapeTool.Circle ||
                            this.currentShape === ShapeTool.Ellipse) {
                            this.isShapeDrawing = true
                            this.shapeStartUiX = f.localX
                            this.shapeStartUiY = f.localY
                            console.info(`>>> shape start ui=(${this.shapeStartUiX}, ${this.shapeStartUiY})`)
                            return
                          }

                          // âœ… æƒ…å†µ 3ï¼šå…¶ä»–æƒ…å†µ â†’ å½“æˆå¹³ç§»ç”»å¸ƒ
                          this.lastPanX = this.offsetX
                          this.lastPanY = this.offsetY
                        })
                        .onActionUpdate(e => {
                          if (!e.fingerList || e.fingerList.length === 0) {
                            return
                          }
                          const f = e.fingerList[0]

                          if (this.isFreeDrawing && this.currentShape === ShapeTool.FreeDraw) {
                            this.drawFreeStrokeSegmentSync(
                              this.freeLastUiX,
                              this.freeLastUiY,
                              f.localX,
                              f.localY
                            )

                            this.freeLastUiX = f.localX
                            this.freeLastUiY = f.localY
                            return
                          }

                          // ğŸ‘‰ æ­£åœ¨ç”»å›¾å½¢ï¼ˆçº¿ / çŸ©å½¢ / åœ† / æ¤­åœ†ï¼‰æ—¶ï¼Œä¸å¹³ç§»
                          if (this.isShapeDrawing &&
                            (this.currentShape === ShapeTool.Line ||
                              this.currentShape === ShapeTool.Rect ||
                              this.currentShape === ShapeTool.Circle ||
                              this.currentShape === ShapeTool.Ellipse)) {
                            return
                          }

                          // ğŸ‘‰ å¦åˆ™ï¼šå¹³ç§»ç”»å¸ƒ
                          this.offsetX = this.lastPanX + e.offsetX
                          this.offsetY = this.lastPanY + e.offsetY
                        })
                        .onActionEnd((e: GestureEvent) => {
                          // è‡ªç”±ç”»ç»“æŸ
                          if (this.isFreeDrawing && this.currentShape === ShapeTool.FreeDraw) {
                            this.handleFreeDrawEnd()
                            return
                          }

                          // å›¾å½¢ç»“æŸ
                          if (!e.fingerList || e.fingerList.length === 0) {
                            this.isShapeDrawing = false
                            return
                          }

                          const f = e.fingerList[0] // â† å·²å»æ‰ GestureFinger

                          const endUiX: number = f.localX
                          const endUiY: number = f.localY


                          // â‘¢ å›¾å½¢ç»“æŸï¼šç›´çº¿ / çŸ©å½¢ / åœ† / æ¤­åœ†
                          if (this.isShapeDrawing &&
                            (this.currentShape === ShapeTool.Line ||
                              this.currentShape === ShapeTool.Rect ||
                              this.currentShape === ShapeTool.Circle ||
                              this.currentShape === ShapeTool.Ellipse)) {

                            this.isShapeDrawing = false

                            if (this.currentShape === ShapeTool.Line) {
                              this.handleLineDrag(this.shapeStartUiX, this.shapeStartUiY, endUiX, endUiY)
                            } else if (this.currentShape === ShapeTool.Rect) {
                              this.handleRectDrag(this.shapeStartUiX, this.shapeStartUiY, endUiX, endUiY)
                            } else if (this.currentShape === ShapeTool.Circle) {
                              this.handleCircleDrag(this.shapeStartUiX, this.shapeStartUiY, endUiX, endUiY)
                            } else if (this.currentShape === ShapeTool.Ellipse) {
                              this.handleEllipseDrag(this.shapeStartUiX, this.shapeStartUiY, endUiX, endUiY)
                            }
                          }
                        }),
                      // ç¼©æ”¾ï¼šä¿æŒåŸæ¥çš„é€»è¾‘
                      PinchGesture()
                        .onActionStart(e => {
                          this.lastZoom = this.zoom
                        })
                        .onActionUpdate(e => {
                          let next = this.lastZoom * e.scale
                          this.zoom = Math.min(5, Math.max(0.3, next))
                        })
                    )
                  )
              }


              // === è£å‰ªæ¨¡å¼ ===
              if (this.cropMode) {
                // æ‰‹åŠ¿ï¼šæ‹–å‡ºè£å‰ªæ¡†
                Stack()
                  .width('100%')
                  .height('100%')
                  .backgroundColor(Color.Transparent)
                  .gesture(
                    PanGesture({ direction: PanDirection.All })
                      .onActionStart(ev => {
                        const f = ev.fingerList[0]
                        this.cropStartX = f.localX
                        this.cropStartY = f.localY
                        this.cropEndX = f.localX
                        this.cropEndY = f.localY
                      })
                      .onActionUpdate(ev => {
                        const f = ev.fingerList[0]
                        this.cropEndX = f.localX
                        this.cropEndY = f.localY
                      })
                      .onActionEnd(() => {
                        this.doCrop()
                      })
                  )

                // ç”»è£å‰ªæ¡†ï¼ˆUIï¼‰
                Rect()
                  .position({
                    x: Math.min(this.cropStartX, this.cropEndX),
                    y: Math.min(this.cropStartY, this.cropEndY)
                  })
                  .width(Math.abs(this.cropEndX - this.cropStartX))
                  .height(Math.abs(this.cropEndY - this.cropStartY))
                  .stroke(Color.Red)
                  .strokeWidth(2)
                  .fill('rgba(255,0,0,0.18)')
              }

            }
          }
          .width('100%')
          .layoutWeight(1)
          .backgroundColor('#FFFFFF')
          .borderRadius(12)
          .padding(2)
          .clip(true)
          .onAreaChange((oldArea, newArea) => {
            this.canvasWidth = Number(newArea.width)
            this.canvasHeight = Number(newArea.height)
          })


          // åº•éƒ¨å·¥å…·æ 
          Row({ space: 10 }) {
            Text('é¸¿ç»˜')
              .fontSize(16)
              .fontWeight(FontWeight.Medium)
              .fontColor('#6B7280')
              .layoutWeight(1)

            Button('æ‰“å¼€å›¾ç‰‡', { type: ButtonType.Capsule })
              .height(40).padding({ left: 14, right: 14 })
              .onClick(() => this.pickImage())

            SaveButton({
              icon: SaveIconStyle.FULL_FILLED,
              text: SaveDescription.SAVE_IMAGE,
              buttonType: ButtonType.Capsule
            })
              .height(40)
              .padding({ left: 14, right: 14 })
              .onClick(async (event, result: SaveButtonOnClickResult) => {
                if (result === SaveButtonOnClickResult.SUCCESS) {
                  // ç”¨æˆ·ç‚¹äº†ä¿å­˜æŒ‰é’®ï¼Œç³»ç»Ÿä¸´æ—¶æˆäºˆç›¸å†Œå†™å…¥æƒé™ï¼ˆçº¦ 5 ç§’ï¼‰
                  await this.saveImage()
                } else {
                  promptAction.showToast({ message: 'æˆæƒå¤±è´¥ï¼Œæ— æ³•ä¿å­˜' })
                }
              })

            Button('é‡ç½®', { type: ButtonType.Capsule })
              .height(40)
              .padding({ left: 14, right: 14 })
              .backgroundColor('#EEF2FF')
              .fontColor('#3B82F6')
              .onClick(() => this.resetView())
          }
          .width('100%')
          .padding({
            left: 12,
            right: 12,
            top: 10,
            bottom: 10
          })
          .backgroundColor('#F7F8FA')
          .border({ width: { top: 0.5 }, color: '#E5E7EB' })
          .alignItems(VerticalAlign.Center)

        }
        .width('100%').height('100%')
        .backgroundColor('#FFFFFF')
        .padding(12)
      }
    }
  }

  // æ ¹æ®åº•å›¾ pm åˆ›å»ºä¸€å¼ â€œå®Œå…¨é€æ˜â€çš„ç»˜åˆ¶å›¾å±‚ï¼ˆå°ºå¯¸ & åƒç´ æ ¼å¼ä¸€è‡´ï¼‰
  private async createEmptyDrawLayerLike(pm: image.PixelMap): Promise<image.PixelMap> {
    // 1. å…ˆ clone ä¸€ä»½ï¼Œä¿è¯ editable
    const layer: image.PixelMap = await this.clonePixelMap(pm)

    // 2. æŠŠæ‰€æœ‰åƒç´ æ¸…æˆé€æ˜
    const byteLength: number = layer.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await layer.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    for (let i = 0; i < data.length; i += 4) {
      data[i] = 0 // R
      data[i + 1] = 0 // G
      data[i + 2] = 0 // B
      data[i + 3] = 0 // A = 0 å®Œå…¨é€æ˜
    }

    await layer.writeBufferToPixels(buffer)
    return layer
  }

  // ç¡®ä¿å­˜åœ¨ç»˜åˆ¶å›¾å±‚ï¼šæ²¡æœ‰å°±åˆ›å»ºï¼Œæœ‰å°±ç›´æ¥è¿”å›
  private async ensureDrawLayer(): Promise<image.PixelMap | undefined> {
    if (!this.pixelMap) {
      return undefined
    }

    if (!this.drawPixelMap) {
      const basePm = this.pixelMap as image.PixelMap
      this.drawPixelMap = await this.createEmptyDrawLayerLike(basePm)
      this.drawPixelVersion++
    }

    return this.drawPixelMap as image.PixelMap
  }

  // é¸¿è’™ 6.0 å®˜æ–¹å¯ç”¨ã€ä¸å˜è‰²çš„å…‹éš†ï¼špack â†’ decode
  private async clonePixelMap(pm: image.PixelMap): Promise<image.PixelMap> {
    // 1. pack æˆ PNG å†…å­˜æµï¼ˆæ³¨æ„ï¼špackToData åªæœ‰ä¸¤ä¸ªå‚æ•°ï¼‰
    const packer = image.createImagePacker()
    const packOpts: image.PackingOption = {
      format: 'image/png', // PNG æ— æŸï¼Œé¢œè‰²æœ€å®‰å…¨
      quality: 100
    }

    // HarmonyOS 6.0ï¼špackToData è¿”å› Promise<ArrayBuffer>
    const buffer: ArrayBuffer = await packer.packToData(pm, packOpts)
    packer.release?.()

    // 2. å† decode æˆæ–°çš„ PixelMapï¼ˆä¿æŒ editableï¼‰
    const imgSource = image.createImageSource(buffer)
    const clonePm: image.PixelMap = await imgSource.createPixelMap({
      editable: true
    })
    imgSource.release?.()

    return clonePm
  }

  // åœ¨ä¸€æ¬¡â€œä¼šæ”¹å˜å›¾åƒ/çŠ¶æ€â€çš„æ“ä½œä¹‹å‰è°ƒç”¨ï¼Œè®°å½•å¿«ç…§
  // includePixel = trueï¼šæŠŠ pmForSnapshot è¿™å¼ å›¾ä½œä¸ºå¿«ç…§ä¿å­˜ï¼ˆä¸æ‹·è´åƒç´ ï¼‰â€”â€”ä¸“é—¨ç»™è£å‰ªç”¨
  private async pushHistorySnapshot(includePixel: boolean, pmForSnapshot?: image.PixelMap): Promise<void> {
    let snapshotPixel: image.PixelMap | undefined = undefined
    let snapshotDraw: image.PixelMap | undefined = undefined // â­ æ–°å¢

    // æ˜¯å¦åŒ…å«åƒç´ å¿«ç…§ï¼ˆåº•å›¾ï¼‰
    if (includePixel && pmForSnapshot) {
      snapshotPixel = pmForSnapshot
    }

    // â­ ä¸ç®¡åº•å›¾è¦ä¸è¦ä¿å­˜ï¼Œç»˜åˆ¶å›¾å±‚å¦‚æœå­˜åœ¨ï¼Œéƒ½ clone ä¸€ä»½ä¿å­˜å¿«ç…§
    if (this.drawPixelMap) {
      snapshotDraw = await this.clonePixelMap(this.drawPixelMap as image.PixelMap)
    }

    // å¦‚æœå·²ç»æ’¤é”€åˆ°ä¸­é—´ï¼Œå†åšæ–°æ“ä½œï¼Œåˆ™ç æ‰â€œæœªæ¥â€åˆ†æ”¯
    if (this.historyIndex >= 0 && this.historyIndex < this.history.length - 1) {
      for (let i = this.historyIndex + 1; i < this.history.length; i++) {
        this.history[i].pixelMap?.release?.()
        this.history[i].drawPixelMap?.release?.() // â­ è®°å¾—é‡Šæ”¾ç»˜åˆ¶å±‚å¿«ç…§
      }
      this.history = this.history.slice(0, this.historyIndex + 1)
    }

    this.history.push({
      pixelMap: snapshotPixel,
      drawPixelMap: snapshotDraw, // â­ å­˜è¿›å»
      zoom: this.zoom,
      offsetX: this.offsetX,
      offsetY: this.offsetY,
      brightnessLevel: this.brightnessLevel,
      contrastLevel: this.contrastLevel,
      accumulatedRotate: this.accumulatedRotate
    })

    this.historyIndex = this.history.length - 1
  }

  // é‡ç½®åˆ°â€œåˆšæ‰“å¼€å›¾ç‰‡æ—¶â€çš„çŠ¶æ€
  private async resetView(): Promise<void> {
    // â‘  æ²¡æœ‰å›¾ï¼Œç›´æ¥è¿”å›
    if (!this.pixelMap) {
      return;
    }

    // â‘¡ æ²¡æœ‰åŸå›¾å¿«ç…§ï¼šåªé‡ç½®è§†å›¾å‚æ•°ï¼ˆå…¼å®¹è€æ•°æ®ï¼‰
    if (!this.originalPixelMap) {
      this.zoom = 1.0;
      this.offsetX = 0;
      this.offsetY = 0;
      this.brightnessLevel = 0.0;
      this.contrastLevel = 0.0;
      this.accumulatedRotate = 0;
      this.pixelVersion++;
      return;
    }

    // â‘¢ åœ¨é‡ç½®ä¹‹å‰ï¼Œå…ˆæŠŠå½“å‰çŠ¶æ€æ”¾è¿›å†å²æ ˆï¼Œreset ä¹Ÿèƒ½â€œæ’¤é”€â€
    const currentPm: image.PixelMap = this.pixelMap as image.PixelMap;
    const beforeResetPm: image.PixelMap = await this.clonePixelMap(currentPm);
    await this.pushHistorySnapshot(true, beforeResetPm);

    // â‘£ ç”¨ originalPixelMap è¿˜åŸåº•å›¾ï¼ˆé‡æ–° clone ä¸€ä»½å¯ç¼–è¾‘ç‰ˆæœ¬ï¼‰
    const originalPm: image.PixelMap = this.originalPixelMap as image.PixelMap;
    const newPm: image.PixelMap = await this.clonePixelMap(originalPm);

    // é‡Šæ”¾å½“å‰åº•å›¾
    currentPm.release();

    // æ›¿æ¢ä¸ºâ€œåˆšæ‰“å¼€å›¾ç‰‡æ—¶â€çš„åº•å›¾
    this.pixelMap = newPm;

    // â‘¤ é‡å»ºç»˜åˆ¶å›¾å±‚ï¼šç›¸å½“äºæ–°å»ºä¸€å¼ å…¨é€æ˜çš„ overlay
    if (this.drawPixelMap) {
      const currentDrawPm: image.PixelMap = this.drawPixelMap as image.PixelMap;
      currentDrawPm.release();
    }
    const drawLayer: image.PixelMap = await this.createEmptyDrawLayerLike(newPm);
    this.drawPixelMap = drawLayer;
    this.drawPixelVersion++; // è§¦å‘å åŠ å±‚ Image åˆ·æ–°

    // â‘¥ è¿˜åŸè§†å›¾å‚æ•°
    this.zoom = 1.0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.brightnessLevel = 0.0;
    this.contrastLevel = 0.0;
    this.accumulatedRotate = 0;

    // â‘¦ é€šçŸ¥åº•å›¾åˆ·æ–°
    this.pixelVersion++;
  }

  // æ‰“å¼€å›¾ç‰‡ï¼ˆ
  private async pickImage() {
    try {
      // é€‰å›¾
      const picker = new photoAccessHelper.PhotoViewPicker()
      const options = new photoAccessHelper.PhotoSelectOptions()
      // åªé€‰æ‹©å›¾ç‰‡
      options.MIMEType = photoAccessHelper.PhotoViewMIMETypes.IMAGE_TYPE
      // ä¸€æ¬¡æœ€å¤šé€‰ä¸€å¼ 
      options.maxSelectNumber = 1

      // ç­‰å¾…ç”¨æˆ·é€‰æ‹©å›¾ç‰‡å¹¶æ‹¿å»ç»“æœ
      const result = await picker.select(options)
      const uris: Array<string> = result.photoUris

      // ç”¨æˆ·æœªé€‰æ‹©å›¾ç‰‡æç¤º
      if (!uris || uris.length === 0) {
        promptAction.showToast({ message: 'æœªé€‰æ‹©å›¾ç‰‡' })
        return
      }

      // å¾—åˆ°å›¾ç‰‡åœ°å€
      const uri: string = uris[0]
      console.info(`>>> Selected URI = ${uri}`)

      // ç”¨ fileIo æ‰“å¼€ uriï¼Œæ‹¿ fd
      const file = await fileIo.open(uri, fileIo.OpenMode.READ_ONLY)

      // æŠŠ fd äº¤ç»™ ImageKit è§£ç  â†’ å¾—åˆ° ImageSource
      const imgSource: image.ImageSource = image.createImageSource(file.fd)
      if (!imgSource) {
        await fileIo.close(file)
        throw new Error('createImageSource è¿”å›ç©º')
      }

      // ä» ImageSource åˆ›å»º PixelMap
      const pm: image.PixelMap = await imgSource.createPixelMap({
        editable: true
      })

      // é‡Šæ”¾åº•å±‚èµ„æº
      imgSource.release?.()
      await fileIo.close(file)

      // æ›´æ–° UI çŠ¶æ€
      // å…ˆé‡Šæ”¾æ—§çš„åŸå›¾å¿«ç…§
      if (this.originalPixelMap) {
        this.originalPixelMap.release?.()
      }
      // ä¿å­˜ä¸€ä»½â€œæ‰“å¼€æ—¶çš„åŸå›¾â€ï¼ˆä»¥å resetView å°±ç”¨å®ƒæ¥è¿˜åŸï¼‰
      this.originalPixelMap = await this.clonePixelMap(pm)

      // é‡Šæ”¾æ—§çš„å½“å‰å›¾
      if (this.pixelMap) {
        this.pixelMap.release?.()
      }
      // å½“å‰æ­£åœ¨ç¼–è¾‘çš„ PixelMap
      this.pixelMap = pm

      // åˆå§‹åŒ–è§†å›¾åˆ°â€œåˆšæ‰“å¼€â€çš„çŠ¶æ€
      this.zoom = 1.0
      this.offsetX = 0
      this.offsetY = 0
      this.brightnessLevel = 0.0
      this.contrastLevel = 0.0
      this.accumulatedRotate = 0
      this.pixelVersion++

      // ========== æ–°å¢ï¼šä¸ºè¿™å¼ å›¾ç‰‡åˆ›å»ºä¸€å±‚é€æ˜çš„ç»˜åˆ¶å±‚ ==========
      if (this.drawPixelMap) {
        this.drawPixelMap.release?.()
      }
      this.drawPixelMap = await this.createEmptyDrawLayerLike(pm)
      this.drawPixelVersion++
      // =========================================================

      promptAction.showToast({ message: 'å›¾ç‰‡å·²åŠ è½½ ' })
    } catch (err) {
      let code = 'NA'
      let message = 'unknown'

      if (typeof err === 'object' && err !== null) {
        const e = err as ErrorWithCode

        if (e.code !== undefined) {
          code = String(e.code)
        }
        if (e.message !== undefined) {
          message = String(e.message)
        }
      } else {
        message = String(err)
      }

      const msg = `code=${code} msg=${message}`
      console.error(`[pickImage] failed: ${msg}`)
      promptAction.showToast({ message: `æ‰“å¼€å¤±è´¥ï¼š${msg}` })
    }
  }

  // ä¿å­˜å›¾ç‰‡ï¼šæŠŠå½“å‰ PixelMap å†™å…¥ç³»ç»Ÿç›¸å†Œ
  private async saveImage() {
    try {
      if (!this.pixelMap) {
        promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
        return
      }

      const context = getContext(this) as common.UIAbilityContext
      const helper = photoAccessHelper.getPhotoAccessHelper(context)

      // ä¿å­˜å‰æŠŠäº®åº¦çœŸæ­£å†™è¿›åƒç´ 
      const pm: image.PixelMap = this.pixelMap as image.PixelMap
      await this.bakeToneToPixelMap(pm)

      // ä¸‹é¢ä¿æŒåŸæ¥çš„ä¿å­˜é€»è¾‘ä¸å˜ï¼Œç”¨ pm ä¿å­˜
      const uri: string = await helper.createAsset(
        photoAccessHelper.PhotoType.IMAGE,
        'jpg'
      )

      const file = await fileIo.open(
        uri,
        fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE
      )

      const packer = image.createImagePacker()
      const packOpts: image.PackingOption = {
        format: 'image/jpeg',
        quality: 90
      }

      await new Promise<void>((resolve, reject) => {
        packer.packToFile(
          pm, // â† ç”¨å·²ç»çƒ˜ç„™äº®åº¦åçš„ pixelMap
          file.fd,
          packOpts,
          (err: BusinessError) => err ? reject(err) : resolve()
        )
      })

      packer.release?.()
      await fileIo.close(file)

      promptAction.showToast({ message: 'å·²ä¿å­˜åˆ°ç›¸å†Œ ' })
    } catch (err) {
      const e = err as BusinessError
      console.error(`saveImage failed, code=${e?.code}, msg=${e?.message}`)
      promptAction.showToast({ message: 'ä¿å­˜å¤±è´¥' })
    }
  }

  private async doCrop() {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }

    const pm = this.pixelMap as image.PixelMap
    const info = await pm.getImageInfo()

    // æ±‚å®é™…æ˜¾ç¤ºå°ºå¯¸ï¼ˆè€ƒè™‘ contain + zoomï¼‰
    const scaleBase = Math.min(
      this.canvasWidth / info.size.width,
      this.canvasHeight / info.size.height
    )

    const realW = info.size.width * scaleBase * this.zoom
    const realH = info.size.height * scaleBase * this.zoom

    // å›¾ç‰‡å·¦ä¸Šè§’ï¼ˆå— offsetX/Y å½±å“ï¼‰
    const imageLeft = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop = (this.canvasHeight - realH) / 2 + this.offsetY

    // UI è£å‰ªæ¡†ï¼ˆæœªè£è¾¹ç•Œå‰ï¼‰
    let uiX1 = Math.min(this.cropStartX, this.cropEndX)
    let uiY1 = Math.min(this.cropStartY, this.cropEndY)
    let uiX2 = Math.max(this.cropStartX, this.cropEndX)
    let uiY2 = Math.max(this.cropStartY, this.cropEndY)

    // å°†è£å‰ªæ¡†é™åˆ¶åˆ°å›¾ç‰‡æ‰€åœ¨åŒºåŸŸ
    const imgX1 = imageLeft
    const imgY1 = imageTop
    const imgX2 = imageLeft + realW
    const imgY2 = imageTop + realH

    // ä¸å›¾ç‰‡æ˜¾ç¤ºåŒºåŸŸæ±‚äº¤é›†
    uiX1 = Math.max(uiX1, imgX1)
    uiY1 = Math.max(uiY1, imgY1)
    uiX2 = Math.min(uiX2, imgX2)
    uiY2 = Math.min(uiY2, imgY2)

    // è‹¥äº¤é›†æ— æ•ˆï¼Œç›´æ¥ç»“æŸ
    if (uiX2 <= uiX1 || uiY2 <= uiY1) {
      promptAction.showToast({ message: 'è£å‰ªåŒºåŸŸè¶…å‡ºå›¾ç‰‡èŒƒå›´' })
      this.cropMode = false
      return
    }

    // æ˜ å°„åˆ°åƒç´ åæ ‡
    const px1 = (uiX1 - imageLeft) * (info.size.width / realW)
    const py1 = (uiY1 - imageTop) * (info.size.height / realH)
    const px2 = (uiX2 - imageLeft) * (info.size.width / realW)
    const py2 = (uiY2 - imageTop) * (info.size.height / realH)

    const cropX = Math.max(0, Math.floor(px1))
    const cropY = Math.max(0, Math.floor(py1))
    const cropW = Math.floor(px2 - px1)
    const cropH = Math.floor(py2 - py1)

    if (cropW <= 0 || cropH <= 0) {
      promptAction.showToast({ message: 'è£å‰ªåŒºåŸŸå¤ªå°' })
      this.cropMode = false
      return
    }

    // ========= æ ¸å¿ƒä¿®æ”¹éƒ¨åˆ†å¼€å§‹ =========

    // 1) å…ˆ clone ä¸€ä»½â€œè£å‰ªå‰çš„å®Œæ•´å›¾â€ä½œä¸ºå†å²å¿«ç…§
    const backupPm = await this.clonePixelMap(pm)
    await this.pushHistorySnapshot(true, backupPm)

    // 2) åœ¨å½“å‰ pixelMap ä¸ŠåŸåœ°è£å‰ªï¼ˆä¿æŒ this.pixelMap å¼•ç”¨ä¸å˜ï¼‰
    await pm.crop({
      x: cropX,
      y: cropY,
      size: { width: cropW, height: cropH }
    })

    // ========= æ ¸å¿ƒä¿®æ”¹éƒ¨åˆ†ç»“æŸ =========

    // å®Œæˆåå¤ä½è§†å›¾
    this.cropMode = false
    this.zoom = 1
    this.offsetX = 0
    this.offsetY = 0
    this.pixelVersion++

    // æ¸…ç©ºè£å‰ªæ¡†ï¼Œé¿å…ä¸Šæ¬¡æ®‹ç•™
    this.cropStartX = 0
    this.cropStartY = 0
    this.cropEndX = 0
    this.cropEndY = 0

    promptAction.showToast({ message: 'è£å‰ªå®Œæˆ' })
  }

  private async rotateRight90(): Promise<void> {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }
    if (this.isRotating) {
      return
    }

    await this.pushHistorySnapshot(false)

    this.isRotating = true
    try {
      // â‘  æ—‹è½¬åº•å›¾
      await (this.pixelMap as image.PixelMap).rotate(90)

      // â‘¡ è‹¥æœ‰ç»˜åˆ¶å±‚ï¼Œä¹Ÿä¸€èµ·æ—‹è½¬ï¼ˆå…³é”®ï¼‰
      if (this.drawPixelMap) {
        await (this.drawPixelMap as image.PixelMap).rotate(90)
        this.drawPixelVersion++
      }

      // â‘¢ æ›´æ–°ç´¯è®¡è§’åº¦
      this.accumulatedRotate = (this.accumulatedRotate + 90) % 360

      this.pixelVersion++
    } catch (err) {
      const e = err as Error
      console.error(`rotateRight90 failed: ${e.message}`)
      promptAction.showToast({ message: 'å³æ—‹å¤±è´¥' })
    } finally {
      this.isRotating = false
    }
  }

  // å‘å·¦æ—‹è½¬ 90 åº¦ï¼ˆé€†æ—¶é’ˆï¼‰
  private async rotateLeft90(): Promise<void> {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }
    if (this.isRotating) {
      return
    }

    await this.pushHistorySnapshot(false)

    this.isRotating = true
    try {
      // â‘  åº•å›¾æ—‹è½¬
      await (this.pixelMap as image.PixelMap).rotate(270)

      // â‘¡ ç»˜åˆ¶å›¾å±‚åŒæ­¥æ—‹è½¬
      if (this.drawPixelMap) {
        await (this.drawPixelMap as image.PixelMap).rotate(270)
        this.drawPixelVersion++
      }

      // â‘¢ æ›´æ–°ç´¯è®¡è§’åº¦
      this.accumulatedRotate = (this.accumulatedRotate + 270) % 360

      this.pixelVersion++
    } catch (err) {
      const e = err as Error
      console.error(`rotateLeft90 failed: ${e.message}`)
      promptAction.showToast({ message: 'å·¦æ—‹å¤±è´¥' })
    } finally {
      this.isRotating = false
    }
  }

  // äº®åº¦è°ƒæ•´
  private async adjustBrightness(delta: number) {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }

    // è®°å½•å½“å‰äº®åº¦/å¯¹æ¯”åº¦å‚æ•°ï¼ˆä¸æ‹·è´åƒç´ ï¼‰
    await this.pushHistorySnapshot(false)

    // brightnessLevel å–ä¸€ä¸ªç›¸å¯¹æ¸©å’Œçš„åŒºé—´ï¼Œé˜²æ­¢å´©å
    this.brightnessLevel += delta

    const MAX_LEVEL: number = 0.5 // å¤§çº¦ +128
    const MIN_LEVEL: number = -0.5 // å¤§çº¦ -128

    if (this.brightnessLevel > MAX_LEVEL) {
      this.brightnessLevel = MAX_LEVEL
    }
    if (this.brightnessLevel < MIN_LEVEL) {
      this.brightnessLevel = MIN_LEVEL
    }
  }

  // æ„å»ºäº®åº¦ + å¯¹æ¯”åº¦çŸ©é˜µ
  private buildToneMatrix(): Array<number> {
    // äº®åº¦ï¼ˆå»ºè®®èŒƒå›´ [-0.5, 0.5]ï¼‰
    const b: number = this.brightnessLevel

    // å¯¹æ¯”åº¦ç³»æ•° cï¼šcontrastLevel âˆˆ [-1,1] å¯¹åº” c âˆˆ [0,2]
    const c: number = 1.0 + this.contrastLevel

    // ä¸ºäº†è®©â€œä¿æŒä¸­å¿ƒç‚¹ä¸å˜â€ï¼Œéœ€è¦é¢å¤–çš„åç§»é¡¹
    // åœ¨å½’ä¸€åŒ–[0,1]ç©ºé—´é‡Œï¼Œä¸­ç‚¹æ˜¯ 0.5ï¼š
    // new = (old - 0.5) * c + 0.5 + b
    //     = c * old + (0.5 * (1 - c) + b)
    const offset: number = 0.5 * (1.0 - c) + b

    return [
      c, 0, 0, 0, offset,
      0, c, 0, 0, offset,
      0, 0, c, 0, offset,
      0, 0, 0, 1, 0
    ]
  }

  // æŠŠå½“å‰ brightnessLevel & contrastLevel ä¸€èµ·çƒ˜ç„™åˆ° pixelMap é‡Œ
  // æ³¨æ„ï¼šè°ƒç”¨åä¼šæŠŠ brightnessLevel / contrastLevel å½’é›¶ï¼Œå¹¶è§¦å‘ä¸€æ¬¡åˆ·æ–°
  private async bakeToneToPixelMap(pm: image.PixelMap): Promise<void> {
    // æ²¡æœ‰è°ƒæ•´äº®åº¦å’Œå¯¹æ¯”åº¦å°±ä¸ç”¨åŠ¨åƒç´ ï¼Œç›´æ¥è¿”å›
    if (this.brightnessLevel === 0 && this.contrastLevel === 0) {
      return
    }

    // è¯»å‡ºåƒç´ æ•°æ®
    const info: image.ImageInfo = await pm.getImageInfo()
    const byteLength: number = pm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await pm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // åˆ¤æ–­é€šé“é¡ºåºï¼Œé˜²æ­¢é¢œè‰²é”™ä¹±
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        // B G R A
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        // A R G B
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
      // R G B A
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    // å¯¹æ¯”åº¦ç³»æ•° cï¼ˆ0~2ï¼‰ï¼Œäº®åº¦åç§» *255
    const c: number = 1.0 + this.contrastLevel
    const shiftBrightness: number = this.brightnessLevel * 255.0
    // æŠŠå…¬å¼ new = (old - 128)*c + 128 + shiftBrightness å±•å¼€ï¼š
    const shiftTotal: number = 128.0 * (1.0 - c) + shiftBrightness

    const clamp = (v: number): number => {
      if (v < 0) {
        return 0
      }
      if (v > 255) {
        return 255
      }
      return v
    }

    // éå†ä¸€æ¬¡åƒç´ ï¼ŒçœŸæ­£æ”¹æ‰ R/G/B é€šé“
    for (let i: number = 0; i < data.length; i += 4) {
      const rIndex: number = i + rOffset
      const gIndex: number = i + gOffset
      const bIndex: number = i + bOffset
      const aIndex: number = i + aOffset

      const r = data[rIndex]
      const g = data[gIndex]
      const b = data[bIndex]

      data[rIndex] = clamp(c * r + shiftTotal)
      data[gIndex] = clamp(c * g + shiftTotal)
      data[bIndex] = clamp(c * b + shiftTotal)
      // alpha åŸæ ·ä¿æŒ
      data[aIndex] = data[aIndex]
    }

    // æŠŠä¿®æ”¹åçš„åƒç´ å†™å› pixelMap
    await pm.writeBufferToPixels(buffer)

    // æŠŠçŠ¶æ€å½’é›¶ï¼šæ­¤æ—¶åº•å±‚åƒç´ å·²ç»æ˜¯â€œæ–°äº®åº¦ + æ–°å¯¹æ¯”åº¦â€
    // å†æŠŠ colorFilter çš„å‚æ•°è®¾å› 0ï¼Œè§†è§‰æ•ˆæœä¿æŒä¸å˜ï¼ˆä¸ä¼šå åŠ ä¸¤æ¬¡ï¼‰
    this.brightnessLevel = 0.0
    this.contrastLevel = 0.0
    this.pixelVersion++ // è§¦å‘ Image é‡æ–°æ¸²æŸ“ä¸€æ¬¡
  }

  // å¯¹æ¯”åº¦è°ƒæ•´
  private async adjustContrast(delta: number) {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }

    // è®°å½•å½“å‰äº®åº¦/å¯¹æ¯”åº¦å‚æ•°ï¼ˆä¸æ‹·è´åƒç´ ï¼‰
    await this.pushHistorySnapshot(false)

    this.contrastLevel += delta

    const MAX_CONTRAST: number = 1.0 // å¯¹æ¯”åº¦å¢å¼ºä¸Šé™
    const MIN_CONTRAST: number = -1.0 // å¯¹æ¯”åº¦é™ä½ä¸‹é™

    if (this.contrastLevel > MAX_CONTRAST) {
      this.contrastLevel = MAX_CONTRAST
    }
    if (this.contrastLevel < MIN_CONTRAST) {
      this.contrastLevel = MIN_CONTRAST
    }
  }

  private onClickTopMenu(menu: TopMenu) {
    // å†æ¬¡ç‚¹å‡»åŒä¸€ä¸ªæŒ‰é’®æ—¶æ”¶èµ·èœå•
    if (this.activeMenu === menu) {
      this.activeMenu = TopMenu.None
    } else {
      this.activeMenu = menu
    }
  }

  private selectShape(shape: ShapeTool) {
    // å…ˆåªè®°å½•å½“å‰å½¢çŠ¶ï¼ŒçœŸæ­£ç»˜åˆ¶é€»è¾‘ä»¥åå†åŠ 
    this.currentShape = shape
  }

  private selectBrush(brush: BrushTool) {
    // å…ˆåªè®°å½•å½“å‰ç”»ç¬”
    this.currentBrush = brush
  }

  private async undo() {
    if (this.historyIndex < 0 || this.history.length === 0) {
      promptAction.showToast({ message: 'æ²¡æœ‰å¯ä»¥æ’¤é”€çš„æ“ä½œ' })
      return
    }

    const snapshot: CanvasSnapshot = this.history[this.historyIndex]
    this.historyIndex--

    // === æƒ…å†µ 1ï¼šæœ‰ pixelMap å¿«ç…§ï¼ˆå¦‚è£å‰ªï¼‰ ===
    if (snapshot.pixelMap) {
      // æŠŠ snapshot.pixelMap å…‹éš†æˆå¯ç¼–è¾‘ç‰ˆæœ¬
      const newPm = await this.clonePixelMap(snapshot.pixelMap)

      // é‡Šæ”¾å½“å‰ pixelMapï¼ˆä¸ç­‰äº snapshot.pixelMapï¼‰
      if (this.pixelMap && this.pixelMap !== snapshot.pixelMap) {
        (this.pixelMap as image.PixelMap).release?.()
      }

      // åˆ‡æ¢åˆ°æ–°çš„ editable PixelMap
      this.pixelMap = newPm
    }

    // === æƒ…å†µ 2ï¼šæ—‹è½¬ / äº®åº¦ / å¯¹æ¯”åº¦ï¼ˆæ—  pixelMapï¼‰===
    else if (this.pixelMap) {
      const currentAngle = this.accumulatedRotate
      const targetAngle = snapshot.accumulatedRotate

      const diff = (360 + targetAngle - currentAngle) % 360
      if (diff === 90 || diff === 180 || diff === 270) {
        try {
          await (this.pixelMap as image.PixelMap).rotate(diff)
        } catch (err) {
          console.error(`undo rotateBack failed: ${JSON.stringify(err)}`)
        }
      }
    }

    // â­ æ–°å¢ï¼šæ¢å¤ç»˜åˆ¶å›¾å±‚ï¼ˆdrawPixelMapï¼‰
    if (snapshot.drawPixelMap) {
      const newDraw = await this.clonePixelMap(snapshot.drawPixelMap)

      if (this.drawPixelMap && this.drawPixelMap !== snapshot.drawPixelMap) {
        this.drawPixelMap.release?.()
      }
      this.drawPixelMap = newDraw
      this.drawPixelVersion++ // è®© Image(drawPixelMap) ä¹Ÿåˆ·æ–°
    } else {
      // è¿™ä¸€æ­¥è¡¨ç¤ºå½“æ—¶æ²¡æœ‰ç»˜åˆ¶å±‚å¿«ç…§ â†’ æ’¤é”€åˆ°ä¸€ä¸ªâ€œæ²¡æœ‰ç»˜åˆ¶å±‚â€çš„çŠ¶æ€
      if (this.drawPixelMap) {
        this.drawPixelMap.release?.()
        this.drawPixelMap = undefined
        this.drawPixelVersion++
      }
    }

    // === æ¢å¤å…¶ä»–çŠ¶æ€ï¼ˆç¼©æ”¾/å¹³ç§»/äº®åº¦/å¯¹æ¯”åº¦ç­‰ï¼‰ ===
    this.zoom = snapshot.zoom
    this.offsetX = snapshot.offsetX
    this.offsetY = snapshot.offsetY
    this.brightnessLevel = snapshot.brightnessLevel
    this.contrastLevel = snapshot.contrastLevel
    this.accumulatedRotate = snapshot.accumulatedRotate

    this.pixelVersion++
  }

  // åœ¨ã€Œç»˜åˆ¶å›¾å±‚ã€ä¸Šç”»ä¸€ä¸ªç‚¹ï¼ˆuiX/uiY æ˜¯ç”»å¸ƒä¸Šçš„ç‚¹å‡»åæ ‡ï¼‰
  private async drawPointAtUi(uiX: number, uiY: number) {
    if (!this.pixelMap) {
      return
    }

    await this.pushHistorySnapshot(false)

    // 1. ç”»å¸ƒå°ºå¯¸é˜²å¾¡
    if (this.canvasWidth <= 0 || this.canvasHeight <= 0) {
      console.info('>>> drawPointAtUi: canvas size is 0, skip')
      return
    }

    // 2. å¿…é¡»å·²ç»æœ‰ç»˜åˆ¶å›¾å±‚ï¼ˆåœ¨ pickImage é‡Œåˆ›å»ºï¼‰
    if (!this.drawPixelMap) {
      promptAction.showToast({ message: 'ç»˜åˆ¶å›¾å±‚ä¸å­˜åœ¨ï¼Œè¯·é‡æ–°æ‰“å¼€å›¾ç‰‡' })
      return
    }

    const basePm = this.pixelMap as image.PixelMap
    const baseInfo: image.ImageInfo = await basePm.getImageInfo()

    const imgW: number = baseInfo.size.width
    const imgH: number = baseInfo.size.height

    // ===== 1) UI -> åƒç´  åæ ‡æ˜ å°„ =====
    const scaleBase: number = Math.min(
      this.canvasWidth / imgW,
      this.canvasHeight / imgH
    )

    if (scaleBase <= 0) {
      console.info('>>> drawPointAtUi: scaleBase <= 0, skip')
      return
    }

    const realW: number = imgW * scaleBase * this.zoom
    const realH: number = imgH * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const pxFloat: number = (uiX - imageLeft) * (imgW / realW)
    const pyFloat: number = (uiY - imageTop) * (imgH / realH)

    const px: number = Math.floor(pxFloat)
    const py: number = Math.floor(pyFloat)

    console.info(`>>> drawPointAtUi: ui=(${uiX.toFixed(1)}, ${uiY.toFixed(1)}) -> pixel=(${px}, ${py})`)

    if (px < 0 || py < 0 || px >= imgW || py >= imgH) {
      // ç‚¹å‡»åœ¨å›¾ç‰‡å¤–é¢ï¼Œç›´æ¥ä¸¢å¼ƒ
      return
    }

    // ===== 2) åœ¨ã€Œç»˜åˆ¶å›¾å±‚ã€ä¸Šæ”¹åƒç´  =====
    const layerPm: image.PixelMap = this.drawPixelMap as image.PixelMap
    const info: image.ImageInfo = await layerPm.getImageInfo()
    const width: number = info.size.width
    const height: number = info.size.height

    if (px < 0 || py < 0 || px >= width || py >= height) {
      console.info('>>> drawPointAtUi: pixel out of layer range')
      return
    }

    const byteLength: number = layerPm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await layerPm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // é€šé“é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const radius: number = this.strokeWidth > 0 ? this.strokeWidth : 4
    const alpha: number = this.getStrokeAlpha()

    for (let yy: number = py - radius; yy <= py + radius; yy++) {
      if (yy < 0 || yy >= height) {
        continue
      }
      for (let xx: number = px - radius; xx <= px + radius; xx++) {
        if (xx < 0 || xx >= width) {
          continue
        }

        const dx: number = xx - px
        const dy: number = yy - py
        if (dx * dx + dy * dy > radius * radius) {
          continue
        }

        const baseIndex: number = (yy * width + xx) * 4
        const rIndex: number = baseIndex + rOffset
        const gIndex: number = baseIndex + gOffset
        const bIndex: number = baseIndex + bOffset
        const aIndex: number = baseIndex + aOffset

        if (this.currentBrush === BrushTool.Eraser) {
          // æ©¡çš®æ“¦ï¼šåªæ“¦æ‰ç»˜åˆ¶å±‚çš„ alpha
          data[aIndex] = 0
        } else {
          data[rIndex] = this.strokeR
          data[gIndex] = this.strokeG
          data[bIndex] = this.strokeB
          data[aIndex] = alpha
        }
      }
    }

    // ===== 3) å†™å› + æ¢ä¸€ä¸ªæ–°çš„ PixelMap å¼•ç”¨ï¼Œå¼ºåˆ¶ UI åˆ·æ–° =====
    await layerPm.writeBufferToPixels(buffer)

    // å’Œä½ å¯¹ä¸»å›¾çš„åšæ³•ä¿æŒä¸€è‡´ï¼šclone ä¸€ä»½æ–°çš„ï¼Œèµ‹ç»™ @State
    const newLayer: image.PixelMap = await this.clonePixelMap(layerPm)
    // æ—§çš„å›¾å±‚å¯ä»¥é‡Šæ”¾ï¼ˆå¯é€‰ï¼‰
    if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
      this.drawPixelMap.release?.()
    }
    this.drawPixelMap = newLayer

    console.info(`>>> draw layer created: size=${(await this.drawPixelMap!.getImageInfo()).size.width}x${(await this.drawPixelMap!.getImageInfo()).size.height}`)


    this.drawPixelVersion++ // id(`draw-${drawPixelVersion}`) ä¹Ÿä¸€èµ·å˜
  }

  // ç›´çº¿å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œåœ¨è¿™é‡Œè½¬æ¢æˆåƒç´ å¹¶ç”»çº¿
  // ç›´çº¿å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œåœ¨è¿™é‡Œè½¬æ¢æˆåƒç´ å¹¶åœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»çº¿
  private async handleLineDrag(startUiX: number, startUiY: number, endUiX: number, endUiY: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    const pm: image.PixelMap = this.pixelMap as image.PixelMap
    const info: image.ImageInfo = await pm.getImageInfo()

    // â€”â€” UI â†’ åƒç´ ï¼ˆå’Œç”»ç‚¹å®Œå…¨ä¸€è‡´çš„æ˜ å°„é€»è¾‘ï¼‰â€”â€”
    const scaleBase: number = Math.min(
      this.canvasWidth / info.size.width,
      this.canvasHeight / info.size.height
    )

    const realW: number = info.size.width * scaleBase * this.zoom
    const realH: number = info.size.height * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const startPxFloat: number = (startUiX - imageLeft) * (info.size.width / realW)
    const startPyFloat: number = (startUiY - imageTop) * (info.size.height / realH)
    const endPxFloat: number = (endUiX - imageLeft) * (info.size.width / realW)
    const endPyFloat: number = (endUiY - imageTop) * (info.size.height / realH)

    const x0: number = Math.floor(startPxFloat)
    const y0: number = Math.floor(startPyFloat)
    const x1: number = Math.floor(endPxFloat)
    const y1: number = Math.floor(endPyFloat)

    console.info(
      `>>> handleLineDrag uiStart=(${startUiX.toFixed(1)},${startUiY.toFixed(1)}), ` +
        `uiEnd=(${endUiX.toFixed(1)},${endUiY.toFixed(1)}) -> ` +
        `pixelStart=(${x0},${y0}), pixelEnd=(${x1},${y1}), imgSize=(${info.size.width},${info.size.height})`
    )

    // å°è¯•ç¡®ä¿æœ‰ç»˜åˆ¶å›¾å±‚ï¼ˆè¿™é‡Œä¸ç›´æ¥ç”¨è¿”å›å€¼ï¼Œåªåšå­˜åœ¨æ€§æ£€æŸ¥ï¼‰
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      return
    }

    // äº¤ç»™ä¸“é—¨å‡½æ•°åœ¨â€œç»˜åˆ¶å›¾å±‚â€ä¸Šç”»çº¿
    await this.drawLineBetweenPixels(x0, y0, x1, y1)

    promptAction.showToast({ message: 'ç›´çº¿å·²ç»˜åˆ¶' })
  }

  // åœ¨ç»˜åˆ¶å›¾å±‚ drawPixelMap ä¸Šç”»ä¸€æ¡â€œå¸¦ç²—ç»†çš„ç›´çº¿â€
  private async drawLineBetweenPixels(x0: number, y0: number, x1: number, y1: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    // â­ å’Œç”»ç‚¹ä¸€æ ·ï¼Œå…ˆè®°å½•ä¸€æ¬¡å†å²å¿«ç…§ï¼ˆåªè®°å½•çŠ¶æ€ + ç»˜åˆ¶å±‚ï¼‰
    await this.pushHistorySnapshot(false)

    // 1. ç”¨åº•å›¾åšä¸€æ¬¡å°ºå¯¸è¾¹ç•Œæ£€æŸ¥ï¼ˆæ­£å¸¸å’Œç»˜åˆ¶å±‚ä¸€è‡´ï¼‰
    const basePm: image.PixelMap = this.pixelMap as image.PixelMap
    const baseInfo: image.ImageInfo = await basePm.getImageInfo()
    const baseW: number = baseInfo.size.width
    const baseH: number = baseInfo.size.height

    if (
      x0 < 0 || y0 < 0 || x0 >= baseW || y0 >= baseH ||
        x1 < 0 || y1 < 0 || x1 >= baseW || y1 >= baseH
    ) {
      console.info('>>> drawLineBetweenPixels: endpoints out of base range, skip')
      return
    }

    // 2. åªåœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»çº¿
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      return
    }

    const info: image.ImageInfo = await layerPm.getImageInfo()
    const width: number = info.size.width
    const height: number = info.size.height

    if (
      x0 < 0 || y0 < 0 || x0 >= width || y0 >= height ||
        x1 < 0 || y1 < 0 || x1 >= width || y1 >= height
    ) {
      console.info('>>> drawLineBetweenPixels: endpoints out of layer range, skip')
      return
    }

    // 3. è¯»å–ç»˜åˆ¶å±‚åƒç´ 
    const byteLength: number = layerPm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await layerPm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // 4. é€šé“é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const radius: number = this.strokeWidth > 0 ? this.strokeWidth : 4
    const alpha: number = this.getStrokeAlpha()

    const drawThickPoint = (cx: number, cy: number): void => {
      for (let yy: number = cy - radius; yy <= cy + radius; yy++) {
        if (yy < 0 || yy >= height) {
          continue
        }
        for (let xx: number = cx - radius; xx <= cx + radius; xx++) {
          if (xx < 0 || xx >= width) {
            continue
          }

          const dx: number = xx - cx
          const dy: number = yy - cy
          if (dx * dx + dy * dy > radius * radius) {
            continue
          }

          const baseIndex: number = (yy * width + xx) * 4
          const rIndex: number = baseIndex + rOffset
          const gIndex: number = baseIndex + gOffset
          const bIndex: number = baseIndex + bOffset
          const aIndex: number = baseIndex + aOffset

          if (this.currentBrush === BrushTool.Eraser) {
            // æ©¡çš®æ“¦ï¼šåªæ“¦ç»˜åˆ¶å±‚ï¼Œå˜æˆé€æ˜
            data[aIndex] = 0
          } else {
            data[rIndex] = this.strokeR
            data[gIndex] = this.strokeG
            data[bIndex] = this.strokeB
            data[aIndex] = alpha
          }
        }
      }
    }

    // 5. Bresenham ç”»çº¿
    let curX: number = x0
    let curY: number = y0
    const dx: number = Math.abs(x1 - x0)
    const sx: number = x0 < x1 ? 1 : -1
    const dy: number = -Math.abs(y1 - y0)
    const sy: number = y0 < y1 ? 1 : -1
    let err: number = dx + dy

    // eslint-disable-next-line no-constant-condition
    while (true) {
      drawThickPoint(curX, curY)

      if (curX === x1 && curY === y1) {
        break
      }

      const e2: number = 2 * err
      if (e2 >= dy) {
        err += dy
        curX += sx
      }
      if (e2 <= dx) {
        err += dx
        curY += sy
      }
    }

    // 6. å†™å›ç»˜åˆ¶å±‚åƒç´ 
    await layerPm.writeBufferToPixels(buffer)

    // â­ å…³é”®ï¼šå’Œç”»ç‚¹ä¸€æ ·ï¼Œclone ä¸€å¼ æ–°çš„å›¾å±‚ï¼Œæ¢å¼•ç”¨ï¼Œå¼ºåˆ¶ UI åˆ·æ–°
    const newLayer: image.PixelMap = await this.clonePixelMap(layerPm)

    if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
      this.drawPixelMap.release?.()
    }
    this.drawPixelMap = newLayer

    this.drawPixelVersion++ // id("draw-xxx") å˜åŒ–ï¼Œå åŠ å±‚ Image ä¼šé‡å»º

    console.info(`>>> drawLineBetweenPixels: line drawn, drawPixelVersion=${this.drawPixelVersion}`)
  }

  // çŸ©å½¢å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œåœ¨è¿™é‡Œè½¬æˆåƒç´ å¹¶ç”»çŸ©å½¢
  private async handleRectDrag(startUiX: number, startUiY: number, endUiX: number, endUiY: number) {
    if (!this.pixelMap) {
      return
    }

    const pm = this.pixelMap as image.PixelMap
    const info: image.ImageInfo = await pm.getImageInfo()

    // â€”â€” UI â†’ åƒç´ ï¼ˆå’Œç”»ç‚¹ / ç”»ç›´çº¿ä¿æŒå®Œå…¨ä¸€è‡´çš„æ˜ å°„é€»è¾‘ï¼‰â€”â€”
    const scaleBase: number = Math.min(
      this.canvasWidth / info.size.width,
      this.canvasHeight / info.size.height
    )

    const realW: number = info.size.width * scaleBase * this.zoom
    const realH: number = info.size.height * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const startPxFloat: number = (startUiX - imageLeft) * (info.size.width / realW)
    const startPyFloat: number = (startUiY - imageTop) * (info.size.height / realH)
    const endPxFloat: number = (endUiX - imageLeft) * (info.size.width / realW)
    const endPyFloat: number = (endUiY - imageTop) * (info.size.height / realH)

    const x0: number = Math.floor(startPxFloat)
    const y0: number = Math.floor(startPyFloat)
    const x1: number = Math.floor(endPxFloat)
    const y1: number = Math.floor(endPyFloat)

    console.info(
      `>>> handleRectDrag uiStart=(${startUiX.toFixed(1)},${startUiY.toFixed(1)}), ` +
        `uiEnd=(${endUiX.toFixed(1)},${endUiY.toFixed(1)}) -> ` +
        `pixelStart=(${x0},${y0}), pixelEnd=(${x1},${y1}), imgSize=(${info.size.width},${info.size.height})`
    )

    // è¿™é‡Œä¸å¼ºåˆ¶è¦æ±‚å®Œå…¨åœ¨å›¾å†…ï¼ŒçœŸæ­£çš„è¾¹ç•Œè£å‰ªäº¤ç»™ drawRectBetweenPixels å»åš

    // 1ï¼‰ä¿®æ”¹å‰å…ˆæŠŠå½“å‰æ•´å›¾å‹å…¥æ’¤é”€æ ˆï¼ˆå¯æ’¤å›ï¼‰
    // 1ï¼‰ä¿®æ”¹å‰ï¼šåªè®°å½•çŠ¶æ€ + ç»˜åˆ¶å±‚å¿«ç…§ï¼ˆåº•å›¾ä¸åŠ¨ï¼‰
    await this.pushHistorySnapshot(false)

    // 2ï¼‰åœ¨ç»˜åˆ¶å±‚ä¸Šç”»çŸ©å½¢
    await this.drawRectBetweenPixels(x0, y0, x1, y1)

    promptAction.showToast({ message: 'çŸ©å½¢å·²ç»˜åˆ¶' })
  }

  // åœ¨åƒç´ åæ ‡é‡Œç”»ä¸€ä¸ªçŸ©å½¢è¾¹æ¡†ï¼ˆä½¿ç”¨å½“å‰ stroke å®½åº¦å’Œé¢œè‰²ï¼‰
  // åœ¨ç»˜åˆ¶å›¾å±‚ drawPixelMap ä¸Šç”»ä¸€ä¸ªçŸ©å½¢è¾¹æ¡†ï¼ˆä½¿ç”¨å½“å‰ stroke å®½åº¦å’Œé¢œè‰²ï¼‰
  private async drawRectBetweenPixels(x0: number, y0: number, x1: number, y1: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    // 1ï¼‰å…ˆç”¨åº•å›¾åšä¸€æ¬¡å°ºå¯¸è¾¹ç•Œæ£€æŸ¥
    const basePm: image.PixelMap = this.pixelMap as image.PixelMap
    const baseInfo: image.ImageInfo = await basePm.getImageInfo()
    const baseW: number = baseInfo.size.width
    const baseH: number = baseInfo.size.height

    // å½’ä¸€åŒ–æˆå·¦ä¸Š / å³ä¸‹
    let left: number = Math.min(x0, x1)
    let right: number = Math.max(x0, x1)
    let top: number = Math.min(y0, y1)
    let bottom: number = Math.max(y0, y1)

    // è£å‰ªåœ¨å›¾ç‰‡èŒƒå›´ä¹‹å†…ï¼ˆç”¨åº•å›¾å°ºå¯¸ï¼‰
    left = Math.max(0, left)
    right = Math.min(baseW - 1, right)
    top = Math.max(0, top)
    bottom = Math.min(baseH - 1, bottom)

    if (left >= right || top >= bottom) {
      console.info('>>> drawRectBetweenPixels: rect too small, skip')
      return
    }

    // 2ï¼‰åªåœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»çŸ©å½¢
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      return
    }

    const info: image.ImageInfo = await layerPm.getImageInfo()
    const width: number = info.size.width
    const height: number = info.size.height

    // 3ï¼‰è¯»ç»˜åˆ¶å±‚çš„åƒç´ 
    const byteLength: number = layerPm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await layerPm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // 4ï¼‰ç¡®å®šé€šé“é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const radius: number = this.strokeWidth > 0 ? this.strokeWidth : 4
    const alpha: number = this.getStrokeAlpha()

    const drawThickPoint = (cx: number, cy: number): void => {
      for (let yy: number = cy - radius; yy <= cy + radius; yy++) {
        if (yy < 0 || yy >= height) {
          continue
        }
        for (let xx: number = cx - radius; xx <= cx + radius; xx++) {
          if (xx < 0 || xx >= width) {
            continue
          }

          const dx: number = xx - cx
          const dy: number = yy - cy
          if (dx * dx + dy * dy > radius * radius) {
            continue
          }

          const baseIndex: number = (yy * width + xx) * 4
          const rIndex: number = baseIndex + rOffset
          const gIndex: number = baseIndex + gOffset
          const bIndex: number = baseIndex + bOffset
          const aIndex: number = baseIndex + aOffset

          if (this.currentBrush === BrushTool.Eraser) {
            // æ©¡çš®æ“¦ï¼šåªæ“¦ç»˜åˆ¶å±‚çš„ alpha
            data[aIndex] = 0
          } else {
            data[rIndex] = this.strokeR
            data[gIndex] = this.strokeG
            data[bIndex] = this.strokeB
            data[aIndex] = alpha
          }
        }
      }
    }

    // 5ï¼‰ç”»å››æ¡è¾¹ï¼šä¸Šã€ä¸‹ã€å·¦ã€å³
    for (let x: number = left; x <= right; x++) {
      drawThickPoint(x, top) // ä¸Šè¾¹
      drawThickPoint(x, bottom) // ä¸‹è¾¹
    }
    for (let y: number = top; y <= bottom; y++) {
      drawThickPoint(left, y) // å·¦è¾¹
      drawThickPoint(right, y) // å³è¾¹
    }

    // 6ï¼‰å†™å›ç»˜åˆ¶å±‚åƒç´ 
    await layerPm.writeBufferToPixels(buffer)

    // 7ï¼‰clone ä¸€ä»½æ–°çš„ç»˜åˆ¶å±‚ï¼Œæ¢å¼•ç”¨ï¼Œå¼ºåˆ¶ UI åˆ·æ–°
    const newLayer: image.PixelMap = await this.clonePixelMap(layerPm)
    if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
      this.drawPixelMap.release?.()
    }
    this.drawPixelMap = newLayer
    this.drawPixelVersion++ // è§¦å‘ Image(drawPixelMap) é‡å»º

    console.info(`>>> drawRectBetweenPixels: rect drawn, drawPixelVersion=${this.drawPixelVersion}`)
  }

  // åœ¨åƒç´ åæ ‡é‡Œç”»ä¸€ä¸ªåœ†å½¢è¾¹æ¡†ï¼ˆä½¿ç”¨å½“å‰ stroke å®½åº¦å’Œé¢œè‰²ï¼‰
  // è¿™é‡Œä¼ å…¥çš„æ˜¯åœ†çš„å¤–æ¥æ­£æ–¹å½¢çš„å·¦ä¸Š / å³ä¸‹
  // è¿™é‡Œä¼ å…¥çš„æ˜¯åœ†çš„å¤–æ¥æ­£æ–¹å½¢çš„å·¦ä¸Š / å³ä¸‹ï¼Œåœ¨â€œç»˜åˆ¶å›¾å±‚â€ä¸Šç”»åœ†
  private async drawCircleBetweenPixels(left: number, top: number, right: number, bottom: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    // ç”¨åº•å›¾åšä¸€æ¬¡è¾¹ç•Œè£å‰ªï¼ˆå°ºå¯¸ä¸ç»˜åˆ¶å±‚ä¸€è‡´ï¼‰
    const basePm: image.PixelMap = this.pixelMap as image.PixelMap
    const baseInfo: image.ImageInfo = await basePm.getImageInfo()
    const baseW: number = baseInfo.size.width
    const baseH: number = baseInfo.size.height

    left = Math.max(0, left)
    right = Math.min(baseW - 1, right)
    top = Math.max(0, top)
    bottom = Math.min(baseH - 1, bottom)

    const w: number = right - left
    const h: number = bottom - top
    const side: number = Math.min(w, h)

    if (side <= 0) {
      console.info('>>> drawCircleBetweenPixels: side too small, skip')
      return
    }

    // ç”¨æ­£æ–¹å½¢åŒ…ä½åœ†
    right = left + side
    bottom = top + side

    const cx: number = Math.round((left + right) / 2)
    const cy: number = Math.round((top + bottom) / 2)
    const radius: number = side / 2

    // â‘¡ åœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»åœ†
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      return
    }

    const info: image.ImageInfo = await layerPm.getImageInfo()
    const width: number = info.size.width
    const height: number = info.size.height

    // 1ï¼‰è¯»ç»˜åˆ¶å±‚åƒç´ 
    const byteLength: number = layerPm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await layerPm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // 2ï¼‰é€šé“é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const strokeRadius: number = this.strokeWidth > 0 ? this.strokeWidth : 4
    const alpha: number = this.getStrokeAlpha()

    const drawThickPoint = (px: number, py: number): void => {
      for (let yy: number = py - strokeRadius; yy <= py + strokeRadius; yy++) {
        if (yy < 0 || yy >= height) {
          continue
        }
        for (let xx: number = px - strokeRadius; xx <= px + strokeRadius; xx++) {
          if (xx < 0 || xx >= width) {
            continue
          }
          const dx: number = xx - px
          const dy: number = yy - py
          if (dx * dx + dy * dy > strokeRadius * strokeRadius) {
            continue
          }

          const baseIndex: number = (yy * width + xx) * 4
          const rIndex: number = baseIndex + rOffset
          const gIndex: number = baseIndex + gOffset
          const bIndex: number = baseIndex + bOffset
          const aIndex: number = baseIndex + aOffset

          if (this.currentBrush === BrushTool.Eraser) {
            // æ©¡çš®æ“¦ï¼šåªæ“¦æ‰ç»˜åˆ¶å±‚ alpha
            data[aIndex] = 0
          } else {
            data[rIndex] = this.strokeR
            data[gIndex] = this.strokeG
            data[bIndex] = this.strokeB
            data[aIndex] = alpha
          }
        }
      }
    }

    // 3ï¼‰ç”¨å‚æ•°æ–¹ç¨‹ç”»ä¸€åœˆï¼šx = cx + r cos t, y = cy + r sin t
    const TWO_PI: number = Math.PI * 2
    // æ­¥æ•°ä¸åŠå¾„æˆæ¯”ä¾‹ï¼Œä¿è¯è¶Šå¤§è¶Šå¹³æ»‘
    const steps: number = Math.max(36, Math.floor(TWO_PI * radius / 2))

    for (let i: number = 0; i < steps; i++) {
      const t: number = (TWO_PI * i) / steps
      const px: number = Math.round(cx + radius * Math.cos(t))
      const py: number = Math.round(cy + radius * Math.sin(t))

      if (px < 0 || px >= width || py < 0 || py >= height) {
        continue
      }
      drawThickPoint(px, py)
    }

    // 4ï¼‰å†™å›ç»˜åˆ¶å±‚åƒç´ 
    await layerPm.writeBufferToPixels(buffer)

    // 5ï¼‰clone ä¸€ä»½æ–°çš„ç»˜åˆ¶å±‚ï¼Œè§¦å‘ UI åˆ·æ–°
    const newLayer: image.PixelMap = await this.clonePixelMap(layerPm)
    if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
      this.drawPixelMap.release?.()
    }
    this.drawPixelMap = newLayer
    this.drawPixelVersion++ // å åŠ å±‚ Image é‡æ–°æ¸²æŸ“

    console.info(`>>> drawCircleBetweenPixels: circle drawn, drawPixelVersion=${this.drawPixelVersion}`)
  }

  // åœ†å½¢å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œè½¬æˆåƒç´ å¹¶ç”»åœ†
  // åœ†å½¢å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œè½¬æˆåƒç´ å¹¶ç”»åœ†ï¼ˆç»˜åˆ¶åœ¨ overlayï¼‰
  private async handleCircleDrag(startUiX: number, startUiY: number, endUiX: number, endUiY: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    const pm: image.PixelMap = this.pixelMap as image.PixelMap
    const info: image.ImageInfo = await pm.getImageInfo()

    // â€”â€” UI â†’ åƒç´ ï¼ˆå’Œç‚¹ / ç›´çº¿ / çŸ©å½¢ä¿æŒä¸€è‡´ï¼‰â€”â€”
    const scaleBase: number = Math.min(
      this.canvasWidth / info.size.width,
      this.canvasHeight / info.size.height
    )

    const realW: number = info.size.width * scaleBase * this.zoom
    const realH: number = info.size.height * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const startPxFloat: number = (startUiX - imageLeft) * (info.size.width / realW)
    const startPyFloat: number = (startUiY - imageTop) * (info.size.height / realH)
    const endPxFloat: number = (endUiX - imageLeft) * (info.size.width / realW)
    const endPyFloat: number = (endUiY - imageTop) * (info.size.height / realH)

    const x0: number = Math.floor(startPxFloat)
    const y0: number = Math.floor(startPyFloat)
    const x1: number = Math.floor(endPxFloat)
    const y1: number = Math.floor(endPyFloat)

    console.info(
      `>>> handleCircleDrag uiStart=(${startUiX.toFixed(1)},${startUiY.toFixed(1)}), ` +
        `uiEnd=(${endUiX.toFixed(1)},${endUiY.toFixed(1)}) -> ` +
        `pixelStart=(${x0},${y0}), pixelEnd=(${x1},${y1}), imgSize=(${info.size.width},${info.size.height})`
    )

    // 1ï¼‰å…ˆæ±‚å‡ºæ‹–å‡ºçŸ©å½¢çš„å·¦/å³/ä¸Š/ä¸‹
    let left: number = Math.min(x0, x1)
    let right: number = Math.max(x0, x1)
    let top: number = Math.min(y0, y1)
    let bottom: number = Math.max(y0, y1)

    const boxW: number = right - left
    const boxH: number = bottom - top
    const side: number = Math.min(Math.abs(boxW), Math.abs(boxH))

    if (side <= 0) {
      console.info('>>> handleCircleDrag: side too small, skip')
      return
    }

    // ç”¨å·¦ä¸Šè§’ + side æ„é€ ä¸€ä¸ªæ­£æ–¹å½¢åŒºåŸŸ
    right = left + side
    bottom = top + side

    // 2ï¼‰ä¿®æ”¹å‰å‹å…¥æ’¤é”€æ ˆï¼šåªè®°å½•çŠ¶æ€ + ç»˜åˆ¶å±‚å¿«ç…§ï¼ˆåº•å›¾ä¸åŠ¨ï¼‰
    await this.pushHistorySnapshot(false)

    // 3ï¼‰çœŸæ­£ç”»åœ†ï¼ˆåœ¨ç»˜åˆ¶å›¾å±‚ä¸Šï¼‰
    await this.drawCircleBetweenPixels(left, top, right, bottom)

    promptAction.showToast({ message: 'åœ†å½¢å·²ç»˜åˆ¶' })
  }

  // æ¤­åœ†å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œè½¬æˆåƒç´ å¹¶ç”»æ¤­åœ†
  // æ¤­åœ†å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œè½¬æˆåƒç´ å¹¶åœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»æ¤­åœ†
  private async handleEllipseDrag(startUiX: number, startUiY: number, endUiX: number, endUiY: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    const pm: image.PixelMap = this.pixelMap as image.PixelMap
    const info: image.ImageInfo = await pm.getImageInfo()

    const scaleBase: number = Math.min(
      this.canvasWidth / info.size.width,
      this.canvasHeight / info.size.height
    )

    const realW: number = info.size.width * scaleBase * this.zoom
    const realH: number = info.size.height * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const startPxFloat: number = (startUiX - imageLeft) * (info.size.width / realW)
    const startPyFloat: number = (startUiY - imageTop) * (info.size.height / realH)
    const endPxFloat: number = (endUiX - imageLeft) * (info.size.width / realW)
    const endPyFloat: number = (endUiY - imageTop) * (info.size.height / realH)

    const x0: number = Math.floor(startPxFloat)
    const y0: number = Math.floor(startPyFloat)
    const x1: number = Math.floor(endPxFloat)
    const y1: number = Math.floor(endPyFloat)

    console.info(
      `>>> handleEllipseDrag uiStart=(${startUiX.toFixed(1)},${startUiY.toFixed(1)}), ` +
        `uiEnd=(${endUiX.toFixed(1)},${endUiY.toFixed(1)}) -> ` +
        `pixelStart=(${x0},${y0}), pixelEnd=(${x1},${y1}), imgSize=(${info.size.width},${info.size.height})`
    )

    let left: number = Math.min(x0, x1)
    let right: number = Math.max(x0, x1)
    let top: number = Math.min(y0, y1)
    let bottom: number = Math.max(y0, y1)

    if (right - left <= 0 || bottom - top <= 0) {
      console.info('>>> handleEllipseDrag: rect too small, skip')
      return
    }

    // 1ï¼‰ä¿®æ”¹å‰å‹å…¥æ’¤é”€æ ˆï¼šåªè®°å½•çŠ¶æ€ + ç»˜åˆ¶å±‚å¿«ç…§ï¼ˆåº•å›¾ä¸åŠ¨ï¼‰
    await this.pushHistorySnapshot(false)

    // 2ï¼‰çœŸæ­£åœ¨ç»˜åˆ¶å›¾å±‚é‡Œç”»æ¤­åœ†
    await this.drawEllipseBetweenPixels(left, top, right, bottom)

    promptAction.showToast({ message: 'æ¤­åœ†å·²ç»˜åˆ¶' })
  }

  // åœ¨åƒç´ åæ ‡é‡Œç”»ä¸€ä¸ªæ¤­åœ†è¾¹æ¡†ï¼ˆä½¿ç”¨å½“å‰ stroke å®½åº¦å’Œé¢œè‰²ï¼‰
  // ä¼ å…¥çš„æ˜¯æ¤­åœ†å¤–æ¥çŸ©å½¢å·¦ä¸Š / å³ä¸‹
  // åœ¨åƒç´ åæ ‡é‡Œç”»ä¸€ä¸ªæ¤­åœ†è¾¹æ¡†ï¼ˆä½¿ç”¨å½“å‰ stroke å®½åº¦å’Œé¢œè‰²ï¼‰
  // ä¼ å…¥çš„æ˜¯æ¤­åœ†å¤–æ¥çŸ©å½¢å·¦ä¸Š / å³ä¸‹ï¼Œå®é™…ç»˜åˆ¶åœ¨ drawPixelMap ä¸Š
  private async drawEllipseBetweenPixels(left: number, top: number, right: number, bottom: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    // å…ˆç”¨åº•å›¾åšä¸€æ¬¡è¾¹ç•Œè£å‰ªï¼ˆå°ºå¯¸ä¸ç»˜åˆ¶å±‚ä¸€è‡´ï¼‰
    const basePm: image.PixelMap = this.pixelMap as image.PixelMap
    const baseInfo: image.ImageInfo = await basePm.getImageInfo()
    const baseW: number = baseInfo.size.width
    const baseH: number = baseInfo.size.height

    left = Math.max(0, left)
    right = Math.min(baseW - 1, right)
    top = Math.max(0, top)
    bottom = Math.min(baseH - 1, bottom)

    const w: number = right - left
    const h: number = bottom - top

    if (w <= 0 || h <= 0) {
      console.info('>>> drawEllipseBetweenPixels: rect too small, skip')
      return
    }

    const cx: number = Math.round((left + right) / 2)
    const cy: number = Math.round((top + bottom) / 2)
    const rx: number = w / 2
    const ry: number = h / 2

    // â‘¡ åœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»æ¤­åœ†
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      return
    }

    const info: image.ImageInfo = await layerPm.getImageInfo()
    const width: number = info.size.width
    const height: number = info.size.height

    // 1ï¼‰è¯»ç»˜åˆ¶å±‚åƒç´ 
    const byteLength: number = layerPm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await layerPm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // 2ï¼‰é€šé“é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const thickRadius: number = this.strokeWidth > 0 ? this.strokeWidth : 4
    const alpha: number = this.getStrokeAlpha()

    const drawThickPoint = (px: number, py: number): void => {
      for (let yy: number = py - thickRadius; yy <= py + thickRadius; yy++) {
        if (yy < 0 || yy >= height) {
          continue
        }
        for (let xx: number = px - thickRadius; xx <= px + thickRadius; xx++) {
          if (xx < 0 || xx >= width) {
            continue
          }
          const dx: number = xx - px
          const dy: number = yy - py
          if (dx * dx + dy * dy > thickRadius * thickRadius) {
            continue
          }

          const baseIndex: number = (yy * width + xx) * 4
          const rIndex: number = baseIndex + rOffset
          const gIndex: number = baseIndex + gOffset
          const bIndex: number = baseIndex + bOffset
          const aIndex: number = baseIndex + aOffset

          if (this.currentBrush === BrushTool.Eraser) {
            // æ©¡çš®æ“¦ï¼šåªæ“¦ç»˜åˆ¶å±‚ï¼Œè®©å®ƒé€æ˜
            data[aIndex] = 0
          } else {
            data[rIndex] = this.strokeR
            data[gIndex] = this.strokeG
            data[bIndex] = this.strokeB
            data[aIndex] = alpha
          }
        }
      }
    }

    // 3ï¼‰å‚æ•°æ–¹ç¨‹æ¤­åœ†ï¼šx = cx + rx cos t, y = cy + ry sin t
    const TWO_PI: number = Math.PI * 2
    const maxR: number = Math.max(rx, ry)
    const steps: number = Math.max(36, Math.floor(TWO_PI * maxR / 2))

    for (let i: number = 0; i < steps; i++) {
      const t: number = (TWO_PI * i) / steps
      const px: number = Math.round(cx + rx * Math.cos(t))
      const py: number = Math.round(cy + ry * Math.sin(t))

      if (px < 0 || px >= width || py < 0 || py >= height) {
        continue
      }
      drawThickPoint(px, py)
    }

    // 4ï¼‰å†™å›ç»˜åˆ¶å±‚åƒç´ 
    await layerPm.writeBufferToPixels(buffer)

    // 5ï¼‰clone ä¸€å¼ æ–°çš„ç»˜åˆ¶å±‚è§¦å‘åˆ·æ–°
    const newLayer: image.PixelMap = await this.clonePixelMap(layerPm)
    if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
      this.drawPixelMap.release?.()
    }
    this.drawPixelMap = newLayer
    this.drawPixelVersion++

    console.info(`>>> drawEllipseBetweenPixels: ellipse drawn, drawPixelVersion=${this.drawPixelVersion}`)
  }

  // åœ¨è‡ªç”±ç»˜åˆ¶æ—¶ï¼Œæ¯ä¸€å°æ®µæ‰‹åŠ¿ç§»åŠ¨ï¼Œå®æ—¶ç”»åˆ°å†…å­˜ buffer é‡Œï¼ˆåŒæ­¥ï¼‰
  private drawFreeStrokeSegmentSync(
    prevUiX: number,
    prevUiY: number,
    curUiX: number,
    curUiY: number
  ): void {
    // è¿™é‡Œè¦æ±‚ï¼šå·²ç»åœ¨æ‰‹åŠ¿å¼€å§‹çš„æ—¶å€™åˆå§‹åŒ–å¥½ freeDrawArrayBuffer / freeDrawBufferï¼Œ
    // ä¸”å®ƒæ˜¯åŸºäº â€œç»˜åˆ¶å±‚ drawPixelMapï¼ˆå¦‚æœæœ‰ï¼‰æˆ–è€…åº•å›¾ pixelMapâ€ çš„åƒç´ æ•°æ®ã€‚
    if (!this.freeDrawBuffer || !this.freeDrawArrayBuffer) {
      return
    }
    if (!this.pixelMap && !this.drawPixelMap) {
      return
    }

    // âœ… ä¼˜å…ˆä½¿ç”¨ç»˜åˆ¶å±‚çš„å°ºå¯¸ / åƒç´ æ ¼å¼
    const basePm: image.PixelMap = (this.drawPixelMap ?? this.pixelMap) as image.PixelMap
    const info: image.ImageInfo = basePm.getImageInfoSync()

    const imgW: number = info.size.width
    const imgH: number = info.size.height

    // â€”â€” UI â†’ åƒç´ æ˜ å°„ï¼Œé€»è¾‘è·Ÿä½ ä¹‹å‰å®Œå…¨ä¸€æ · â€”â€”
    const scaleBase: number = Math.min(
      this.canvasWidth / imgW,
      this.canvasHeight / imgH
    )
    const realW: number = imgW * scaleBase * this.zoom
    const realH: number = imgH * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const x0: number = Math.floor((prevUiX - imageLeft) * (imgW / realW))
    const y0: number = Math.floor((prevUiY - imageTop) * (imgH / realH))
    const x1: number = Math.floor((curUiX - imageLeft) * (imgW / realW))
    const y1: number = Math.floor((curUiY - imageTop) * (imgH / realH))

    // è¶Šç•Œç›´æ¥ä¸¢å¼ƒè¿™æ®µ
    if (
      x0 < 0 || x0 >= imgW || y0 < 0 || y0 >= imgH ||
        x1 < 0 || x1 >= imgW || y1 < 0 || y1 >= imgH
    ) {
      return
    }

    // â­ çœŸæ­£ç”»åˆ° freeDrawBufferï¼ˆåŒæ­¥ã€ä¸ awaitï¼‰
    this.drawLineIntoBuffer(
      x0,
      y0,
      x1,
      y1,
      this.freeDrawBuffer as Uint8Array,
      imgW,
      imgH,
      info.pixelFormat
    )
  }

  // åœ¨ç»™å®šçš„åƒç´ ç¼“å†²åŒºé‡Œç”»ä¸€æ¡â€œå¸¦ç²—ç»†çš„çº¿æ®µâ€ï¼ˆè‡ªç”±ç”»ä¸“ç”¨ï¼Œå®Œå…¨åŒæ­¥ï¼‰
  // x0,y0,x1,y1 æ˜¯åƒç´ åæ ‡ï¼›buffer æ˜¯æ•´å¼ å›¾çš„ BGRA/ARGB/RGBA åƒç´ æ•°æ®
  private drawLineIntoBuffer(
    x0: number,
    y0: number,
    x1: number,
    y1: number,
    buffer: Uint8Array,
    imgW: number,
    imgH: number,
    pixelFormat: image.PixelMapFormat
  ): void {
    const width: number = imgW
    const height: number = imgH

    // é€šé“åç§»
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        // B G R A
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        // A R G B
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
      // R G B A
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const radius: number = this.strokeWidth > 0 ? this.strokeWidth : 4
    const alpha: number = this.getStrokeAlpha()

    const drawThickPoint = (cx: number, cy: number): void => {
      for (let yy: number = cy - radius; yy <= cy + radius; yy++) {
        if (yy < 0 || yy >= height) {
          continue
        }
        for (let xx: number = cx - radius; xx <= cx + radius; xx++) {
          if (xx < 0 || xx >= width) {
            continue
          }

          const dx: number = xx - cx
          const dy: number = yy - cy
          if (dx * dx + dy * dy > radius * radius) {
            continue
          }

          const baseIndex: number = (yy * width + xx) * 4
          const rIndex: number = baseIndex + rOffset
          const gIndex: number = baseIndex + gOffset
          const bIndex: number = baseIndex + bOffset
          const aIndex: number = baseIndex + aOffset

          if (aIndex >= buffer.length) {
            // ç†è®ºä¸Šä¸ä¼šè¶Šç•Œï¼Œä¿é™©èµ·è§
            continue
          }

          if (this.currentBrush === BrushTool.Eraser) {
            // ğŸ§½ æ©¡çš®æ“¦ï¼šåªæŠŠç»˜åˆ¶å±‚æ“¦é€æ˜
            buffer[aIndex] = 0
          } else {
            // æ™®é€šç”»ç¬” / è§å…‰ç¬”ï¼šç”¨å½“å‰ç¬”åˆ·é¢œè‰² + é€æ˜åº¦
            buffer[rIndex] = this.strokeR
            buffer[gIndex] = this.strokeG
            buffer[bIndex] = this.strokeB
            buffer[aIndex] = alpha
          }
        }
      }
    }

    // â€”â€” ä¸‹é¢ Bresenham ç”»çº¿ä¿æŒä¸å˜ â€”â€”
    let curX: number = x0
    let curY: number = y0
    const dx: number = Math.abs(x1 - x0)
    const sx: number = x0 < x1 ? 1 : -1
    const dy: number = -Math.abs(y1 - y0)
    const sy: number = y0 < y1 ? 1 : -1
    let err: number = dx + dy

    while (true) {
      drawThickPoint(curX, curY)

      if (curX === x1 && curY === y1) {
        break
      }

      const e2: number = 2 * err
      if (e2 >= dy) {
        err += dy
        curX += sx
      }
      if (e2 <= dx) {
        err += dx
        curY += sy
      }
    }
  }

  private async prepareFreeDrawBuffer() {
    if (!this.pixelMap) {
      return
    }

    const pm = this.pixelMap as image.PixelMap

    this.freeBufferReady = false

    this.freeDrawByteLength = pm.getPixelBytesNumber()
    this.freeDrawArrayBuffer = new ArrayBuffer(this.freeDrawByteLength)

    // å¼‚æ­¥è¯»å–åƒç´ ï¼ˆä¸èƒ½åœ¨æ‰‹åŠ¿é‡Œ awaitï¼‰
    pm.readPixelsToBuffer(this.freeDrawArrayBuffer).then(() => {
      this.freeDrawBuffer = new Uint8Array(this.freeDrawArrayBuffer!)
      this.freeBufferReady = true
    })
  }

  private async handleFreeDrawEnd(): Promise<void> {
    // è¿™é‡Œä¸å†æ£€æŸ¥ isFreeDrawingï¼Œåªæ£€æŸ¥å½“å‰å·¥å…· & pixelMap
    if (this.currentShape !== ShapeTool.FreeDraw || !this.pixelMap) {
      return
    }

    this.isFreeDrawing = false

    const pm: image.PixelMap = this.pixelMap as image.PixelMap

    // 1) æŠŠæœ€åçš„å†…å­˜ buffer å†™å› pixelMap
    if (this.freeDrawArrayBuffer) {
      await pm.writeBufferToPixels(this.freeDrawArrayBuffer)
    }

    // 2) clone ä¸€ä»½æ–°çš„ PixelMap â€”â€” è§¦å‘çœŸæ­£çš„ UI åˆ·æ–°
    const newPm: image.PixelMap = await this.clonePixelMap(pm)

    if (this.pixelMap && this.pixelMap !== newPm) {
      (this.pixelMap as image.PixelMap).release?.()
    }

    this.pixelMap = newPm
    this.pixelVersion++ // Image() ä¼šåˆ·æ–°

    // 3) æ¸…ç©ºç¼“å­˜
    this.freeDrawBuffer = null
    this.freeDrawArrayBuffer = null
  }

  // æ ¹æ®å½“å‰ç”»ç¬”é€æ˜åº¦ strokeOpacityï¼ˆ0.0~1.0ï¼‰è®¡ç®—å¯¹åº”çš„ alphaï¼ˆ0~255ï¼‰
  // å½“å‰ç”»ç¬”çš„ alphaï¼ˆ0~255ï¼‰
  private getStrokeAlpha(): number {
    // ä»¥åå¦‚æœè¦åšæ©¡çš®æ“¦ = æŠ¹é€æ˜ï¼Œå¯ä»¥åœ¨è¿™é‡Œ special case
    if (this.currentBrush === BrushTool.Eraser) {
      // æš‚æ—¶å…ˆç•™ç€ 255ï¼Œä¸åšâ€œæŠ¹é€æ˜â€é€»è¾‘ï¼Œåé¢æˆ‘ä»¬å•ç‹¬å¤„ç†æ©¡çš®æ“¦
      // return 0
    }

    let a: number = Math.round(this.strokeOpacity * 255)

    if (a < 0) {
      a = 0
    } else if (a > 255) {
      a = 255
    }
    return a
  }
}
