// ArkUI äº¤äº’å¼¹çª—ä¸ç³»ç»Ÿæ“ä½œèƒ½åŠ›
import { promptAction } from '@kit.ArkUI'
// åª’ä½“åº“è®¿é—®ï¼ˆå›¾ç‰‡è¯»å–ã€ä¿å­˜ï¼‰
import { photoAccessHelper } from '@kit.MediaLibraryKit'
// PixelMap ä¸å›¾ç‰‡å¤„ç†èƒ½åŠ›
import { image } from '@kit.ImageKit'
// æ–‡ä»¶è¯»å†™èƒ½åŠ›
import { fileIo } from '@kit.CoreFileKit'
// Ability ä¸Šä¸‹æ–‡ç›¸å…³èƒ½åŠ›
import { common } from '@kit.AbilityKit'
// ç³»ç»Ÿæ ‡å‡†é”™è¯¯ç±»å‹
import { BusinessError } from '@kit.BasicServicesKit'
// èµ„æºç®¡ç†ï¼ˆstringã€media ç­‰ï¼‰
import resourceManager from '@ohos.resourceManager'
// ç»˜åˆ¶ APIï¼ˆCanvas / Path / Paintï¼‰
import drawing from '@ohos.graphics.drawing'
// å·¥å…·ç±»ï¼ˆæ—¶é—´ã€ç¼–ç ç­‰ï¼‰
import util from '@ohos.util'

// entry/src/main/ets/pages/Index.ets
// é¢œè‰²é€‰æ‹©ç»„ä»¶
import { ColorWheelPicker } from './ColorPicker'
// åä½œé€šä¿¡å®¢æˆ·ç«¯åŠæ¶ˆæ¯å®šä¹‰
import {
  CollabClient,
  CollabMessage,
  buildClearMessage,
  CollabAssignIdPayload,
  CollabImageSyncPayload,
  OnlineUsersPayload,
  OnlineUserItem
} from '../common/net/CollabClient'

// ç»Ÿä¸€é”™è¯¯ç»“æ„ï¼Œå…¼å®¹ç³»ç»Ÿä¸è‡ªå®šä¹‰é”™è¯¯
interface ErrorWithCode {
  code?: number | string // é”™è¯¯ç 
  message?: string // é”™è¯¯æè¿°
}

// åœ¨çº¿ç”¨æˆ·å±•ç¤ºä¿¡æ¯
interface OnlineUserInfo {
  clientId: string // åä½œå®¢æˆ·ç«¯ ID
  displayColor: string // ç”¨æˆ·æ ‡è¯†é¢œè‰²
  isSelf: boolean // æ˜¯å¦ä¸ºå½“å‰è®¾å¤‡
}

// ç”»å¸ƒçŠ¶æ€å¿«ç…§ï¼Œç”¨äºæ’¤é”€ / æ¢å¤
interface CanvasSnapshot {
  pixelMap?: image.PixelMap // åº•å›¾å¿«ç…§
  drawPixelMap?: image.PixelMap // ç»˜åˆ¶å›¾å±‚å¿«ç…§
  zoom: number // å½“å‰ç¼©æ”¾æ¯”ä¾‹
  offsetX: number // X æ–¹å‘åç§»
  offsetY: number // Y æ–¹å‘åç§»
  brightnessLevel: number // äº®åº¦å‚æ•°
  contrastLevel: number // å¯¹æ¯”åº¦å‚æ•°
  accumulatedRotate: number // ç´¯è®¡æ—‹è½¬è§’åº¦
}

// æ“ä½œè®°å½•ï¼Œç”¨äºåä½œæ—¥å¿—å±•ç¤º
interface OperationLogItem {
  id: number // æœ¬åœ°å”¯ä¸€æ ‡è¯†
  userId: string // æ“ä½œè€… ID
  userColor: string // æ“ä½œè€…é¢œè‰²
  message: string // æ“ä½œæè¿°
  timestamp: string // æ“ä½œæ—¶é—´
}

// é¡¶éƒ¨èœå•ç±»å‹
enum TopMenu {
  None, // æ— èœå•
  Image, // å›¾ç‰‡æ“ä½œ
  Shape, // å½¢çŠ¶å·¥å…·
  Brush // ç”»ç¬”å·¥å…·
}

// å½¢çŠ¶ç»˜åˆ¶å·¥å…·ç±»å‹
enum ShapeTool {
  None, // æœªé€‰æ‹©
  Point, // ç‚¹
  Line, // ç›´çº¿
  Rect, // çŸ©å½¢
  Circle, // åœ†
  Ellipse, // æ¤­åœ†
  FreeDraw // è‡ªç”±ç»˜åˆ¶
}

// ç”»ç¬”å·¥å…·ç±»å‹
enum BrushTool {
  None, // æœªé€‰æ‹©
  Pen, // æ™®é€šç”»ç¬”
  Highlighter, // è§å…‰ç¬”
  Eraser // æ©¡çš®æ“¦
}


@Entry
@Component
struct Index {
  // ç”»å¸ƒçŠ¶æ€
  @State pixelMap?: image.PixelMap = undefined
  @State zoom: number = 1.0
  @State offsetX: number = 0
  @State offsetY: number = 0
  @State pixelVersion: number = 0
  // ================= æ–°å¢ï¼šç»˜åˆ¶å›¾å±‚ =================
  // ä¸“é—¨ç”¨æ¥ç”»çº¿æ¡/å½¢çŠ¶ï¼Œæ©¡çš®æ“¦åªæ“¦è¿™ä¸ªå±‚
  @State drawPixelMap?: image.PixelMap = undefined
  @State drawPixelVersion: number = 0
  // ==================================================
  // æ—‹è½¬ä¸­æ ‡å¿—ï¼Œé˜²æ­¢è¿ç‚¹å¯¼è‡´ä¸¤æ¬¡å³æ—‹
  private isRotating: boolean = false
  private accumulatedRotate: number = 0 // ä¹‹å‰æ—‹è½¬çš„æ€»åº¦æ•°
  // æ—‹è½¬ / äº®åº¦ / å¯¹æ¯”åº¦
  @State rotateDeg: number = 0 // æ—‹è½¬è§’åº¦
  @State brightnessLevel: number = 0.0 // -0.5 ~ 0.5 å·¦å³ï¼Œ0 æ˜¯åŸå›¾
  @State contrastLevel: number = 0.0 // -1.0 ~ 1.0ï¼ˆ0 æ˜¯åŸå›¾å¯¹æ¯”åº¦ï¼‰
  @State showLeftPanel: boolean = false // å·¦ä¾§å·¥å…·æ æ˜¯å¦å±•å¼€
  @State currentTool: string = '' // å½“å‰é€‰æ‹©çš„å·¥å…·ç±»å‹ï¼ˆpoint/line/rect...ï¼‰
  @State activeMenu: TopMenu = TopMenu.None // å½“å‰å±•å¼€çš„é¡¶æ èœå•
  @State currentShape: ShapeTool = ShapeTool.None
  @State currentBrush: BrushTool = BrushTool.Pen // é»˜è®¤å°±æ˜¯æ™®é€šç”»ç¬”
  // é¡¶éƒ¨èœå•å½“å‰é€‰ä¸­çš„ä¸€çº§èœå•ï¼šimage / shape / brush / ''(ä¸æ˜¾ç¤ºäºŒçº§)
  @State currentMenu: string = 'image'
  // å½“å‰äºŒçº§èœå•ï¼ˆå½¢çŠ¶ / ç”»ç¬”æ‰ä¼šä½¿ç”¨ï¼‰
  @State currentSubTool: string = ''
  // æ‰‹åŠ¿å†…éƒ¨çŠ¶æ€
  private lastPanX: number = 0
  private lastPanY: number = 0
  private lastZoom: number = 1.0
  // è£å‰ªæ¨¡å¼ å¼€/å…³
  @State cropMode: boolean = false
  // æ‰‹åŠ¿é€‰æ‹©æ¡†ï¼ˆUI åæ ‡ï¼‰
  @State cropStartX: number = 0
  @State cropStartY: number = 0
  @State cropEndX: number = 0
  @State cropEndY: number = 0
  // ç”»å¸ƒå¤§å°ï¼ˆä¸ºäº†æŠŠ UI åæ ‡æ¯”ä¾‹æ˜ å°„æˆåƒç´ åæ ‡ï¼‰
  @State canvasWidth: number = 0
  @State canvasHeight: number = 0
  // æ’¤é”€ç”¨çš„å†å²æ ˆï¼ˆä¸éœ€è¦å“åº”å¼ï¼‰
  private history: Array<CanvasSnapshot> = []
  private historyIndex: number = -1
  private readonly historyLimit: number = 10
  // æ–°å¢ï¼šè®°å½•â€œæ‰“å¼€å›¾ç‰‡æ—¶çš„åŸå›¾å¿«ç…§â€
  private originalPixelMap?: image.PixelMap = undefined
  //å…¨å±€ç”»ç¬”æ ·å¼ï¼ˆå½¢çŠ¶ + ç”»ç¬”å…±äº«ï¼‰
  @State strokeWidth: number = 4 // åƒç´ åŠå¾„ï¼Œç»†ç¬”/ç²—ç¬”ä¸€èµ·æ”¹è¿™ä¸ª
  @State strokeR: number = 0 // é»˜è®¤é»‘è‰²
  @State strokeG: number = 0
  @State strokeB: number = 0
  @State strokeOpacity: number = 1.0 // 0.0 ~ 1.0 ç”»ç¬”é€æ˜åº¦ï¼ˆæš‚æ—¶åªä½œä¸º UIï¼‰
  // å½“å‰æ˜¯å¦æ­£åœ¨ç»˜åˆ¶ä¸€ä¸ªå½¢çŠ¶ï¼ˆçº¿ã€çŸ©å½¢ã€åœ†ç­‰ï¼‰
  private isShapeDrawing: boolean = false
  // é€šç”¨å½¢çŠ¶ç»˜åˆ¶çš„èµ·ç‚¹ï¼ˆUI åæ ‡ï¼‰
  private shapeStartUiX: number = 0
  private shapeStartUiY: number = 0
  // è‡ªç”±ç»˜åˆ¶çŠ¶æ€ï¼ˆå½¢çŠ¶ = ShapeTool.FreeDraw æ—¶ä½¿ç”¨ï¼‰
  private isFreeDrawing: boolean = false
  private freeLastUiX: number = 0
  private freeLastUiY: number = 0
  // è‡ªç”±ç”»å¼€å§‹æ—¶ç¼“å­˜åŸå›¾åƒç´ 
  private freeDrawBuffer: Uint8Array | null = null
  private freeDrawArrayBuffer: ArrayBuffer | null = null
  private freeDrawByteLength: number = 0
  private freeBufferReady: boolean = false
  // å½“å‰åº•å›¾çš„å¯¹è§’çº¿é•¿åº¦ï¼ˆåƒç´ ï¼‰ï¼Œç”¨äºè£å‰ªæ—¶æ¸©å’Œç¼©æ”¾ç”»ç¬”
  @State imageDiag: number = 0
  // ==== æ–°å¢ï¼šåä½œ WebSocket å®¢æˆ·ç«¯ ====
  // æŠŠä¸‹é¢çš„ 192.168.1.100 æ¢æˆä½ è¿è¡Œ Node.js æœåŠ¡å™¨é‚£å°ç”µè„‘çš„å±€åŸŸç½‘ IP
  // ä¸èƒ½ç”¨ 0.0.0.0ï¼Œè¦ç”¨å…·ä½“ IPï¼Œæ¯”å¦‚ 192.168.0.5
  private collabClient: CollabClient = new CollabClient(
    'ws://101.43.185.73:8080/collab'
  );
  // ç»™å½“å‰è®¾å¤‡ä¸€ä¸ªå›ºå®š idï¼ˆä¸è¦æ¯æ¬¡ç‚¹å‡»éƒ½å˜ï¼‰
  @State localClientId: string = ''; // æœåŠ¡å™¨åˆ†é…ç»™è‡ªå·±çš„ id
  @State localColor: string = '#000000'; // è‡ªå·±çš„ä»£è¡¨è‰²
  // åœ¨çº¿ç”¨æˆ·åˆ—è¡¨ï¼ˆåŒ…å«è‡ªå·±å’Œåˆ«äººï¼‰
  @State onlineUsers: Array<OnlineUserInfo> = [];
  // æœ¬æœº clientIdï¼ˆç»™ CollabClient ç”¨çš„é‚£ä¸ª idï¼Œè¦ä¿æŒä¸€è‡´ï¼‰
  private clientId: string = 'client-' + Date.now().toString();
  // ç®€å•çš„é¢œè‰²æ± ï¼ŒæŒ‰é¡ºåºç»™ä¸åŒç”¨æˆ·åˆ†é¢œè‰²
  private userColorPalette: Array<string> = [
    '#2563EB', // è“
    '#EC4899', // ç²‰
    '#10B981', // ç»¿
    '#F97316', // æ©™
    '#A855F7',// ç´«
  ];
  private nextColorIndex: number = 0;
  // æ˜¯å¦å‚ä¸åä½œï¼ˆæ§åˆ¶æ˜¯å¦è¿ WebSocketï¼‰
  @State collabEnabled: boolean = true;
  @State showOpLog: boolean = false; // æ˜¯å¦å±•å¼€æ“ä½œè®°å½•é¢æ¿
  @State opLogList: Array<OperationLogItem> = []; // æ“ä½œè®°å½•é˜Ÿåˆ—
  private opSeq: number = 0; // æœ¬åœ°è‡ªå¢ id
  private lastOpDesc: string = ''; //ä¸Šä¸€ä¸ªåä½œæ“ä½œ

  // ====== æ–°å¢ï¼šç”Ÿå‘½å‘¨æœŸé‡Œåˆå§‹åŒ– / å…³é—­ WebSocket ======
  // ====== ç”Ÿå‘½å‘¨æœŸï¼šé¡µé¢å‡ºç°æ—¶åˆå§‹åŒ– WebSocket ======
  aboutToAppear(): void {
    this.collabClient.setCallbacks(
      () => {
        // onOpen
        console.log('[Collab] WebSocket open');

        if (!this.collabEnabled) {
          this.collabClient.close();
          return;
        }

        this.onlineUsers = [];
      },
      () => {
        console.log('[Collab] WebSocket close');
        this.onlineUsers = [];
        this.localClientId = ''; // æ–­å¼€åæ¸…ç©º
      },
      (msg: CollabMessage) => {
        console.log('[Collab] message = ' + JSON.stringify(msg));

        // ğŸ”´ è¿œç«¯ç”¨æˆ·ï¼šæŠŠä¸ç­‰äºæˆ‘çš„ clientId çš„ç”¨æˆ·åŠ å…¥ remote åˆ—è¡¨
        if (msg.clientId && msg.clientId !== this.clientId) {
          this.ensureRemoteUser(msg.clientId);
        }

        // ========== â‘  å¤„ç† assignId ==========
        if (msg.type === 'assignId') {
          const payload = msg.payload as CollabAssignIdPayload | undefined;

          // æœåŠ¡å™¨åˆ†é…ç»™æˆ‘çš„çœŸæ­£ clientId
          this.localClientId = msg.clientId ?? '';

          // ä½¿ç”¨æœåŠ¡å™¨ç»™çš„é¢œè‰²
          const color: string =
            (payload && payload.displayColor) ||
            this.pickColorForClient(this.localClientId || this.clientId);

          this.localColor = color;

          const selfUser: OnlineUserInfo = {
            clientId: this.localClientId || this.clientId,
            displayColor: color,
            isSelf: true
          };

          // åœ¨çº¿åˆ—è¡¨é‡ŒåŠ å…¥è‡ªå·±
          this.onlineUsers = [selfUser];

          console.info('[Collab] assigned id = ' + this.localClientId);
          return;
        }

        // ========== â‘¡ âš¡ å¤„ç† onlineUsers æ–°æ¶ˆæ¯ï¼ˆæ”¾åœ¨ assignId åã€å…¶ä»–æ¶ˆæ¯å‰ï¼‰ ==========
        if (msg.type === 'onlineUsers') {
          const payload = msg.payload as OnlineUsersPayload;
          this.onlineUsers = payload.users.map((u: OnlineUserItem): OnlineUserInfo => {
            const info: OnlineUserInfo = {
              clientId: u.clientId,
              displayColor: u.displayColor,
              isSelf: u.clientId === this.localClientId
            };
            return info;
          });
        }


        // ========== â‘¢ clear æ¶ˆæ¯ ==========
        if (msg.type === 'clear') {
          console.log('[Collab] remote clear layer, do resetView()');
          this.resetView();

          // åªè®°å½•åˆ«çš„ç”¨æˆ·çš„æ¸…ç©ºæ“ä½œ
          const selfId: string = this.localClientId || this.clientId;
          if (msg.clientId && msg.clientId !== selfId) {
            // ä¸å†è‡ªå·±ç®—é¢œè‰²ï¼ŒappendOpLog ä¼šè‡ªå·±ä» onlineUsers é‡Œæ‰¾
            this.appendOpLog(msg.clientId, 'æ¸…ç©ºç”»å¸ƒ');
          }
        }


        // ========== â‘£ imageSync å›¾ç‰‡åŒæ­¥ ==========
        if (msg.type === 'imageSync') {
          const payload = msg.payload as CollabImageSyncPayload;
          console.info('[Collab] receive image-sync from: ' + msg.clientId);

          // è®°å½•è¿œç«¯æ›´æ–°ç”»å¸ƒï¼ˆåŒæ ·è·³è¿‡è‡ªå·±å‘çš„ echoï¼‰
          const selfId: string = this.localClientId || this.clientId;
          if (msg.clientId && msg.clientId !== selfId) {
            const desc: string = payload.opDesc ?? 'æ›´æ–°äº†ç”»å¸ƒ';
            // ä¸ä¼  colorï¼Œè®© appendOpLog è‡ªå·±ä» onlineUsers å–é¢œè‰²
            this.appendOpLog(msg.clientId, desc);
          }

          this.applyRemoteImage(payload).then(() => {
            console.info('[Collab] remote image applied');
            promptAction.showToast({ message: 'å·²åŠ è½½åä½œå›¾ç‰‡' });
          });
        }


        // æ›´å¤šæ¶ˆæ¯ç±»å‹åœ¨è¿™é‡Œæ‰©å±•...
      },
      (err: string) => {
        console.error('[Collab] error = ' + err);
      }
    );

    this.collabClient.connect();
  }

  aboutToDisappear(): void {
    // é¡µé¢é”€æ¯æ—¶è®°å¾—æ–­å¼€è¿æ¥
    this.collabClient.close();
  }

  build() {
    Column() {
      Column() {
        Column() {

          // é¡¶éƒ¨å·¥å…·æ 
          Column() {
            // === ä¸€çº§èœå•ï¼šå›¾ç‰‡æ“ä½œ / å½¢çŠ¶ / ç”»ç¬” / æ’¤é”€ / åˆ†äº« ===
            Row({ space: 8 }) {
              // ä¸€çº§æŒ‰é’®ï¼šå›¾ç‰‡æ“ä½œ
              Button('å›¾ç‰‡æ“ä½œ', { type: ButtonType.Capsule })
                .height(32)
                .fontSize(12)
                .backgroundColor(this.currentMenu === 'image' ? '#2563EB' : '#EFF6FF')
                .fontColor(this.currentMenu === 'image' ? '#FFFFFF' : '#1D4ED8')
                .onClick(() => {
                  this.currentMenu = this.currentMenu === 'image' ? '' : 'image'
                })

              // ä¸€çº§æŒ‰é’®ï¼šå½¢çŠ¶
              Button('å½¢çŠ¶', { type: ButtonType.Capsule })
                .height(32)
                .fontSize(12)
                .backgroundColor(this.currentMenu === 'shape' ? '#2563EB' : '#EFF6FF')
                .fontColor(this.currentMenu === 'shape' ? '#FFFFFF' : '#1D4ED8')
                .onClick(() => {
                  this.currentMenu = this.currentMenu === 'shape' ? '' : 'shape'
                })

              // ä¸€çº§æŒ‰é’®ï¼šç”»ç¬”
              Button('ç”»ç¬”', { type: ButtonType.Capsule })
                .height(32)
                .fontSize(12)
                .backgroundColor(this.currentMenu === 'brush' ? '#2563EB' : '#EFF6FF')
                .fontColor(this.currentMenu === 'brush' ? '#FFFFFF' : '#1D4ED8')
                .onClick(() => {
                  this.currentMenu = this.currentMenu === 'brush' ? '' : 'brush'
                })

              // âœ… æ–°å¢ï¼šä¸€çº§æŒ‰é’®ï¼šåˆ†äº«
              // Button('åˆ†äº«', { type: ButtonType.Capsule })
              //   .height(32)
              //   .fontSize(12)
              //   .backgroundColor(this.currentMenu === 'share' ? '#2563EB' : '#EFF6FF')
              //   .fontColor(this.currentMenu === 'share' ? '#FFFFFF' : '#1D4ED8')
              //   .onClick(() => {
              //     this.currentMenu = this.currentMenu === 'share' ? '' : 'share'
              //   })

              // ä¸€çº§æŒ‰é’®ï¼šåŠ æ°´å°
              Button('åŠ æ°´å°', { type: ButtonType.Capsule })
                .height(32)
                .fontSize(12)
                .backgroundColor('#E0F2FE')
                .fontColor('#0369A1')
                .onClick(async () => {
                  await this.addWatermark()
                })


              // ä¸€çº§æŒ‰é’®ï¼šæ’¤é”€
              Button('æ’¤é”€', { type: ButtonType.Capsule })
                .height(32)
                .fontSize(12)
                .backgroundColor('#fff31818')
                .onClick(async () => {
                  await this.undo()
                })
            }
            .width('100%')
            .padding({
              left: 4,
              right: 4,
              top: 4,
              bottom: 4
            })
            .justifyContent(FlexAlign.Center)

            // === äºŒçº§èœå•åŒºåŸŸï¼šæ ¹æ® currentMenu å†³å®šæ˜¾ç¤ºå“ªä¸€è¡Œ ===
            if (this.currentMenu === 'image') {
              // å›¾ç‰‡æ“ä½œï¼šå¸¦æ¨ªå‘æ»šåŠ¨æ¡
              Scroll() {
                Row({ space: 8 }) {
                  Button('è£å‰ª', { type: ButtonType.Capsule })
                    .height(32)
                    .fontSize(12)
                    .backgroundColor(this.cropMode ? '#EF4444' : '#EFF6FF')
                    .fontColor(this.cropMode ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => {
                      if (!this.pixelMap) {
                        // ä¸è¿›å…¥è£å‰ªæ¨¡å¼ï¼Œä½†è°ƒç”¨ doCropï¼Œè®© doCrop è‡ªå·±å¼¹å‡º toast
                        this.doCrop()
                        return
                      }

                      this.cropMode = !this.cropMode
                      if (this.cropMode) {
                        this.cropStartX = 0
                        this.cropStartY = 0
                        this.cropEndX = 0
                        this.cropEndY = 0
                      }
                    })

                  // äºŒçº§æŒ‰é’®ç»Ÿä¸€ç”¨ Normal + æµ…ç°èƒŒæ™¯ï¼Œä¸ä¸€çº§åŒºåˆ†
                  Button('å¯¹æ¯”åº¦+', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.adjustContrast(0.1))

                  Button('å¯¹æ¯”åº¦-', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.adjustContrast(-0.1))

                  Button('å·¦æ—‹90Â°', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.rotateLeft90())

                  Button('å³æ—‹90Â°', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.rotateRight90())

                  Button('å˜äº®', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.adjustBrightness(0.05))

                  Button('å˜æš—', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.adjustBrightness(-0.05))
                }
                .height(32)
                .padding({ left: 4, right: 4 })
              }
              .scrollable(ScrollDirection.Horizontal)
              .width('100%')
              .padding({ bottom: 8 }) // äºŒçº§èœå•å’Œç”»å¸ƒä¹‹é—´ç•™ä¸€ç‚¹ç©ºéš™
            } else if (this.currentMenu === 'shape') {
              Scroll() {
                Row({ space: 8 }) {

                  Button('ç‚¹', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Point ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Point ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.selectShape(ShapeTool.Point))

                  Button('ç›´çº¿', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Line ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Line ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.selectShape(ShapeTool.Line))

                  Button('çŸ©å½¢', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Rect ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Rect ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.selectShape(ShapeTool.Rect))

                  Button('åœ†', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Circle ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Circle ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.selectShape(ShapeTool.Circle))

                  Button('æ¤­åœ†', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Ellipse ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Ellipse ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.selectShape(ShapeTool.Ellipse))

                  Button('çº¿æ¡', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.FreeDraw ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.FreeDraw ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.selectShape(ShapeTool.FreeDraw))

                }
                .height(32)
                .padding({ left: 4, right: 4 })
              }
              .scrollable(ScrollDirection.Horizontal)
              .width('100%')
              .padding({ bottom: 8 })

            } else if (this.currentMenu === 'brush') {
              Scroll() {
                Column() {


                  // ===== ç¬¬ 2 è¡Œï¼šç²—ç»†è°ƒèŠ‚ Slider =====
                  Row({ space: 8 }) {
                    Text('ç²—ç»†')
                      .fontSize(11)
                      .fontColor('#4B5563')
                      .width(36)

                    Slider({
                      value: this.strokeWidth,
                      min: 1,
                      max: 40,
                      step: 1
                    })
                      .width('60%')
                      .onChange((value: number) => {
                        this.strokeWidth = value
                      })

                    Text(`${this.strokeWidth.toFixed(0)} px`)
                      .fontSize(10)
                      .fontColor('#6B7280')
                      .width(40)
                  }
                  .height(32)
                  .padding({ left: 4, right: 4, bottom: 4 })
                  .alignItems(VerticalAlign.Center)


                  // ===== ç¬¬ 3 è¡Œï¼šé€æ˜åº¦ Slider =====
                  Row({ space: 8 }) {
                    Text('é€æ˜åº¦')
                      .fontSize(11)
                      .fontColor('#4B5563')
                      .width(36)

                    Slider({
                      value: this.strokeOpacity,
                      min: 0.1, // æœ€ä½ 10%ï¼Œé˜²æ­¢å®Œå…¨çœ‹ä¸è§
                      max: 1.0,
                      step: 0.05
                    })
                      .width('60%')
                      .onChange((value: number) => {
                        this.strokeOpacity = value
                      })

                    Text(`${Math.round(this.strokeOpacity * 100)}%`)
                      .fontSize(10)
                      .fontColor('#6B7280')
                      .width(40)
                  }
                  .height(32)
                  .padding({ left: 4, right: 4, bottom: 4 })
                  .alignItems(VerticalAlign.Center)


                  // ---- ç¬¬äº”è¡Œï¼šé¢œè‰²é¢„è§ˆï¼ˆå¯é€‰ï¼‰ ----
                  Row() {
                    // ===== ç¬¬ 1 è¡Œï¼šæ©¡çš®æ“¦ =====
                    Row({ space: 8 }) {
                      Button('æ©¡çš®æ“¦', { type: ButtonType.Normal })
                        .height(28)
                        .fontSize(11)
                        .backgroundColor(this.currentBrush === BrushTool.Eraser ? '#FB923C' : '#FEF3C7')
                        .fontColor(this.currentBrush === BrushTool.Eraser ? '#FFFFFF' : '#92400E')
                        .onClick(() => {
                          if (this.currentBrush === BrushTool.Eraser) {
                            // ğŸ‘‰ å†ç‚¹ä¸€æ¬¡ï¼šå…³é—­æ©¡çš®æ“¦ï¼Œæ¢å¤æ™®é€šç”»ç¬”
                            this.currentBrush = BrushTool.Pen
                            // è‡ªç”±ç”»ä¿æŒä¸å˜ï¼Œç”¨æˆ·å¯ä»¥ç»§ç»­ç”¨æ™®é€šç”»ç¬”è‡ªç”±ç”»
                          } else {
                            // ğŸ‘‰ ç¬¬ä¸€æ¬¡ç‚¹ï¼šå¼€å¯æ©¡çš®æ“¦ + è¿›å…¥è‡ªç”±ç»˜åˆ¶æ¨¡å¼
                            this.currentBrush = BrushTool.Eraser
                            this.currentShape = ShapeTool.FreeDraw
                          }
                        })

                    }
                    .height(32)
                    .padding({ left: 4, right: 4, bottom: 4 })

                    ColorWheelPicker({
                      strokeR: $strokeR,
                      strokeG: $strokeG,
                      strokeB: $strokeB
                    }).margin({ top: 6 })

                    Text('å½“å‰é¢œè‰²é¢„è§ˆ').fontSize(14)

                    Blank()
                      .width(24)
                      .height(24)
                      .backgroundColor(
                        // strokeR/G/B æ˜¯ 0~255ï¼Œéœ€è¦ç»„è£…æˆ 0xAARRGGBB
                        (0xFF000000 +
                          (this.strokeR << 16) +
                          (this.strokeG << 8) +
                        this.strokeB)
                      )
                      .border({ width: 1, color: '#111827' })
                      .margin({ left: 8 })
                  }

                }
              }
              .scrollable(ScrollDirection.Horizontal)
              .width('100%')
              .padding({ bottom: 8 })
            }

          }


          // ===== é¡¶éƒ¨ï¼šåœ¨çº¿åä½œæ¡ =====
          // é¡¶éƒ¨ï¼šåä½œ & åœ¨çº¿ç”¨æˆ·æ 
          Row({ space: 8 }) { // ç”¨è¾ƒå° space æ§åˆ¶ç»„ä»¶ä¹‹é—´çš„å›ºå®šé—´è·
            // å·¦ä¾§ï¼šåä½œæŒ‰é’®ï¼ˆç¨å¾®ç¼©å°ï¼‰
            Button(this.collabEnabled ? 'æ–­å¼€åä½œ' : 'åŠ å…¥åä½œ', { type: ButtonType.Capsule })
              .height(24)             // åŸæ¥ 28ï¼Œç¨å¾®ç¼©å°
              .fontSize(10)           // åŸæ¥ 11
              .backgroundColor(this.collabEnabled ? '#FEE2E2' : '#DCFCE7')
              .fontColor(this.collabEnabled ? '#B91C1C' : '#166534')
              .onClick(() => {
                if (this.collabEnabled) {
                  this.collabEnabled = false
                  this.collabClient.close()
                  this.onlineUsers = []
                  promptAction.showToast({ message: 'å·²æ–­å¼€åä½œ' })
                } else {
                  this.collabEnabled = true
                  this.collabClient.connect()
                  promptAction.showToast({ message: 'æ­£åœ¨åŠ å…¥åä½œ...' })
                }
              })

            // æ“ä½œè®°å½•æŒ‰é’®ï¼ˆä¹Ÿç¼©å°ä¸€ç‚¹ï¼‰
            Button(this.showOpLog ? 'æ”¶èµ·è®°å½•' : 'æ“ä½œè®°å½•', { type: ButtonType.Capsule })
              .height(22)             // åŸæ¥ 24
              .fontSize(10)           // åŸæ¥ 11
              .backgroundColor(this.showOpLog ? '#DBEAFE' : '#E5E7EB')
              .fontColor('#111827')
              .onClick(() => {
                this.showOpLog = !this.showOpLog
              })

            // åœ¨çº¿ç”¨æˆ·åŒºåŸŸæ•´ä½“æ”¾åˆ°ä¸€ä¸ªæ°´å¹³ Scroll é‡Œ
            // è¿™æ ·å½“ç”¨æˆ·å¾ˆå¤šæ—¶å¯ä»¥å·¦å³æ»‘åŠ¨
            Scroll() {
              Row({ space: 4 }) { // å†…éƒ¨å†ç¨å¾®ç´§å‡‘ä¸€äº›
                // ä¸­é—´æ ‡é¢˜ï¼šâ€œåœ¨çº¿ï¼šâ€ æ›´çŸ­æ›´çª„
                Text('åœ¨çº¿ï¼š')
                  .fontSize(10)
                  .fontColor('#6B7280')

                // åœ¨çº¿ç”¨æˆ·æ ‡ç­¾ï¼ˆç´§æŒ¨ç€â€œåœ¨çº¿ï¼šâ€ï¼‰
                Row({ space: 4 }) {
                  ForEach(this.onlineUsers, (u: OnlineUserInfo) => {
                    Row() {
                      // å½©è‰²å°æ–¹å—
                      Rect()
                        .width(8)    // åŸæ¥ 10
                        .height(8)
                        .radius(2)
                        .fill(u.displayColor)
                        .margin({ right: 4 })

                      Text(u.isSelf ? 'æˆ‘(' + u.clientId + ')' : u.clientId)
                        .fontSize(10)          // æ›´å°ä¸€ç‚¹
                        .fontColor('#111827')
                    }
                    .padding({
                      left: 6, // åŸæ¥ 8
                      right: 6,
                      top: 2, // åŸæ¥ 3
                      bottom: 2
                    })
                    .backgroundColor(u.isSelf ? '#DBEAFE' : '#E5E7EB')
                    .borderRadius(999)
                  }, (u: OnlineUserInfo) => u.clientId)
                }
              }
              .height(26) // æ§åˆ¶æ•´ä¸ªåœ¨çº¿ç”¨æˆ·åŒºçš„é«˜åº¦æ›´ç´§å‡‘
            }
            .scrollable(ScrollDirection.Horizontal) // âœ… æ°´å¹³æ»šåŠ¨
            .layoutWeight(1) // å æ®å‰©ä½™ç©ºé—´ï¼Œè‡ªé€‚åº”å‹ç¼©ï¼Œä¸æ’‘å¼€å·¦ä¾§æŒ‰é’®
          }
          .justifyContent(FlexAlign.Start) // æ•´è¡Œé å·¦æ’
          .alignItems(VerticalAlign.Center) // å‚ç›´å±…ä¸­
          .padding({
            left: 12,
            right: 12,
            top: 4, // åŸæ¥ 6ï¼Œç¨å¾®å‡ä¸€ç‚¹
            bottom: 4
          })
          .backgroundColor('#F9FAFB')

          // ===== æ“ä½œè®°å½•åŒºåŸŸï¼Œä¿æŒä½ åŸæ¥çš„é€»è¾‘ä¸å˜ =====
          if (this.showOpLog) {
            Column() {
              Scroll() {
                Column({ space: 4 }) {
                  ForEach(this.opLogList, (item: OperationLogItem) => {
                    Row() {
                      // å·¦ä¾§ç”¨æˆ·é¢œè‰²å—
                      Rect()
                        .width(10)
                        .height(10)
                        .radius(2)
                        .fill(item.userColor)
                        .margin({ right: 6 })

                      // ä¸­é—´æ–‡æœ¬ï¼šæ—¶é—´ + ç”¨æˆ· + æ“ä½œå†…å®¹
                      Column({ space: 2 }) {
                        Text(`[${item.timestamp}] ${item.userId}`)
                          .fontSize(11)
                          .fontColor('#4B5563')

                        Text(item.message)
                          .fontSize(11)
                          .fontColor('#111827')
                      }
                    }
                    .padding({
                      left: 8,
                      right: 8,
                      top: 4,
                      bottom: 4
                    })
                    .backgroundColor('#FFFFFF')
                    .borderRadius(6)
                  }, (item: OperationLogItem) => item.id.toString())
                }
              }
              .width('100%')
              .height(120) // å›ºå®šé«˜åº¦ï¼Œå†…éƒ¨å¯æ»šåŠ¨

              // åº•éƒ¨ä¸€æ¡æ·¡ç°çº¿
              Divider().strokeWidth(0.5).color('#E5E7EB')
            }
            .padding({ left: 12, right: 12, bottom: 6 })
            .backgroundColor('#F3F4F6')
          }


          // ç”»å¸ƒ
          Stack() {
            if (!this.pixelMap) {
              Column() {
                Text('ç‚¹å‡»â€œæ‰“å¼€å›¾ç‰‡â€å¼€å§‹ç¼–è¾‘')
                  .fontSize(14)
                  .fontColor('#9AA1A8')
                  .letterSpacing(0.5)
              }
              .width('100%').height('100%')
              .justifyContent(FlexAlign.Center)
              .alignItems(HorizontalAlign.Center)
            } else {
              // =======================
              // 1. å›¾ç‰‡æ˜¾ç¤ºå±‚ï¼ˆåº•å›¾ï¼‰
              // =======================
              Image(this.pixelMap)
                .id(`img-${this.pixelVersion}`)
                .objectFit(ImageFit.Contain)
                .width('100%')
                .height('100%')
                .scale({ x: this.zoom, y: this.zoom })
                .translate({ x: this.offsetX, y: this.offsetY })
                .colorFilter(this.buildToneMatrix())

              // =======================
              // 1.5 ç»˜åˆ¶å›¾å±‚ï¼ˆå åŠ ï¼‰
              // =======================
              if (this.drawPixelMap) {
                Image(this.drawPixelMap)
                  .id(`draw-${this.drawPixelVersion}`)
                  .objectFit(ImageFit.Contain)
                  .width('100%')
                  .height('100%')
                  .scale({ x: this.zoom, y: this.zoom })
                  .translate({ x: this.offsetX, y: this.offsetY })
              }


              // ==========================
              // 2. æ‹–æ‹½ & ç¼©æ”¾æ‰‹åŠ¿å±‚ï¼ˆä¸æ˜¯è£å‰ªæ—¶ç”Ÿæ•ˆï¼‰
              // ==========================
              if (!this.cropMode) {
                Stack()
                  .width('100%')
                  .height('100%')
                  .backgroundColor(Color.Transparent)
                  .hitTestBehavior(HitTestMode.Transparent)
                  .gesture(
                    GestureGroup(GestureMode.Parallel,

                      // ç‚¹å‡»ï¼šç”»ç‚¹
                      TapGesture()
                        .onAction((ev: GestureEvent) => {
                          if (!ev.fingerList || ev.fingerList.length === 0) {
                            return
                          }
                          const finger = ev.fingerList[0]
                          const x: number = finger.localX
                          const y: number = finger.localY

                          console.info(`>>> tap at x=${x}, y=${y}`)

                          if (this.currentShape === ShapeTool.Point) {
                            this.drawPointAtUi(x, y)
                          }
                        }),

                      // æ‹–æ‹½ï¼šå¹³ç§» / ç›´çº¿ / çŸ©å½¢ / åœ† / æ¤­åœ† / è‡ªç”±ç”»
                      PanGesture({ direction: PanDirection.All })
                        .onActionStart(e => {
                          if (!e.fingerList || e.fingerList.length === 0) {
                            return
                          }
                          const f = e.fingerList[0]

                          if (this.currentShape === ShapeTool.FreeDraw) {
                            this.isFreeDrawing = true
                            this.freeLastUiX = f.localX
                            this.freeLastUiY = f.localY

                            // å¼‚æ­¥å‡†å¤‡ bufferï¼ˆä¸èƒ½ awaitï¼‰
                            this.prepareFreeDrawBuffer()

                            // å­˜ä¸€æ¬¡å¿«ç…§æ–¹ä¾¿æ’¤é”€æ•´ç¬”
                            if (this.pixelMap) {
                              this.clonePixelMap(this.pixelMap as image.PixelMap)
                                .then(pmBackup => this.pushHistorySnapshot(true, pmBackup))
                            }
                            return
                          }


                          // âœ… æƒ…å†µ 2ï¼šç›´çº¿ / çŸ©å½¢ / åœ† / æ¤­åœ†ï¼šæ‹–å‡ºä¸€ä¸ªå½¢çŠ¶
                          if (this.currentShape === ShapeTool.Line ||
                            this.currentShape === ShapeTool.Rect ||
                            this.currentShape === ShapeTool.Circle ||
                            this.currentShape === ShapeTool.Ellipse) {
                            this.isShapeDrawing = true
                            this.shapeStartUiX = f.localX
                            this.shapeStartUiY = f.localY
                            console.info(`>>> shape start ui=(${this.shapeStartUiX}, ${this.shapeStartUiY})`)
                            return
                          }

                          // âœ… æƒ…å†µ 3ï¼šå…¶ä»–æƒ…å†µ â†’ å½“æˆå¹³ç§»ç”»å¸ƒ
                          this.lastPanX = this.offsetX
                          this.lastPanY = this.offsetY
                        })
                        .onActionUpdate(e => {
                          if (!e.fingerList || e.fingerList.length === 0) {
                            return
                          }
                          const f = e.fingerList[0]

                          if (this.isFreeDrawing && this.currentShape === ShapeTool.FreeDraw) {
                            this.drawFreeStrokeSegmentSync(
                              this.freeLastUiX,
                              this.freeLastUiY,
                              f.localX,
                              f.localY
                            )

                            this.freeLastUiX = f.localX
                            this.freeLastUiY = f.localY
                            return
                          }

                          // ğŸ‘‰ æ­£åœ¨ç”»å›¾å½¢ï¼ˆçº¿ / çŸ©å½¢ / åœ† / æ¤­åœ†ï¼‰æ—¶ï¼Œä¸å¹³ç§»
                          if (this.isShapeDrawing &&
                            (this.currentShape === ShapeTool.Line ||
                              this.currentShape === ShapeTool.Rect ||
                              this.currentShape === ShapeTool.Circle ||
                              this.currentShape === ShapeTool.Ellipse)) {
                            return
                          }

                          // ğŸ‘‰ å¦åˆ™ï¼šå¹³ç§»ç”»å¸ƒ
                          this.offsetX = this.lastPanX + e.offsetX
                          this.offsetY = this.lastPanY + e.offsetY
                        })
                        .onActionEnd((e: GestureEvent) => {
                          // è‡ªç”±ç”»ç»“æŸ
                          if (this.isFreeDrawing && this.currentShape === ShapeTool.FreeDraw) {
                            this.handleFreeDrawEnd()
                            return
                          }

                          // å›¾å½¢ç»“æŸ
                          if (!e.fingerList || e.fingerList.length === 0) {
                            this.isShapeDrawing = false
                            return
                          }

                          const f = e.fingerList[0] // â† å·²å»æ‰ GestureFinger

                          const endUiX: number = f.localX
                          const endUiY: number = f.localY


                          // â‘¢ å›¾å½¢ç»“æŸï¼šç›´çº¿ / çŸ©å½¢ / åœ† / æ¤­åœ†
                          if (this.isShapeDrawing &&
                            (this.currentShape === ShapeTool.Line ||
                              this.currentShape === ShapeTool.Rect ||
                              this.currentShape === ShapeTool.Circle ||
                              this.currentShape === ShapeTool.Ellipse)) {

                            this.isShapeDrawing = false

                            if (this.currentShape === ShapeTool.Line) {
                              this.handleLineDrag(this.shapeStartUiX, this.shapeStartUiY, endUiX, endUiY)
                            } else if (this.currentShape === ShapeTool.Rect) {
                              this.handleRectDrag(this.shapeStartUiX, this.shapeStartUiY, endUiX, endUiY)
                            } else if (this.currentShape === ShapeTool.Circle) {
                              this.handleCircleDrag(this.shapeStartUiX, this.shapeStartUiY, endUiX, endUiY)
                            } else if (this.currentShape === ShapeTool.Ellipse) {
                              this.handleEllipseDrag(this.shapeStartUiX, this.shapeStartUiY, endUiX, endUiY)
                            }
                          }
                        }),
                      // ç¼©æ”¾ï¼šä¿æŒåŸæ¥çš„é€»è¾‘
                      PinchGesture()
                        .onActionStart(e => {
                          this.lastZoom = this.zoom
                        })
                        .onActionUpdate(e => {
                          let next = this.lastZoom * e.scale
                          this.zoom = Math.min(5, Math.max(0.3, next))
                        })
                    )
                  )
              }


              // === è£å‰ªæ¨¡å¼ ===
              if (this.cropMode) {
                // æ‰‹åŠ¿ï¼šæ‹–å‡ºè£å‰ªæ¡†
                Stack()
                  .width('100%')
                  .height('100%')
                  .backgroundColor(Color.Transparent)
                  .gesture(
                    PanGesture({ direction: PanDirection.All })
                      .onActionStart(ev => {
                        const f = ev.fingerList[0]
                        this.cropStartX = f.localX
                        this.cropStartY = f.localY
                        this.cropEndX = f.localX
                        this.cropEndY = f.localY
                      })
                      .onActionUpdate(ev => {
                        const f = ev.fingerList[0]
                        this.cropEndX = f.localX
                        this.cropEndY = f.localY
                      })
                      .onActionEnd(() => {
                        this.doCrop()
                      })
                  )

                // ç”»è£å‰ªæ¡†ï¼ˆUIï¼‰
                Rect()
                  .position({
                    x: Math.min(this.cropStartX, this.cropEndX),
                    y: Math.min(this.cropStartY, this.cropEndY)
                  })
                  .width(Math.abs(this.cropEndX - this.cropStartX))
                  .height(Math.abs(this.cropEndY - this.cropStartY))
                  .stroke(Color.Red)
                  .strokeWidth(2)
                  .fill('rgba(255,0,0,0.18)')
              }

            }
          }
          .width('100%')
          .layoutWeight(1)
          .backgroundColor('#FFFFFF')
          .borderRadius(12)
          .padding(2)
          .clip(true)
          .onAreaChange((oldArea, newArea) => {
            this.canvasWidth = Number(newArea.width)
            this.canvasHeight = Number(newArea.height)
          })


          // åº•éƒ¨å·¥å…·æ 
          Row({ space: 10 }) {
            Text('é¸¿ç»˜')
              .fontSize(16)
              .fontWeight(FontWeight.Medium)
              .fontColor('#6B7280')
              .layoutWeight(1)

            Button('æ‰“å¼€å›¾ç‰‡', { type: ButtonType.Capsule })
              .height(40).padding({ left: 14, right: 14 })
              .onClick(() => this.pickImage())

            SaveButton({
              icon: SaveIconStyle.FULL_FILLED,
              text: SaveDescription.SAVE_IMAGE,
              buttonType: ButtonType.Capsule
            })
              .height(40)
              .padding({ left: 14, right: 14 })
              .onClick(async (event, result: SaveButtonOnClickResult) => {
                if (result === SaveButtonOnClickResult.SUCCESS) {
                  // ç”¨æˆ·ç‚¹äº†ä¿å­˜æŒ‰é’®ï¼Œç³»ç»Ÿä¸´æ—¶æˆäºˆç›¸å†Œå†™å…¥æƒé™ï¼ˆçº¦ 5 ç§’ï¼‰
                  await this.saveImage()
                } else {
                  promptAction.showToast({ message: 'æˆæƒå¤±è´¥ï¼Œæ— æ³•ä¿å­˜' })
                }
              })

            Button('é‡ç½®', { type: ButtonType.Capsule })
              .height(40)
              .padding({ left: 14, right: 14 })
              .backgroundColor('#EEF2FF')
              .fontColor('#3B82F6')
              .onClick(() => {
                this.resetView();

                if (this.collabClient.connected) {
                  const senderId: string = this.localClientId || this.clientId;

                  const msg: CollabMessage = buildClearMessage(
                    senderId,
                    'main-layer'
                  );
                  this.collabClient.send(msg);
                } else {
                  console.error('[Collab] not connected, skip sRend clear');
                }
              })
          }
          .width('100%')
          .padding({
            left: 12,
            right: 12,
            top: 10,
            bottom: 10
          })
          .backgroundColor('#F7F8FA')
          .border({ width: { top: 0.5 }, color: '#E5E7EB' })
          .alignItems(VerticalAlign.Center)

        }
        .width('100%').height('100%')
        .backgroundColor('#FFFFFF')
        .padding(12)
      }
    }
  }

  private async shareToWeChat(): Promise<void> {
  }

  private async shareToWeibo(): Promise<void> {
  }

  private async shareByEmail(): Promise<void> {
  }

  private async loadLogoPixelMap(): Promise<image.PixelMap> {
    const context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;
    const resMgr = context.resourceManager;

    const logoId: number = $r('app.media.logo').id;

    // è¯»å‡ºäºŒè¿›åˆ¶æ•°æ®ï¼ˆUint8Arrayï¼‰
    const fileData: Uint8Array = await resMgr.getMediaContent(logoId);

    // â­ å…³é”®ï¼šåªå–è¿™ä¸€æ®µçš„æœ‰æ•ˆæ•°æ®ï¼Œé¿å…ä½¿ç”¨æ•´ä¸ª buffer å¸¦æ¥çš„è„æ•°æ®
    const buffer: ArrayBuffer = fileData.buffer.slice(
      fileData.byteOffset,
      fileData.byteOffset + fileData.byteLength
    );

    const imgSource: image.ImageSource = image.createImageSource(buffer);
    const logoPm: image.PixelMap = await imgSource.createPixelMap({
      editable: true
    });
    imgSource.release?.();

    return logoPm;
  }

  // åœ¨ç»˜åˆ¶å±‚ layerPm ä¸Šï¼ŒæŠŠ watermarkPm æŒ‰ (offsetX, offsetY) è´´ä¸Šå»
  private async pasteWatermarkIntoLayer(
    layerPm: image.PixelMap,
    watermarkPm: image.PixelMap,
    offsetX: number,
    offsetY: number
  ): Promise<void> {
    const layerInfo: image.ImageInfo = await layerPm.getImageInfo();
    const wmInfo: image.ImageInfo = await watermarkPm.getImageInfo();

    const layerW: number = layerInfo.size.width;
    const layerH: number = layerInfo.size.height;
    const wmW: number = wmInfo.size.width;
    const wmH: number = wmInfo.size.height;

    // å°ºå¯¸å…œåº•ï¼šå®Œå…¨åœ¨å¤–é¢å°±ä¸ç”¨ç”»
    if (wmW <= 0 || wmH <= 0 || layerW <= 0 || layerH <= 0) {
      console.info('>>> pasteWatermarkIntoLayer: invalid size, skip');
      return;
    }

    // è¯»å–åƒç´ æ•°æ®
    const layerLen: number = layerPm.getPixelBytesNumber();
    const wmLen: number = watermarkPm.getPixelBytesNumber();

    const layerBuf: ArrayBuffer = new ArrayBuffer(layerLen);
    const wmBuf: ArrayBuffer = new ArrayBuffer(wmLen);

    await layerPm.readPixelsToBuffer(layerBuf);
    await watermarkPm.readPixelsToBuffer(wmBuf);

    const layerData: Uint8Array = new Uint8Array(layerBuf);
    const wmData: Uint8Array = new Uint8Array(wmBuf);

    // ------- layer é€šé“åç§» -------
    let lrOff: number = 0;
    let lgOff: number = 1;
    let lbOff: number = 2;
    let laOff: number = 3;

    switch (layerInfo.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        lbOff = 0;
        lgOff = 1;
        lrOff = 2;
        laOff = 3;
        break;
      case image.PixelMapFormat.ARGB_8888:
        laOff = 0;
        lrOff = 1;
        lgOff = 2;
        lbOff = 3;
        break;
      case image.PixelMapFormat.RGBA_8888:
      default:
        lrOff = 0;
        lgOff = 1;
        lbOff = 2;
        laOff = 3;
        break;
    }

    // ------- watermark é€šé“åç§» -------
    let wrOff: number = 0;
    let wgOff: number = 1;
    let wbOff: number = 2;
    let waOff: number = 3;

    switch (wmInfo.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        wbOff = 0;
        wgOff = 1;
        wrOff = 2;
        waOff = 3;
        break;
      case image.PixelMapFormat.ARGB_8888:
        waOff = 0;
        wrOff = 1;
        wgOff = 2;
        wbOff = 3;
        break;
      case image.PixelMapFormat.RGBA_8888:
      default:
        wrOff = 0;
        wgOff = 1;
        wbOff = 2;
        waOff = 3;
        break;
    }

    // ç®€å•ç­–ç•¥ï¼šåªè¦ watermark åƒç´  alpha > 0ï¼Œå°±ç›´æ¥è¦†ç›–ç»˜åˆ¶å±‚å¯¹åº”åƒç´ 
    for (let wy: number = 0; wy < wmH; wy++) {
      const ty: number = offsetY + wy;
      if (ty < 0 || ty >= layerH) {
        continue;
      }

      for (let wx: number = 0; wx < wmW; wx++) {
        const tx: number = offsetX + wx;
        if (tx < 0 || tx >= layerW) {
          continue;
        }

        const wmIdx: number = (wy * wmW + wx) * 4;
        const waIdx: number = wmIdx + waOff;
        const alpha: number = wmData[waIdx];

        if (alpha === 0) {
          // æ°´å°è¿™ç‚¹å®Œå…¨é€æ˜ï¼Œä¸ç”¨ç®¡
          continue;
        }

        const lrIdx: number = (ty * layerW + tx) * 4 + lrOff;
        const lgIdx: number = (ty * layerW + tx) * 4 + lgOff;
        const lbIdx: number = (ty * layerW + tx) * 4 + lbOff;
        const laIdx: number = (ty * layerW + tx) * 4 + laOff;

        const wrIdx: number = wmIdx + wrOff;
        const wgIdx: number = wmIdx + wgOff;
        const wbIdx: number = wmIdx + wbOff;

        layerData[lrIdx] = wmData[wrIdx];
        layerData[lgIdx] = wmData[wgIdx];
        layerData[lbIdx] = wmData[wbIdx];
        layerData[laIdx] = alpha;
      }
    }

    await layerPm.writeBufferToPixels(layerBuf);
  }

  // è°ƒæ•´æ°´å°å¤§å°
  // è°ƒæ•´æ°´å°å¤§å°ä¸ºç›®æ ‡å°ºå¯¸
  // æŠŠæ°´å°ç¼©æ”¾åˆ°ä¸è¶…è¿‡ targetWidth x targetHeightï¼ˆä¿æŒé•¿å®½æ¯”ï¼‰
  // å¦‚æœæœ¬æ¥å°±æ¯”ç›®æ ‡å°ï¼Œå°±ä¸ç¼©æ”¾
  private async resizeWatermark(
    watermarkPm: image.PixelMap,
    targetWidth: number,
    targetHeight: number
  ): Promise<image.PixelMap> {
    const wmInfo: image.ImageInfo = await watermarkPm.getImageInfo();
    const srcW: number = wmInfo.size.width;
    const srcH: number = wmInfo.size.height;

    // æ°´å°æœ¬æ¥å°±æ¯”ç›®æ ‡å°ï¼Œç›´æ¥ç”¨åŸå›¾
    if (srcW <= targetWidth && srcH <= targetHeight) {
      return watermarkPm;
    }

    // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼ˆä¿æŒé•¿å®½æ¯”ï¼Œæœ€é•¿è¾¹ = targetï¼‰
    const scaleX: number = targetWidth / srcW;
    const scaleY: number = targetHeight / srcH;
    const scale: number = Math.min(scaleX, scaleY);

    // å¾—åˆ°æ–°çš„å®½é«˜ï¼ˆè‡³å°‘ 1 åƒç´ ï¼‰
    const newW: number = Math.max(1, Math.floor(srcW * scale));
    const newH: number = Math.max(1, Math.floor(srcH * scale));

    // è¯»å–åŸå§‹æ°´å°åƒç´ 
    const srcLen: number = watermarkPm.getPixelBytesNumber();
    const srcBuf: ArrayBuffer = new ArrayBuffer(srcLen);
    await watermarkPm.readPixelsToBuffer(srcBuf);
    const srcData: Uint8Array = new Uint8Array(srcBuf);

    // å‡†å¤‡ç›®æ ‡åƒç´ ç¼“å†²åŒºï¼ˆæˆ‘ä»¬ç”¨ RGBA_8888ï¼‰
    const dstBuf: ArrayBuffer = new ArrayBuffer(newW * newH * 4);
    const dstData: Uint8Array = new Uint8Array(dstBuf);

    // æºåƒç´ é€šé“åç§»
    let srOff: number = 0;
    let sgOff: number = 1;
    let sbOff: number = 2;
    let saOff: number = 3;

    switch (wmInfo.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        sbOff = 0;
        sgOff = 1;
        srOff = 2;
        saOff = 3;
        break;
      case image.PixelMapFormat.ARGB_8888:
        saOff = 0;
        srOff = 1;
        sgOff = 2;
        sbOff = 3;
        break;
      case image.PixelMapFormat.RGBA_8888:
      default:
        srOff = 0;
        sgOff = 1;
        sbOff = 2;
        saOff = 3;
        break;
    }

    // æœ€è¿‘é‚»ç¼©æ”¾ï¼šå¯¹ç›®æ ‡ (dx,dy)ï¼Œåœ¨åŸå›¾ä¸­æ‰¾ä¸€ä¸ªæœ€è¿‘çš„ (sx,sy)
    for (let dy: number = 0; dy < newH; dy++) {
      const srcY: number = Math.min(srcH - 1, Math.floor(dy / scale));
      for (let dx: number = 0; dx < newW; dx++) {
        const srcX: number = Math.min(srcW - 1, Math.floor(dx / scale));

        const srcIndex: number = (srcY * srcW + srcX) * 4;
        const r: number = srcData[srcIndex + srOff];
        const g: number = srcData[srcIndex + sgOff];
        const b: number = srcData[srcIndex + sbOff];
        const a: number = srcData[srcIndex + saOff];

        const dstIndex: number = (dy * newW + dx) * 4;
        // ç›®æ ‡æˆ‘ä»¬ç›´æ¥æŒ‰ RGBA å†™
        dstData[dstIndex + 0] = r;
        dstData[dstIndex + 1] = g;
        dstData[dstIndex + 2] = b;
        dstData[dstIndex + 3] = a;
      }
    }

    // ç”¨æˆ‘ä»¬è‡ªå·±ç”Ÿæˆçš„åƒç´ æ•°æ®åˆ›å»ºä¸€å¼ æ–°çš„ PixelMapï¼ˆRGBA_8888ï¼‰
    const opts: image.InitializationOptions = {
      editable: true,
      pixelFormat: image.PixelMapFormat.RGBA_8888,
      size: {
        width: newW,
        height: newH
      }
    };

    const resizedPm: image.PixelMap = await image.createPixelMap(dstBuf, opts);
    return resizedPm;
  }

  // æ·»åŠ æ°´å°åˆ°å½“å‰ç»˜åˆ¶å›¾å±‚
  private async addWatermark(): Promise<void> {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' });
      return;
    }

    // å…ˆå‹ä¸€ä»½å¿«ç…§ï¼Œæ”¯æŒæ’¤é”€
    await this.pushFullSnapshotBeforeChange();

    // ç¡®ä¿æœ‰ç»˜åˆ¶å›¾å±‚
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer();
    if (!layerPm) {
      promptAction.showToast({ message: 'å½“å‰æ²¡æœ‰å¯ç¼–è¾‘å›¾å±‚' });
      return;
    }

    // åŠ è½½å¹¶è°ƒæ•´æ°´å°å¤§å°ï¼ˆè°ƒæ•´ä¸º 30x30pxï¼‰
    const logoPm: image.PixelMap = await this.loadLogoPixelMap();
    const resizedLogoPm: image.PixelMap = await this.resizeWatermark(logoPm, 100, 100); // è°ƒæ•´ä¸º 30x30px

    // è·å–å›¾å±‚ä¿¡æ¯
    const layerInfo: image.ImageInfo = await layerPm.getImageInfo();
    const layerW: number = layerInfo.size.width;
    const layerH: number = layerInfo.size.height;

    // è·å–æ°´å°å›¾ç‰‡çš„å°ºå¯¸
    const watermarkInfo: image.ImageInfo = await resizedLogoPm.getImageInfo();
    const watermarkWidth: number = watermarkInfo.size.width;
    const watermarkHeight: number = watermarkInfo.size.height;

    // å³ä¸‹è§’ï¼Œé¢„ç•™ 10px è¾¹è·
    const margin: number = 10;
    let offsetX: number = layerW - watermarkWidth - margin;
    let offsetY: number = layerH - watermarkHeight - margin;

    // é˜²æ­¢æ°´å°æ¯”å›¾è¿˜å¤§ / å‡ºç•Œ
    if (offsetX < 0) {
      offsetX = 0;
    }
    if (offsetY < 0) {
      offsetY = 0;
    }

    // æŠŠè°ƒæ•´å¥½çš„æ°´å°è´´åˆ°ç»˜åˆ¶å›¾å±‚
    await this.pasteWatermarkIntoLayer(layerPm, resizedLogoPm, offsetX, offsetY);

    // clone ä¸€ä»½æ–°å›¾å±‚ï¼Œå¼ºåˆ¶ UI åˆ·æ–°
    const newLayer: image.PixelMap = await this.clonePixelMap(layerPm);
    if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
      this.drawPixelMap.release?.();
    }
    this.drawPixelMap = newLayer;
    this.drawPixelVersion++;

    // å†™æ“ä½œæ—¥å¿— + åä½œåŒæ­¥
    const desc: string = 'åœ¨å³ä¸‹è§’æ·»åŠ äº†æ°´å°';
    await this.logAndSyncAfterImageChange(desc);

    promptAction.showToast({ message: 'æ°´å°å·²æ·»åŠ ' });
  }

  // æ ¹æ®åº•å›¾ pm åˆ›å»ºä¸€å¼ â€œå®Œå…¨é€æ˜â€çš„ç»˜åˆ¶å›¾å±‚ï¼ˆå°ºå¯¸ & åƒç´ æ ¼å¼ä¸€è‡´ï¼‰
  private async createEmptyDrawLayerLike(pm: image.PixelMap): Promise<image.PixelMap> {
    // 1. å…ˆ clone ä¸€ä»½ï¼Œä¿è¯ editable
    const layer: image.PixelMap = await this.clonePixelMap(pm)

    // 2. æŠŠæ‰€æœ‰åƒç´ æ¸…æˆé€æ˜
    const byteLength: number = layer.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await layer.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    for (let i = 0; i < data.length; i += 4) {
      data[i] = 0 // R
      data[i + 1] = 0 // G
      data[i + 2] = 0 // B
      data[i + 3] = 0 // A = 0 å®Œå…¨é€æ˜
    }

    await layer.writeBufferToPixels(buffer)
    return layer
  }

  // ç¡®ä¿å­˜åœ¨ç»˜åˆ¶å›¾å±‚ï¼šæ²¡æœ‰å°±åˆ›å»ºï¼Œæœ‰å°±ç›´æ¥è¿”å›
  private async ensureDrawLayer(): Promise<image.PixelMap | undefined> {
    if (!this.pixelMap) {
      return undefined
    }

    if (!this.drawPixelMap) {
      const basePm = this.pixelMap as image.PixelMap
      this.drawPixelMap = await this.createEmptyDrawLayerLike(basePm)
      this.drawPixelVersion++
    }

    return this.drawPixelMap as image.PixelMap
  }

  // é¸¿è’™ 6.0 å®˜æ–¹å¯ç”¨ã€ä¸å˜è‰²çš„å…‹éš†ï¼špack â†’ decode
  private async clonePixelMap(pm: image.PixelMap): Promise<image.PixelMap> {
    // 1. pack æˆ PNG å†…å­˜æµï¼ˆæ³¨æ„ï¼špackToData åªæœ‰ä¸¤ä¸ªå‚æ•°ï¼‰
    const packer = image.createImagePacker()
    const packOpts: image.PackingOption = {
      format: 'image/png', // PNG æ— æŸï¼Œé¢œè‰²æœ€å®‰å…¨
      quality: 100
    }

    // HarmonyOS 6.0ï¼špackToData è¿”å› Promise<ArrayBuffer>
    const buffer: ArrayBuffer = await packer.packToData(pm, packOpts)
    packer.release?.()

    // 2. å† decode æˆæ–°çš„ PixelMapï¼ˆä¿æŒ editableï¼‰
    const imgSource = image.createImageSource(buffer)
    const clonePm: image.PixelMap = await imgSource.createPixelMap({
      editable: true
    })
    imgSource.release?.()

    return clonePm
  }

  // åœ¨ä¸€æ¬¡â€œä¼šæ”¹å˜å›¾åƒ/çŠ¶æ€â€çš„æ“ä½œä¹‹å‰è°ƒç”¨ï¼Œè®°å½•å¿«ç…§
  // includePixel = trueï¼šæŠŠ pmForSnapshot è¿™å¼ å›¾ä½œä¸ºå¿«ç…§ä¿å­˜ï¼ˆä¸æ‹·è´åƒç´ ï¼‰â€”â€”ä¸“é—¨ç»™è£å‰ªç”¨
  private async pushHistorySnapshot(includePixel: boolean, pmForSnapshot?: image.PixelMap): Promise<void> {
    let snapshotPixel: image.PixelMap | undefined = undefined
    let snapshotDraw: image.PixelMap | undefined = undefined // â­ æ–°å¢

    // æ˜¯å¦åŒ…å«åƒç´ å¿«ç…§ï¼ˆåº•å›¾ï¼‰
    if (includePixel && pmForSnapshot) {
      snapshotPixel = pmForSnapshot
    }

    // â­ ä¸ç®¡åº•å›¾è¦ä¸è¦ä¿å­˜ï¼Œç»˜åˆ¶å›¾å±‚å¦‚æœå­˜åœ¨ï¼Œéƒ½ clone ä¸€ä»½ä¿å­˜å¿«ç…§
    if (this.drawPixelMap) {
      snapshotDraw = await this.clonePixelMap(this.drawPixelMap as image.PixelMap)
    }

    // å¦‚æœå·²ç»æ’¤é”€åˆ°ä¸­é—´ï¼Œå†åšæ–°æ“ä½œï¼Œåˆ™ç æ‰â€œæœªæ¥â€åˆ†æ”¯
    if (this.historyIndex >= 0 && this.historyIndex < this.history.length - 1) {
      for (let i = this.historyIndex + 1; i < this.history.length; i++) {
        this.history[i].pixelMap?.release?.()
        this.history[i].drawPixelMap?.release?.() // â­ è®°å¾—é‡Šæ”¾ç»˜åˆ¶å±‚å¿«ç…§
      }
      this.history = this.history.slice(0, this.historyIndex + 1)
    }

    this.history.push({
      pixelMap: snapshotPixel,
      drawPixelMap: snapshotDraw, // â­ å­˜è¿›å»
      zoom: this.zoom,
      offsetX: this.offsetX,
      offsetY: this.offsetY,
      brightnessLevel: this.brightnessLevel,
      contrastLevel: this.contrastLevel,
      accumulatedRotate: this.accumulatedRotate
    })

    this.historyIndex = this.history.length - 1
  }

  // é‡ç½®åˆ°â€œåˆšæ‰“å¼€å›¾ç‰‡æ—¶â€çš„çŠ¶æ€
  private async resetView(): Promise<void> {
    // â‘  æ²¡æœ‰å›¾ï¼Œç›´æ¥è¿”å›
    if (!this.pixelMap) {
      return;
    }

    // â‘¡ æ²¡æœ‰åŸå›¾å¿«ç…§ï¼šåªé‡ç½®è§†å›¾å‚æ•°ï¼ˆå…¼å®¹è€æ•°æ®ï¼‰
    if (!this.originalPixelMap) {
      this.zoom = 1.0;
      this.offsetX = 0;
      this.offsetY = 0;
      this.brightnessLevel = 0.0;
      this.contrastLevel = 0.0;
      this.accumulatedRotate = 0;
      this.pixelVersion++;
      return;
    }

    // â‘¢ åœ¨é‡ç½®ä¹‹å‰ï¼Œå…ˆæŠŠå½“å‰çŠ¶æ€æ”¾è¿›å†å²æ ˆï¼Œreset ä¹Ÿèƒ½â€œæ’¤é”€â€
    const currentPm: image.PixelMap = this.pixelMap as image.PixelMap;
    const beforeResetPm: image.PixelMap = await this.clonePixelMap(currentPm);
    await this.pushHistorySnapshot(true, beforeResetPm);

    // â‘£ ç”¨ originalPixelMap è¿˜åŸåº•å›¾ï¼ˆé‡æ–° clone ä¸€ä»½å¯ç¼–è¾‘ç‰ˆæœ¬ï¼‰
    const originalPm: image.PixelMap = this.originalPixelMap as image.PixelMap;
    const newPm: image.PixelMap = await this.clonePixelMap(originalPm);

    // é‡Šæ”¾å½“å‰åº•å›¾
    currentPm.release();

    // æ›¿æ¢ä¸ºâ€œåˆšæ‰“å¼€å›¾ç‰‡æ—¶â€çš„åº•å›¾
    this.pixelMap = newPm;

    // â‘¤ é‡å»ºç»˜åˆ¶å›¾å±‚ï¼šç›¸å½“äºæ–°å»ºä¸€å¼ å…¨é€æ˜çš„ overlay
    if (this.drawPixelMap) {
      const currentDrawPm: image.PixelMap = this.drawPixelMap as image.PixelMap;
      currentDrawPm.release();
    }
    const drawLayer: image.PixelMap = await this.createEmptyDrawLayerLike(newPm);
    this.drawPixelMap = drawLayer;
    this.drawPixelVersion++; // è§¦å‘å åŠ å±‚ Image åˆ·æ–°

    // â‘¥ è¿˜åŸè§†å›¾å‚æ•°
    this.zoom = 1.0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.brightnessLevel = 0.0;
    this.contrastLevel = 0.0;
    this.accumulatedRotate = 0;

    // â‘¦ é€šçŸ¥åº•å›¾åˆ·æ–°
    this.pixelVersion++;
  }

  // æ‰“å¼€å›¾ç‰‡ï¼ˆ
  private async pickImage() {
    try {
      // é€‰å›¾
      const picker = new photoAccessHelper.PhotoViewPicker()
      const options = new photoAccessHelper.PhotoSelectOptions()
      // åªé€‰æ‹©å›¾ç‰‡
      options.MIMEType = photoAccessHelper.PhotoViewMIMETypes.IMAGE_TYPE
      // ä¸€æ¬¡æœ€å¤šé€‰ä¸€å¼ 
      options.maxSelectNumber = 1

      // ç­‰å¾…ç”¨æˆ·é€‰æ‹©å›¾ç‰‡å¹¶æ‹¿å»ç»“æœ
      const result = await picker.select(options)
      const uris: Array<string> = result.photoUris

      // ç”¨æˆ·æœªé€‰æ‹©å›¾ç‰‡æç¤º
      if (!uris || uris.length === 0) {
        promptAction.showToast({ message: 'æœªé€‰æ‹©å›¾ç‰‡' })
        return
      }

      // å¾—åˆ°å›¾ç‰‡åœ°å€
      const uri: string = uris[0]
      console.info(`>>> Selected URI = ${uri}`)

      // ç”¨ fileIo æ‰“å¼€ uriï¼Œæ‹¿ fd
      const file = await fileIo.open(uri, fileIo.OpenMode.READ_ONLY)

      // æŠŠ fd äº¤ç»™ ImageKit è§£ç  â†’ å¾—åˆ° ImageSource
      const imgSource: image.ImageSource = image.createImageSource(file.fd)
      if (!imgSource) {
        await fileIo.close(file)
        throw new Error('createImageSource è¿”å›ç©º')
      }

      // ä» ImageSource åˆ›å»º PixelMap
      const pm: image.PixelMap = await imgSource.createPixelMap({
        editable: true
      })

      // é‡Šæ”¾åº•å±‚èµ„æº
      imgSource.release?.()
      await fileIo.close(file)

      // æ›´æ–° UI çŠ¶æ€
      // å…ˆé‡Šæ”¾æ—§çš„åŸå›¾å¿«ç…§
      if (this.originalPixelMap) {
        this.originalPixelMap.release?.()
      }
      // ä¿å­˜ä¸€ä»½â€œæ‰“å¼€æ—¶çš„åŸå›¾â€ï¼ˆä»¥å resetView å°±ç”¨å®ƒæ¥è¿˜åŸï¼‰
      this.originalPixelMap = await this.clonePixelMap(pm)

      // é‡Šæ”¾æ—§çš„å½“å‰å›¾
      if (this.pixelMap) {
        this.pixelMap.release?.()
      }
      // å½“å‰æ­£åœ¨ç¼–è¾‘çš„ PixelMap
      this.pixelMap = pm

      // åˆå§‹åŒ–è§†å›¾åˆ°â€œåˆšæ‰“å¼€â€çš„çŠ¶æ€
      this.zoom = 1.0
      this.offsetX = 0
      this.offsetY = 0
      this.brightnessLevel = 0.0
      this.contrastLevel = 0.0
      this.accumulatedRotate = 0
      this.pixelVersion++

      // ğŸ‘‰ æ–°å¢ï¼šè®°å½•å½“å‰å›¾ç‰‡å¯¹è§’çº¿ï¼Œç”¨äºåç»­è£å‰ªæ—¶è®¡ç®—æ¯”ä¾‹
      const openInfo: image.ImageInfo = await pm.getImageInfo()
      const openW: number = openInfo.size.width
      const openH: number = openInfo.size.height
      this.imageDiag = Math.hypot(openW, openH)

      // ========== æ–°å¢ï¼šä¸ºè¿™å¼ å›¾ç‰‡åˆ›å»ºä¸€å±‚é€æ˜çš„ç»˜åˆ¶å±‚ ==========
      if (this.drawPixelMap) {
        this.drawPixelMap.release?.()
      }
      this.drawPixelMap = await this.createEmptyDrawLayerLike(pm)
      this.drawPixelVersion++
      // =========================================================
      const selfId: string = this.localClientId || this.clientId
      this.appendOpLog(selfId, 'æ‰“å¼€äº†ä¸€å¼ å›¾ç‰‡', this.localColor)

      if (this.collabClient.connected && this.pixelMap) {
        await this.broadcastImageToPeers(this.pixelMap as image.PixelMap, 'æ‰“å¼€äº†ä¸€å¼ å›¾ç‰‡')
      }

      promptAction.showToast({ message: 'å›¾ç‰‡å·²åŠ è½½ ' })
    } catch (err) {
      let code = 'NA'
      let message = 'unknown'

      if (typeof err === 'object' && err !== null) {
        const e = err as ErrorWithCode

        if (e.code !== undefined) {
          code = String(e.code)
        }
        if (e.message !== undefined) {
          message = String(e.message)
        }
      } else {
        message = String(err)
      }

      const msg = `code=${code} msg=${message}`
      console.error(`[pickImage] failed: ${msg}`)
      promptAction.showToast({ message: `æ‰“å¼€å¤±è´¥ï¼š${msg}` })
    }
  }

  // ä¿å­˜å›¾ç‰‡ï¼šæŠŠå½“å‰ PixelMap å†™å…¥ç³»ç»Ÿç›¸å†Œ
  private async saveImage() {
    try {
      if (!this.pixelMap) {
        promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
        return
      }

      const context = getContext(this) as common.UIAbilityContext
      const helper = photoAccessHelper.getPhotoAccessHelper(context)

      // 1) å…‹éš†ä¸€ä»½åº•å›¾ï¼Œç”¨äºä¿å­˜
      const basePm: image.PixelMap = this.pixelMap as image.PixelMap
      const pmForSave: image.PixelMap = await this.clonePixelMap(basePm)

      // 2) æœ‰ç»˜åˆ¶å±‚çš„è¯ï¼Œå…ˆåˆæˆä¸Šå»
      if (this.drawPixelMap) {
        await this.mergeDrawLayerIntoBase(pmForSave, this.drawPixelMap as image.PixelMap)
      }

      // 3) æŠŠäº®åº¦/å¯¹æ¯”åº¦çƒ˜ç„™è¿› pmForSaveï¼ˆåªå½±å“ä¿å­˜ï¼Œä¸æ”¹çœŸå®çŠ¶æ€ï¼‰
      await this.bakeToneForSave(pmForSave)

      // 4) æ­£å¸¸ packToFile ä¿å­˜ pmForSave ...
      const uri: string = await helper.createAsset(
        photoAccessHelper.PhotoType.IMAGE,
        'jpg'
      )

      const file = await fileIo.open(
        uri,
        fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE
      )

      const packer = image.createImagePacker()
      const packOpts: image.PackingOption = {
        format: 'image/jpeg',
        quality: 90
      }

      await new Promise<void>((resolve, reject) => {
        packer.packToFile(
          pmForSave,
          file.fd,
          packOpts,
          (err: BusinessError) => err ? reject(err) : resolve()
        )
      })

      packer.release?.()
      await fileIo.close(file)

      promptAction.showToast({ message: 'å·²ä¿å­˜åˆ°ç›¸å†Œ ' })
    } catch (err) {
      const e = err as BusinessError
      console.error(`saveImage failed, code=${e?.code}, msg=${e?.message}`)
      promptAction.showToast({ message: 'ä¿å­˜å¤±è´¥' })
    }
  }

  // è£å‰ªï¼šæ ¹æ®å½“å‰è£å‰ªæ¡†ï¼ŒæŠŠåº•å›¾å’Œç»˜åˆ¶å±‚ä¸€èµ·è£å‰ªï¼Œå¹¶â€œæ¸©å’Œâ€è°ƒæ•´ç”»ç¬”ç²—ç»†
  private async doCrop(): Promise<void> {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }

    const pm: image.PixelMap = this.pixelMap as image.PixelMap
    const info: image.ImageInfo = await pm.getImageInfo()

    // ç”»å¸ƒå°ºå¯¸ã€é˜²å¾¡
    if (this.canvasWidth <= 0 || this.canvasHeight <= 0) {
      promptAction.showToast({ message: 'ç”»å¸ƒå°šæœªåˆå§‹åŒ–' })
      this.cropMode = false
      return
    }

    // === 1. è®¡ç®—å›¾ç‰‡åœ¨ç”»å¸ƒä¸Šçš„å®é™…æ˜¾ç¤ºåŒºåŸŸï¼ˆè€ƒè™‘ contain + zoom + å¹³ç§»ï¼‰===
    const imgW: number = info.size.width
    const imgH: number = info.size.height

    const scaleBase: number = Math.min(
      this.canvasWidth / imgW,
      this.canvasHeight / imgH
    )

    if (scaleBase <= 0) {
      promptAction.showToast({ message: 'ç¼©æ”¾å‚æ•°å¼‚å¸¸' })
      this.cropMode = false
      return
    }

    const realW: number = imgW * scaleBase * this.zoom
    const realH: number = imgH * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY
    const imageRight: number = imageLeft + realW
    const imageBottom: number = imageTop + realH

    // === 2. è¯»å– UI è£å‰ªæ¡†ï¼Œå¹¶ä¸å›¾ç‰‡æ˜¾ç¤ºåŒºåŸŸæ±‚äº¤é›† ===
    let uiX1: number = Math.min(this.cropStartX, this.cropEndX)
    let uiY1: number = Math.min(this.cropStartY, this.cropEndY)
    let uiX2: number = Math.max(this.cropStartX, this.cropEndX)
    let uiY2: number = Math.max(this.cropStartY, this.cropEndY)

    // å’Œå›¾ç‰‡å¯è§åŒºåŸŸæ±‚äº¤
    uiX1 = Math.max(uiX1, imageLeft)
    uiY1 = Math.max(uiY1, imageTop)
    uiX2 = Math.min(uiX2, imageRight)
    uiY2 = Math.min(uiY2, imageBottom)

    if (uiX2 <= uiX1 || uiY2 <= uiY1) {
      promptAction.showToast({ message: 'è£å‰ªåŒºåŸŸè¶…å‡ºå›¾ç‰‡èŒƒå›´' })
      this.cropMode = false
      return
    }

    // === 3. UI åæ ‡æ˜ å°„åˆ°åƒç´ åæ ‡ ===
    const px1Float: number = (uiX1 - imageLeft) * (imgW / realW)
    const py1Float: number = (uiY1 - imageTop) * (imgH / realH)
    const px2Float: number = (uiX2 - imageLeft) * (imgW / realW)
    const py2Float: number = (uiY2 - imageTop) * (imgH / realH)

    const cropX: number = Math.max(0, Math.floor(px1Float))
    const cropY: number = Math.max(0, Math.floor(py1Float))
    const cropW: number = Math.floor(px2Float - px1Float)
    const cropH: number = Math.floor(py2Float - py1Float)

    if (cropW <= 0 || cropH <= 0) {
      promptAction.showToast({ message: 'è£å‰ªåŒºåŸŸå¤ªå°' })
      this.cropMode = false
      return
    }

    // ========= 4. çœŸæ­£è£å‰ªï¼ˆåº•å›¾ + ç»˜åˆ¶å±‚ï¼‰ï¼Œå¹¶è®°å½•æ’¤é”€ =========

    // 4.1 è£å‰ªå‰å¤‡ä»½ä¸€ä»½å®Œæ•´åº•å›¾ï¼ˆç”¨äºæ’¤é”€ï¼‰
    const backupPm: image.PixelMap = await this.clonePixelMap(pm)
    await this.pushHistorySnapshot(true, backupPm)

    // 4.2 åœ¨å½“å‰ pixelMap ä¸ŠåŸåœ°è£å‰ªï¼ˆå¼•ç”¨ä¸å˜ï¼‰
    await pm.crop({
      x: cropX,
      y: cropY,
      size: { width: cropW, height: cropH }
    })

    // 4.3 è‹¥å­˜åœ¨ç»˜åˆ¶å›¾å±‚ï¼ŒåŒæ­¥è£å‰ªåŒä¸€åŒºåŸŸï¼Œä¿è¯å°ºå¯¸å¯¹é½
    if (this.drawPixelMap) {
      const overlayPm: image.PixelMap = this.drawPixelMap as image.PixelMap
      try {
        await overlayPm.crop({
          x: cropX,
          y: cropY,
          size: { width: cropW, height: cropH }
        })
        this.drawPixelVersion++
      } catch (e) {
        const err: Error = e as Error
        console.warn(`crop drawPixelMap failed: ${err.message}`)
      }
    }

    // ========= 5. æ¸©å’Œè°ƒæ•´ç”»ç¬”ç²—ç»†ï¼ˆé¿å…ä¸€æ¬¡è£å‰ªå˜åŒ–è¿‡çŒ›ï¼‰ =========

    // æ—§å¯¹è§’çº¿ï¼šä¼˜å…ˆç”¨ imageDiagï¼ˆå¦‚æœä½ åœ¨æ‰“å¼€å›¾ç‰‡æˆ– reset æ—¶æœ‰è®¾ç½®ï¼‰
    const oldDiag: number = this.imageDiag > 0
      ? this.imageDiag
      : Math.sqrt(imgW * imgW + imgH * imgH)

    const newDiag: number = Math.sqrt(cropW * cropW + cropH * cropH)

    if (oldDiag > 0 && newDiag > 0) {
      const rawRatio: number = newDiag / oldDiag // <1 è¡¨ç¤ºå›¾å˜å°

      // è¿™é‡Œæ˜¯â€œæ¸©å’Œç¼©æ”¾â€ï¼š
      // - ä¸æ”¾å¤§ç”»ç¬”ï¼šratio æœ€å¤§ 1.0
      // - æ¯æ¬¡æœ€å¤šç¼©å°åˆ° 80%ï¼šratio æœ€å° 0.8
      let ratio: number = rawRatio
      if (ratio > 1.0) {
        ratio = 1.0
      }
      if (ratio < 0.8) {
        ratio = 0.8
      }

      // åº”ç”¨ç¼©æ”¾ï¼Œæœ€ä½ä¸å°äº 1 åƒç´ 
      this.strokeWidth = Math.max(1, this.strokeWidth * ratio)

      // æ›´æ–°å½“å‰å›¾ç‰‡å¯¹è§’çº¿ï¼Œä½œä¸ºä¸‹ä¸€æ¬¡è£å‰ªçš„åŸºå‡†
      this.imageDiag = newDiag
    } else {
      // å…œåº•ï¼šæ— æ³•è®¡ç®—æ—¶ï¼Œåªè®°å½•æ–°å¯¹è§’çº¿ï¼Œä¸è°ƒæ•´ç”»ç¬”
      this.imageDiag = newDiag
    }

    // ========= 6. æ”¶å°¾ï¼šå¤ä½è§†å›¾ / æ¸…ç†çŠ¶æ€ =========
    this.cropMode = false
    this.zoom = 1.0
    this.offsetX = 0
    this.offsetY = 0
    this.pixelVersion++

    this.cropStartX = 0
    this.cropStartY = 0
    this.cropEndX = 0
    this.cropEndY = 0

    promptAction.showToast({ message: 'è£å‰ªå®Œæˆ' })
  }

  private async rotateRight90(): Promise<void> {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }
    if (this.isRotating) {
      return
    }

    await this.pushHistorySnapshot(false)

    this.isRotating = true
    try {
      // â‘  æ—‹è½¬åº•å›¾
      await (this.pixelMap as image.PixelMap).rotate(90)

      // â‘¡ è‹¥æœ‰ç»˜åˆ¶å±‚ï¼Œä¹Ÿä¸€èµ·æ—‹è½¬ï¼ˆå…³é”®ï¼‰
      if (this.drawPixelMap) {
        await (this.drawPixelMap as image.PixelMap).rotate(90)
        this.drawPixelVersion++
      }

      // â‘¢ æ›´æ–°ç´¯è®¡è§’åº¦
      this.accumulatedRotate = (this.accumulatedRotate + 90) % 360

      this.pixelVersion++
      await this.logAndSyncAfterImageChange('å·¦æ—‹è½¬ 90Â°')
    } catch (err) {
      const e = err as Error
      console.error(`rotateRight90 failed: ${e.message}`)
      promptAction.showToast({ message: 'å³æ—‹å¤±è´¥' })
    } finally {
      this.isRotating = false
    }
  }

  // å‘å·¦æ—‹è½¬ 90 åº¦ï¼ˆé€†æ—¶é’ˆï¼‰
  private async rotateLeft90(): Promise<void> {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }
    if (this.isRotating) {
      return
    }

    await this.pushHistorySnapshot(false)

    this.isRotating = true
    try {
      // â‘  åº•å›¾æ—‹è½¬
      await (this.pixelMap as image.PixelMap).rotate(270)

      // â‘¡ ç»˜åˆ¶å›¾å±‚åŒæ­¥æ—‹è½¬
      if (this.drawPixelMap) {
        await (this.drawPixelMap as image.PixelMap).rotate(270)
        this.drawPixelVersion++
      }

      // â‘¢ æ›´æ–°ç´¯è®¡è§’åº¦
      this.accumulatedRotate = (this.accumulatedRotate + 270) % 360

      this.pixelVersion++
      await this.logAndSyncAfterImageChange('å·¦æ—‹è½¬ 90Â°')
    } catch (err) {
      const e = err as Error
      console.error(`rotateLeft90 failed: ${e.message}`)
      promptAction.showToast({ message: 'å·¦æ—‹å¤±è´¥' })
    } finally {
      this.isRotating = false
    }
  }

  // äº®åº¦è°ƒæ•´
  // äº®åº¦è°ƒæ•´
  private async adjustBrightness(delta: number) {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }

    // è®°å½•å½“å‰äº®åº¦/å¯¹æ¯”åº¦å‚æ•°ï¼ˆä¸æ‹·è´åƒç´ ï¼‰
    await this.pushHistorySnapshot(false)

    // brightnessLevel å–ä¸€ä¸ªç›¸å¯¹æ¸©å’Œçš„åŒºé—´ï¼Œé˜²æ­¢å´©å
    this.brightnessLevel += delta

    const MAX_LEVEL: number = 0.5 // å¤§çº¦ +128
    const MIN_LEVEL: number = -0.5 // å¤§çº¦ -128

    if (this.brightnessLevel > MAX_LEVEL) {
      this.brightnessLevel = MAX_LEVEL
    }
    if (this.brightnessLevel < MIN_LEVEL) {
      this.brightnessLevel = MIN_LEVEL
    }

    // === æ–°å¢ï¼šæ„é€ æè¿° + è®°å½•æ“ä½œ + åä½œåŒæ­¥ ===
    let desc: string
    if (delta > 0) {
      desc = 'æé«˜äº†äº®åº¦'
    } else if (delta < 0) {
      desc = 'é™ä½äº†äº®åº¦'
    } else {
      desc = 'è°ƒæ•´äº†äº®åº¦'
    }

    await this.logAndSyncAfterImageChange(desc)
  }

  // æ„å»ºäº®åº¦ + å¯¹æ¯”åº¦çŸ©é˜µ
  private buildToneMatrix(): Array<number> {
    // äº®åº¦ï¼ˆå»ºè®®èŒƒå›´ [-0.5, 0.5]ï¼‰
    const b: number = this.brightnessLevel

    // å¯¹æ¯”åº¦ç³»æ•° cï¼šcontrastLevel âˆˆ [-1,1] å¯¹åº” c âˆˆ [0,2]
    const c: number = 1.0 + this.contrastLevel

    // ä¸ºäº†è®©â€œä¿æŒä¸­å¿ƒç‚¹ä¸å˜â€ï¼Œéœ€è¦é¢å¤–çš„åç§»é¡¹
    // åœ¨å½’ä¸€åŒ–[0,1]ç©ºé—´é‡Œï¼Œä¸­ç‚¹æ˜¯ 0.5ï¼š
    // new = (old - 0.5) * c + 0.5 + b
    //     = c * old + (0.5 * (1 - c) + b)
    const offset: number = 0.5 * (1.0 - c) + b

    return [
      c, 0, 0, 0, offset,
      0, c, 0, 0, offset,
      0, 0, c, 0, offset,
      0, 0, 0, 1, 0
    ]
  }

  // æŠŠå½“å‰ brightnessLevel & contrastLevel ä¸€èµ·çƒ˜ç„™åˆ° pixelMap é‡Œ
  // æ³¨æ„ï¼šè°ƒç”¨åä¼šæŠŠ brightnessLevel / contrastLevel å½’é›¶ï¼Œå¹¶è§¦å‘ä¸€æ¬¡åˆ·æ–°
  private async bakeToneToPixelMap(pm: image.PixelMap): Promise<void> {
    // æ²¡æœ‰è°ƒæ•´äº®åº¦å’Œå¯¹æ¯”åº¦å°±ä¸ç”¨åŠ¨åƒç´ ï¼Œç›´æ¥è¿”å›
    if (this.brightnessLevel === 0 && this.contrastLevel === 0) {
      return
    }

    // è¯»å‡ºåƒç´ æ•°æ®
    const info: image.ImageInfo = await pm.getImageInfo()
    const byteLength: number = pm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await pm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // åˆ¤æ–­é€šé“é¡ºåºï¼Œé˜²æ­¢é¢œè‰²é”™ä¹±
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        // B G R A
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        // A R G B
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
      // R G B A
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    // å¯¹æ¯”åº¦ç³»æ•° cï¼ˆ0~2ï¼‰ï¼Œäº®åº¦åç§» *255
    const c: number = 1.0 + this.contrastLevel
    const shiftBrightness: number = this.brightnessLevel * 255.0
    // æŠŠå…¬å¼ new = (old - 128)*c + 128 + shiftBrightness å±•å¼€ï¼š
    const shiftTotal: number = 128.0 * (1.0 - c) + shiftBrightness

    const clamp = (v: number): number => {
      if (v < 0) {
        return 0
      }
      if (v > 255) {
        return 255
      }
      return v
    }

    // éå†ä¸€æ¬¡åƒç´ ï¼ŒçœŸæ­£æ”¹æ‰ R/G/B é€šé“
    for (let i: number = 0; i < data.length; i += 4) {
      const rIndex: number = i + rOffset
      const gIndex: number = i + gOffset
      const bIndex: number = i + bOffset
      const aIndex: number = i + aOffset

      const r = data[rIndex]
      const g = data[gIndex]
      const b = data[bIndex]

      data[rIndex] = clamp(c * r + shiftTotal)
      data[gIndex] = clamp(c * g + shiftTotal)
      data[bIndex] = clamp(c * b + shiftTotal)
      // alpha åŸæ ·ä¿æŒ
      data[aIndex] = data[aIndex]
    }

    // æŠŠä¿®æ”¹åçš„åƒç´ å†™å› pixelMap
    await pm.writeBufferToPixels(buffer)

    // æŠŠçŠ¶æ€å½’é›¶ï¼šæ­¤æ—¶åº•å±‚åƒç´ å·²ç»æ˜¯â€œæ–°äº®åº¦ + æ–°å¯¹æ¯”åº¦â€
    // å†æŠŠ colorFilter çš„å‚æ•°è®¾å› 0ï¼Œè§†è§‰æ•ˆæœä¿æŒä¸å˜ï¼ˆä¸ä¼šå åŠ ä¸¤æ¬¡ï¼‰
    this.brightnessLevel = 0.0
    this.contrastLevel = 0.0
    this.pixelVersion++ // è§¦å‘ Image é‡æ–°æ¸²æŸ“ä¸€æ¬¡
  }

  // å¯¹æ¯”åº¦è°ƒæ•´
  private async adjustContrast(delta: number) {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }

    // è®°å½•å½“å‰äº®åº¦/å¯¹æ¯”åº¦å‚æ•°ï¼ˆä¸æ‹·è´åƒç´ ï¼‰
    await this.pushHistorySnapshot(false)

    this.contrastLevel += delta

    const MAX_CONTRAST: number = 1.0 // å¯¹æ¯”åº¦å¢å¼ºä¸Šé™
    const MIN_CONTRAST: number = -1.0 // å¯¹æ¯”åº¦é™ä½ä¸‹é™

    if (this.contrastLevel > MAX_CONTRAST) {
      this.contrastLevel = MAX_CONTRAST
    }
    if (this.contrastLevel < MIN_CONTRAST) {
      this.contrastLevel = MIN_CONTRAST
    }

    let desc: string
    if (delta > 0) {
      desc = 'æé«˜äº†å¯¹æ¯”åº¦'
    } else if (delta < 0) {
      desc = 'é™ä½äº†å¯¹æ¯”åº¦'
    } else {
      desc = 'è°ƒæ•´äº†å¯¹æ¯”åº¦'
    }

    await this.logAndSyncAfterImageChange(desc)
  }

  private onClickTopMenu(menu: TopMenu) {
    // å†æ¬¡ç‚¹å‡»åŒä¸€ä¸ªæŒ‰é’®æ—¶æ”¶èµ·èœå•
    if (this.activeMenu === menu) {
      this.activeMenu = TopMenu.None
    } else {
      this.activeMenu = menu
    }
  }

  private selectShape(shape: ShapeTool) {
    this.currentShape = shape

    // å¦‚æœä¹‹å‰æ˜¯æ©¡çš®æ“¦ï¼Œåˆ‡æ¢å½¢çŠ¶æ—¶è‡ªåŠ¨æ¢å¤ä¸ºæ™®é€šç”»ç¬”
    if (this.currentBrush === BrushTool.Eraser) {
      this.currentBrush = BrushTool.Pen
    }
  }

  private selectBrush(brush: BrushTool) {
    // å…ˆåªè®°å½•å½“å‰ç”»ç¬”
    this.currentBrush = brush
  }

  private async undo() {
    console.info(`>>> UNDO CALLED, historyLen=${this.history.length}, historyIndex=${this.historyIndex}`)

    if (this.historyIndex < 0 || this.history.length === 0) {
      promptAction.showToast({ message: 'æ²¡æœ‰å¯ä»¥æ’¤é”€çš„æ“ä½œ' })
      return
    }

    const snapshot: CanvasSnapshot = this.history[this.historyIndex]
    this.historyIndex--

    // === æƒ…å†µ 1ï¼šæœ‰ pixelMap å¿«ç…§ï¼ˆå¦‚è£å‰ªï¼‰ ===
    if (snapshot.pixelMap) {
      // æŠŠ snapshot.pixelMap å…‹éš†æˆå¯ç¼–è¾‘ç‰ˆæœ¬
      const newPm = await this.clonePixelMap(snapshot.pixelMap)

      // é‡Šæ”¾å½“å‰ pixelMapï¼ˆä¸ç­‰äº snapshot.pixelMapï¼‰
      if (this.pixelMap && this.pixelMap !== snapshot.pixelMap) {
        (this.pixelMap as image.PixelMap).release?.()
      }

      // åˆ‡æ¢åˆ°æ–°çš„ editable PixelMap
      this.pixelMap = newPm
    }

    // === æƒ…å†µ 2ï¼šæ—‹è½¬ / äº®åº¦ / å¯¹æ¯”åº¦ï¼ˆæ—  pixelMapï¼‰===
    else if (this.pixelMap) {
      const currentAngle = this.accumulatedRotate
      const targetAngle = snapshot.accumulatedRotate

      const diff = (360 + targetAngle - currentAngle) % 360
      if (diff === 90 || diff === 180 || diff === 270) {
        try {
          await (this.pixelMap as image.PixelMap).rotate(diff)
        } catch (err) {
          console.error(`undo rotateBack failed: ${JSON.stringify(err)}`)
        }
      }
    }

    // â­ æ–°å¢ï¼šæ¢å¤ç»˜åˆ¶å›¾å±‚ï¼ˆdrawPixelMapï¼‰
    if (snapshot.drawPixelMap) {
      const newDraw = await this.clonePixelMap(snapshot.drawPixelMap)

      if (this.drawPixelMap && this.drawPixelMap !== snapshot.drawPixelMap) {
        this.drawPixelMap.release?.()
      }
      this.drawPixelMap = newDraw
      this.drawPixelVersion++ // è®© Image(drawPixelMap) ä¹Ÿåˆ·æ–°
    } else {
      // è¿™ä¸€æ­¥è¡¨ç¤ºå½“æ—¶æ²¡æœ‰ç»˜åˆ¶å±‚å¿«ç…§ â†’ æ’¤é”€åˆ°ä¸€ä¸ªâ€œæ²¡æœ‰ç»˜åˆ¶å±‚â€çš„çŠ¶æ€
      if (this.drawPixelMap) {
        this.drawPixelMap.release?.()
        this.drawPixelMap = undefined
        this.drawPixelVersion++
      }
    }

    // === æ¢å¤å…¶ä»–çŠ¶æ€ï¼ˆç¼©æ”¾/å¹³ç§»/äº®åº¦/å¯¹æ¯”åº¦ç­‰ï¼‰ ===
    this.zoom = snapshot.zoom
    this.offsetX = snapshot.offsetX
    this.offsetY = snapshot.offsetY
    this.brightnessLevel = snapshot.brightnessLevel
    this.contrastLevel = snapshot.contrastLevel
    this.accumulatedRotate = snapshot.accumulatedRotate

    const desc: string = 'æ’¤é”€äº†ä¸€æ­¥æ“ä½œ'
    await this.logAndSyncAfterImageChange(desc)

    this.pixelVersion++
  }

  // åœ¨ã€Œç»˜åˆ¶å›¾å±‚ã€ä¸Šç”»ä¸€ä¸ªç‚¹ï¼ˆuiX/uiY æ˜¯ç”»å¸ƒä¸Šçš„ç‚¹å‡»åæ ‡ï¼‰
  private async drawPointAtUi(uiX: number, uiY: number) {
    if (!this.pixelMap) {
      return
    }

    // âœ… ç”»ä¹‹å‰å‹ä¸€ä»½æ•´å›¾å¿«ç…§ï¼ˆè¿™é‡ŒæŒ‰ä½ ç°æœ‰é€»è¾‘æ¥ï¼‰
    await this.pushFullSnapshotBeforeChange();

    // 1. ç”»å¸ƒå°ºå¯¸é˜²å¾¡
    if (this.canvasWidth <= 0 || this.canvasHeight <= 0) {
      console.info('>>> drawPointAtUi: canvas size is 0, skip')
      return
    }

    // ===== â­â­ é€‰ç›®æ ‡å›¾å±‚ï¼šä¼˜å…ˆ drawPixelMapï¼Œæ²¡æœ‰å°±ç”¨ pixelMap =====
    let targetPm: image.PixelMap | undefined = this.drawPixelMap as image.PixelMap | undefined
    let targetIsDrawLayer: boolean = true

    if (!targetPm) {
      targetPm = this.pixelMap as image.PixelMap
      targetIsDrawLayer = false
    }

    if (!targetPm) {
      console.warn('>>> drawPointAtUi: both drawPixelMap & pixelMap are null')
      promptAction.showToast({ message: 'å½“å‰æ²¡æœ‰å¯ç¼–è¾‘å›¾å±‚ï¼Œè¯·é‡æ–°æ‰“å¼€å›¾ç‰‡' })
      return
    }

    console.info(`>>> drawPointAtUi: target layer = ${targetIsDrawLayer ? 'drawPixelMap' : 'pixelMap'}`)

    // ===== ä¸‹é¢è¿™éƒ¨åˆ†ï¼ŒåŸæ¥ç”¨ basePm / layerPm çš„åœ°æ–¹ï¼Œç»Ÿä¸€æ¢æˆ targetPm =====

    const basePm = this.pixelMap as image.PixelMap
    const baseInfo: image.ImageInfo = await basePm.getImageInfo()

    const imgW: number = baseInfo.size.width
    const imgH: number = baseInfo.size.height

    // ===== 1) UI -> åƒç´  åæ ‡æ˜ å°„ =====
    const scaleBase: number = Math.min(
      this.canvasWidth / imgW,
      this.canvasHeight / imgH
    )

    if (scaleBase <= 0) {
      console.info('>>> drawPointAtUi: scaleBase <= 0, skip')
      return
    }

    const realW: number = imgW * scaleBase * this.zoom
    const realH: number = imgH * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const pxFloat: number = (uiX - imageLeft) * (imgW / realW)
    const pyFloat: number = (uiY - imageTop) * (imgH / realH)

    const px: number = Math.floor(pxFloat)
    const py: number = Math.floor(pyFloat)

    console.info(`>>> drawPointAtUi: ui=(${uiX.toFixed(1)}, ${uiY.toFixed(1)}) -> pixel=(${px}, ${py})`)

    if (px < 0 || py < 0 || px >= imgW || py >= imgH) {
      // ç‚¹å‡»åœ¨å›¾ç‰‡å¤–é¢ï¼Œç›´æ¥ä¸¢å¼ƒ
      return
    }

    // ===== 2) åœ¨ã€Œç›®æ ‡å›¾å±‚ã€ä¸Šæ”¹åƒç´  =====
    const info: image.ImageInfo = await targetPm.getImageInfo()
    const width: number = info.size.width
    const height: number = info.size.height

    if (px < 0 || py < 0 || px >= width || py >= height) {
      console.info('>>> drawPointAtUi: pixel out of target layer range')
      return
    }

    const byteLength: number = targetPm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await targetPm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // é€šé“é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const radius: number = this.computeStrokeRadiusPixel(imgW, imgH)
    const alpha: number = this.getStrokeAlpha()

    for (let yy: number = py - radius; yy <= py + radius; yy++) {
      if (yy < 0 || yy >= height) {
        continue
      }
      for (let xx: number = px - radius; xx <= px + radius; xx++) {
        if (xx < 0 || xx >= width) {
          continue
        }

        const dx: number = xx - px
        const dy: number = yy - py
        if (dx * dx + dy * dy > radius * radius) {
          continue
        }

        const baseIndex: number = (yy * width + xx) * 4
        const rIndex: number = baseIndex + rOffset
        const gIndex: number = baseIndex + gOffset
        const bIndex: number = baseIndex + bOffset
        const aIndex: number = baseIndex + aOffset

        if (this.currentBrush === BrushTool.Eraser) {
          // â­ æ©¡çš®æ“¦ï¼šåªæ“¦æ‰ç›®æ ‡å›¾å±‚çš„ alpha
          data[aIndex] = 0
        } else {
          data[rIndex] = this.strokeR
          data[gIndex] = this.strokeG
          data[bIndex] = this.strokeB
          data[aIndex] = alpha
        }
      }
    }

    // ===== 3) å†™å› + æ¢ä¸€ä¸ªæ–°çš„ PixelMap å¼•ç”¨ï¼Œå¼ºåˆ¶ UI åˆ·æ–° =====
    await targetPm.writeBufferToPixels(buffer)

    if (targetIsDrawLayer) {
      const newLayer: image.PixelMap = await this.clonePixelMap(targetPm)
      if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
        this.drawPixelMap.release?.()
      }
      this.drawPixelMap = newLayer
      this.drawPixelVersion++
    } else {
      const newBase: image.PixelMap = await this.clonePixelMap(targetPm)
      if (this.pixelMap && this.pixelMap !== newBase) {
        (this.pixelMap as image.PixelMap).release?.()
      }
      this.pixelMap = newBase
      this.pixelVersion++
    }

    const desc: string = `ç”»äº†ä¸€ä¸ªç‚¹ åƒç´ =(${Math.floor(uiX)}, ${Math.floor(uiY)})`
    await this.logAndSyncAfterImageChange(desc)

    console.info(
      `>>> drawPointAtUi done: target=${targetIsDrawLayer ? 'draw' : 'base'}, size=${width}x${height}`
    )
  }

  // ç›´çº¿å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œåœ¨è¿™é‡Œè½¬æ¢æˆåƒç´ å¹¶ç”»çº¿
  // ç›´çº¿å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œåœ¨è¿™é‡Œè½¬æ¢æˆåƒç´ å¹¶åœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»çº¿
  private async handleLineDrag(startUiX: number, startUiY: number, endUiX: number, endUiY: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    const pm: image.PixelMap = this.pixelMap as image.PixelMap
    const info: image.ImageInfo = await pm.getImageInfo()

    // â€”â€” UI â†’ åƒç´ ï¼ˆå’Œç”»ç‚¹å®Œå…¨ä¸€è‡´çš„æ˜ å°„é€»è¾‘ï¼‰â€”â€”
    const scaleBase: number = Math.min(
      this.canvasWidth / info.size.width,
      this.canvasHeight / info.size.height
    )

    const realW: number = info.size.width * scaleBase * this.zoom
    const realH: number = info.size.height * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const startPxFloat: number = (startUiX - imageLeft) * (info.size.width / realW)
    const startPyFloat: number = (startUiY - imageTop) * (info.size.height / realH)
    const endPxFloat: number = (endUiX - imageLeft) * (info.size.width / realW)
    const endPyFloat: number = (endUiY - imageTop) * (info.size.height / realH)

    const x0: number = Math.floor(startPxFloat)
    const y0: number = Math.floor(startPyFloat)
    const x1: number = Math.floor(endPxFloat)
    const y1: number = Math.floor(endPyFloat)

    console.info(
      `>>> handleLineDrag uiStart=(${startUiX.toFixed(1)},${startUiY.toFixed(1)}), ` +
        `uiEnd=(${endUiX.toFixed(1)},${endUiY.toFixed(1)}) -> ` +
        `pixelStart=(${x0},${y0}), pixelEnd=(${x1},${y1}), imgSize=(${info.size.width},${info.size.height})`
    )

    // å°è¯•ç¡®ä¿æœ‰ç»˜åˆ¶å›¾å±‚ï¼ˆè¿™é‡Œä¸ç›´æ¥ç”¨è¿”å›å€¼ï¼Œåªåšå­˜åœ¨æ€§æ£€æŸ¥ï¼‰
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      return
    }

    // äº¤ç»™ä¸“é—¨å‡½æ•°åœ¨â€œç»˜åˆ¶å›¾å±‚â€ä¸Šç”»çº¿
    await this.drawLineBetweenPixels(x0, y0, x1, y1)

    // â­â­ åŒæ­¥åä½œ
    // â­ æ“ä½œè®°å½•ï¼šåªè®°å½• å·¦ä¸Šè§’ -> å³ä¸‹è§’ï¼ˆåƒç´ åæ ‡ï¼‰
    const left: number = Math.min(x0, x1)
    const top: number = Math.min(y0, y1)
    const right: number = Math.max(x0, x1)
    const bottom: number = Math.max(y0, y1)

    const desc: string = `ç”»äº†ä¸€æ¡ç›´çº¿ (${left}, ${top}) -> (${right}, ${bottom})`

    await this.logAndSyncAfterImageChange(desc)

    promptAction.showToast({ message: 'ç›´çº¿å·²ç»˜åˆ¶' })
  }

  // åœ¨ç»˜åˆ¶å›¾å±‚ drawPixelMap ä¸Šç”»ä¸€æ¡â€œå¸¦ç²—ç»†çš„ç›´çº¿â€
  private async drawLineBetweenPixels(x0: number, y0: number, x1: number, y1: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    // â­ å’Œç”»ç‚¹ä¸€æ ·ï¼Œå…ˆè®°å½•ä¸€æ¬¡å†å²å¿«ç…§ï¼ˆåªè®°å½•çŠ¶æ€ + ç»˜åˆ¶å±‚ï¼‰
    await this.pushFullSnapshotBeforeChange();

    // 1. ç”¨åº•å›¾åšä¸€æ¬¡å°ºå¯¸è¾¹ç•Œæ£€æŸ¥ï¼ˆæ­£å¸¸å’Œç»˜åˆ¶å±‚ä¸€è‡´ï¼‰
    const basePm: image.PixelMap = this.pixelMap as image.PixelMap
    const baseInfo: image.ImageInfo = await basePm.getImageInfo()
    const baseW: number = baseInfo.size.width
    const baseH: number = baseInfo.size.height

    if (
      x0 < 0 || y0 < 0 || x0 >= baseW || y0 >= baseH ||
        x1 < 0 || y1 < 0 || x1 >= baseW || y1 >= baseH
    ) {
      console.info('>>> drawLineBetweenPixels: endpoints out of base range, skip')
      return
    }

    // 2. åªåœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»çº¿
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      return
    }

    const info: image.ImageInfo = await layerPm.getImageInfo()
    const width: number = info.size.width
    const height: number = info.size.height

    if (
      x0 < 0 || y0 < 0 || x0 >= width || y0 >= height ||
        x1 < 0 || y1 < 0 || x1 >= width || y1 >= height
    ) {
      console.info('>>> drawLineBetweenPixels: endpoints out of layer range, skip')
      return
    }

    // 3. è¯»å–ç»˜åˆ¶å±‚åƒç´ 
    const byteLength: number = layerPm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await layerPm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // 4. é€šé“é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const radius: number = this.computeStrokeRadiusPixel(width, height)
    const alpha: number = this.getStrokeAlpha()

    const drawThickPoint = (cx: number, cy: number): void => {
      for (let yy: number = cy - radius; yy <= cy + radius; yy++) {
        if (yy < 0 || yy >= height) {
          continue
        }
        for (let xx: number = cx - radius; xx <= cx + radius; xx++) {
          if (xx < 0 || xx >= width) {
            continue
          }

          const dx: number = xx - cx
          const dy: number = yy - cy
          if (dx * dx + dy * dy > radius * radius) {
            continue
          }

          const baseIndex: number = (yy * width + xx) * 4
          const rIndex: number = baseIndex + rOffset
          const gIndex: number = baseIndex + gOffset
          const bIndex: number = baseIndex + bOffset
          const aIndex: number = baseIndex + aOffset

          if (this.currentBrush === BrushTool.Eraser) {
            // æ©¡çš®æ“¦ï¼šåªæ“¦ç»˜åˆ¶å±‚ï¼Œå˜æˆé€æ˜
            data[aIndex] = 0
          } else {
            data[rIndex] = this.strokeR
            data[gIndex] = this.strokeG
            data[bIndex] = this.strokeB
            data[aIndex] = alpha
          }
        }
      }
    }

    // 5. Bresenham ç”»çº¿
    let curX: number = x0
    let curY: number = y0
    const dx: number = Math.abs(x1 - x0)
    const sx: number = x0 < x1 ? 1 : -1
    const dy: number = -Math.abs(y1 - y0)
    const sy: number = y0 < y1 ? 1 : -1
    let err: number = dx + dy

    // eslint-disable-next-line no-constant-condition
    while (true) {
      drawThickPoint(curX, curY)

      if (curX === x1 && curY === y1) {
        break
      }

      const e2: number = 2 * err
      if (e2 >= dy) {
        err += dy
        curX += sx
      }
      if (e2 <= dx) {
        err += dx
        curY += sy
      }
    }

    // 6. å†™å›ç»˜åˆ¶å±‚åƒç´ 
    await layerPm.writeBufferToPixels(buffer)

    // â­ å…³é”®ï¼šå’Œç”»ç‚¹ä¸€æ ·ï¼Œclone ä¸€å¼ æ–°çš„å›¾å±‚ï¼Œæ¢å¼•ç”¨ï¼Œå¼ºåˆ¶ UI åˆ·æ–°
    const newLayer: image.PixelMap = await this.clonePixelMap(layerPm)

    if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
      this.drawPixelMap.release?.()
    }
    this.drawPixelMap = newLayer

    this.drawPixelVersion++ // id("draw-xxx") å˜åŒ–ï¼Œå åŠ å±‚ Image ä¼šé‡å»º

    console.info(`>>> drawLineBetweenPixels: line drawn, drawPixelVersion=${this.drawPixelVersion}`)
  }

  // çŸ©å½¢å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œåœ¨è¿™é‡Œè½¬æˆåƒç´ å¹¶ç”»çŸ©å½¢
  private async handleRectDrag(startUiX: number, startUiY: number, endUiX: number, endUiY: number) {
    if (!this.pixelMap) {
      return
    }

    const pm = this.pixelMap as image.PixelMap
    const info: image.ImageInfo = await pm.getImageInfo()

    // â€”â€” UI â†’ åƒç´ ï¼ˆå’Œç”»ç‚¹ / ç”»ç›´çº¿ä¿æŒå®Œå…¨ä¸€è‡´çš„æ˜ å°„é€»è¾‘ï¼‰â€”â€”
    const scaleBase: number = Math.min(
      this.canvasWidth / info.size.width,
      this.canvasHeight / info.size.height
    )

    const realW: number = info.size.width * scaleBase * this.zoom
    const realH: number = info.size.height * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const startPxFloat: number = (startUiX - imageLeft) * (info.size.width / realW)
    const startPyFloat: number = (startUiY - imageTop) * (info.size.height / realH)
    const endPxFloat: number = (endUiX - imageLeft) * (info.size.width / realW)
    const endPyFloat: number = (endUiY - imageTop) * (info.size.height / realH)

    const x0: number = Math.floor(startPxFloat)
    const y0: number = Math.floor(startPyFloat)
    const x1: number = Math.floor(endPxFloat)
    const y1: number = Math.floor(endPyFloat)

    console.info(
      `>>> handleRectDrag uiStart=(${startUiX.toFixed(1)},${startUiY.toFixed(1)}), ` +
        `uiEnd=(${endUiX.toFixed(1)},${endUiY.toFixed(1)}) -> ` +
        `pixelStart=(${x0},${y0}), pixelEnd=(${x1},${y1}), imgSize=(${info.size.width},${info.size.height})`
    )

    // è¿™é‡Œä¸å¼ºåˆ¶è¦æ±‚å®Œå…¨åœ¨å›¾å†…ï¼ŒçœŸæ­£çš„è¾¹ç•Œè£å‰ªäº¤ç»™ drawRectBetweenPixels å»åš

    // 1ï¼‰ä¿®æ”¹å‰å…ˆæŠŠå½“å‰æ•´å›¾å‹å…¥æ’¤é”€æ ˆï¼ˆå¯æ’¤å›ï¼‰
    // 1ï¼‰ä¿®æ”¹å‰ï¼šåªè®°å½•çŠ¶æ€ + ç»˜åˆ¶å±‚å¿«ç…§ï¼ˆåº•å›¾ä¸åŠ¨ï¼‰
    await this.pushFullSnapshotBeforeChange();

    // 2ï¼‰åœ¨ç»˜åˆ¶å±‚ä¸Šç”»çŸ©å½¢
    await this.drawRectBetweenPixels(x0, y0, x1, y1)

    // 3ï¼‰å†™æ“ä½œè®°å½•ï¼ˆå¸¦åƒç´ åæ ‡ï¼‰
    // å½’ä¸€åŒ–æˆå·¦ä¸Š / å³ä¸‹
    const left: number = Math.min(x0, x1)
    const right: number = Math.max(x0, x1)
    const top: number = Math.min(y0, y1)
    const bottom: number = Math.max(y0, y1)

    const desc: string =
      `ç”»äº†ä¸€ä¸ªçŸ©å½¢ å·¦ä¸Šåƒç´ =(${left}, ${top}), å³ä¸‹åƒç´ =(${right}, ${bottom})`

    await this.logAndSyncAfterImageChange(desc)


    promptAction.showToast({ message: 'çŸ©å½¢å·²ç»˜åˆ¶' })
  }

  // åœ¨åƒç´ åæ ‡é‡Œç”»ä¸€ä¸ªçŸ©å½¢è¾¹æ¡†ï¼ˆä½¿ç”¨å½“å‰ stroke å®½åº¦å’Œé¢œè‰²ï¼‰
  // åœ¨ç»˜åˆ¶å›¾å±‚ drawPixelMap ä¸Šç”»ä¸€ä¸ªçŸ©å½¢è¾¹æ¡†ï¼ˆä½¿ç”¨å½“å‰ stroke å®½åº¦å’Œé¢œè‰²ï¼‰
  private async drawRectBetweenPixels(x0: number, y0: number, x1: number, y1: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    // 1ï¼‰å…ˆç”¨åº•å›¾åšä¸€æ¬¡å°ºå¯¸è¾¹ç•Œæ£€æŸ¥
    const basePm: image.PixelMap = this.pixelMap as image.PixelMap
    const baseInfo: image.ImageInfo = await basePm.getImageInfo()
    const baseW: number = baseInfo.size.width
    const baseH: number = baseInfo.size.height

    // å½’ä¸€åŒ–æˆå·¦ä¸Š / å³ä¸‹
    let left: number = Math.min(x0, x1)
    let right: number = Math.max(x0, x1)
    let top: number = Math.min(y0, y1)
    let bottom: number = Math.max(y0, y1)

    // è£å‰ªåœ¨å›¾ç‰‡èŒƒå›´ä¹‹å†…ï¼ˆç”¨åº•å›¾å°ºå¯¸ï¼‰
    left = Math.max(0, left)
    right = Math.min(baseW - 1, right)
    top = Math.max(0, top)
    bottom = Math.min(baseH - 1, bottom)

    if (left >= right || top >= bottom) {
      console.info('>>> drawRectBetweenPixels: rect too small, skip')
      return
    }

    // 2ï¼‰åªåœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»çŸ©å½¢
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      return
    }

    const info: image.ImageInfo = await layerPm.getImageInfo()
    const width: number = info.size.width
    const height: number = info.size.height

    // 3ï¼‰è¯»ç»˜åˆ¶å±‚çš„åƒç´ 
    const byteLength: number = layerPm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await layerPm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // 4ï¼‰ç¡®å®šé€šé“é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const radius: number = this.computeStrokeRadiusPixel(width, height)
    const alpha: number = this.getStrokeAlpha()

    const drawThickPoint = (cx: number, cy: number): void => {
      for (let yy: number = cy - radius; yy <= cy + radius; yy++) {
        if (yy < 0 || yy >= height) {
          continue
        }
        for (let xx: number = cx - radius; xx <= cx + radius; xx++) {
          if (xx < 0 || xx >= width) {
            continue
          }

          const dx: number = xx - cx
          const dy: number = yy - cy
          if (dx * dx + dy * dy > radius * radius) {
            continue
          }

          const baseIndex: number = (yy * width + xx) * 4
          const rIndex: number = baseIndex + rOffset
          const gIndex: number = baseIndex + gOffset
          const bIndex: number = baseIndex + bOffset
          const aIndex: number = baseIndex + aOffset

          if (this.currentBrush === BrushTool.Eraser) {
            // æ©¡çš®æ“¦ï¼šåªæ“¦ç»˜åˆ¶å±‚çš„ alpha
            data[aIndex] = 0
          } else {
            data[rIndex] = this.strokeR
            data[gIndex] = this.strokeG
            data[bIndex] = this.strokeB
            data[aIndex] = alpha
          }
        }
      }
    }

    // 5ï¼‰ç”»å››æ¡è¾¹ï¼šä¸Šã€ä¸‹ã€å·¦ã€å³
    for (let x: number = left; x <= right; x++) {
      drawThickPoint(x, top) // ä¸Šè¾¹
      drawThickPoint(x, bottom) // ä¸‹è¾¹
    }
    for (let y: number = top; y <= bottom; y++) {
      drawThickPoint(left, y) // å·¦è¾¹
      drawThickPoint(right, y) // å³è¾¹
    }

    // 6ï¼‰å†™å›ç»˜åˆ¶å±‚åƒç´ 
    await layerPm.writeBufferToPixels(buffer)

    // 7ï¼‰clone ä¸€ä»½æ–°çš„ç»˜åˆ¶å±‚ï¼Œæ¢å¼•ç”¨ï¼Œå¼ºåˆ¶ UI åˆ·æ–°
    const newLayer: image.PixelMap = await this.clonePixelMap(layerPm)
    if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
      this.drawPixelMap.release?.()
    }
    this.drawPixelMap = newLayer
    this.drawPixelVersion++ // è§¦å‘ Image(drawPixelMap) é‡å»º

    console.info(`>>> drawRectBetweenPixels: rect drawn, drawPixelVersion=${this.drawPixelVersion}`)
  }

  // åœ¨åƒç´ åæ ‡é‡Œç”»ä¸€ä¸ªåœ†å½¢è¾¹æ¡†ï¼ˆä½¿ç”¨å½“å‰ stroke å®½åº¦å’Œé¢œè‰²ï¼‰
  // è¿™é‡Œä¼ å…¥çš„æ˜¯åœ†çš„å¤–æ¥æ­£æ–¹å½¢çš„å·¦ä¸Š / å³ä¸‹
  // è¿™é‡Œä¼ å…¥çš„æ˜¯åœ†çš„å¤–æ¥æ­£æ–¹å½¢çš„å·¦ä¸Š / å³ä¸‹ï¼Œåœ¨â€œç»˜åˆ¶å›¾å±‚â€ä¸Šç”»åœ†
  private async drawCircleBetweenPixels(left: number, top: number, right: number, bottom: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    // ç”¨åº•å›¾åšä¸€æ¬¡è¾¹ç•Œè£å‰ªï¼ˆå°ºå¯¸ä¸ç»˜åˆ¶å±‚ä¸€è‡´ï¼‰
    const basePm: image.PixelMap = this.pixelMap as image.PixelMap
    const baseInfo: image.ImageInfo = await basePm.getImageInfo()
    const baseW: number = baseInfo.size.width
    const baseH: number = baseInfo.size.height

    left = Math.max(0, left)
    right = Math.min(baseW - 1, right)
    top = Math.max(0, top)
    bottom = Math.min(baseH - 1, bottom)

    const w: number = right - left
    const h: number = bottom - top
    const side: number = Math.min(w, h)

    if (side <= 0) {
      console.info('>>> drawCircleBetweenPixels: side too small, skip')
      return
    }

    // ç”¨æ­£æ–¹å½¢åŒ…ä½åœ†
    right = left + side
    bottom = top + side

    const cx: number = Math.round((left + right) / 2)
    const cy: number = Math.round((top + bottom) / 2)
    const radius: number = side / 2

    // â‘¡ åœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»åœ†
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      return
    }

    const info: image.ImageInfo = await layerPm.getImageInfo()
    const width: number = info.size.width
    const height: number = info.size.height

    // 1ï¼‰è¯»ç»˜åˆ¶å±‚åƒç´ 
    const byteLength: number = layerPm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await layerPm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // 2ï¼‰é€šé“é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const strokeRadius: number = this.computeStrokeRadiusPixel(width, height)

    const alpha: number = this.getStrokeAlpha()

    const drawThickPoint = (px: number, py: number): void => {
      for (let yy: number = py - strokeRadius; yy <= py + strokeRadius; yy++) {
        if (yy < 0 || yy >= height) {
          continue
        }
        for (let xx: number = px - strokeRadius; xx <= px + strokeRadius; xx++) {
          if (xx < 0 || xx >= width) {
            continue
          }
          const dx: number = xx - px
          const dy: number = yy - py
          if (dx * dx + dy * dy > strokeRadius * strokeRadius) {
            continue
          }

          const baseIndex: number = (yy * width + xx) * 4
          const rIndex: number = baseIndex + rOffset
          const gIndex: number = baseIndex + gOffset
          const bIndex: number = baseIndex + bOffset
          const aIndex: number = baseIndex + aOffset

          if (this.currentBrush === BrushTool.Eraser) {
            // æ©¡çš®æ“¦ï¼šåªæ“¦æ‰ç»˜åˆ¶å±‚ alpha
            data[aIndex] = 0
          } else {
            data[rIndex] = this.strokeR
            data[gIndex] = this.strokeG
            data[bIndex] = this.strokeB
            data[aIndex] = alpha
          }
        }
      }
    }

    // 3ï¼‰ç”¨å‚æ•°æ–¹ç¨‹ç”»ä¸€åœˆï¼šx = cx + r cos t, y = cy + r sin t
    const TWO_PI: number = Math.PI * 2
    // æ­¥æ•°ä¸åŠå¾„æˆæ¯”ä¾‹ï¼Œä¿è¯è¶Šå¤§è¶Šå¹³æ»‘
    const steps: number = Math.max(36, Math.floor(TWO_PI * radius / 2))

    for (let i: number = 0; i < steps; i++) {
      const t: number = (TWO_PI * i) / steps
      const px: number = Math.round(cx + radius * Math.cos(t))
      const py: number = Math.round(cy + radius * Math.sin(t))

      if (px < 0 || px >= width || py < 0 || py >= height) {
        continue
      }
      drawThickPoint(px, py)
    }

    // 4ï¼‰å†™å›ç»˜åˆ¶å±‚åƒç´ 
    await layerPm.writeBufferToPixels(buffer)

    // 5ï¼‰clone ä¸€ä»½æ–°çš„ç»˜åˆ¶å±‚ï¼Œè§¦å‘ UI åˆ·æ–°
    const newLayer: image.PixelMap = await this.clonePixelMap(layerPm)
    if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
      this.drawPixelMap.release?.()
    }
    this.drawPixelMap = newLayer
    this.drawPixelVersion++ // å åŠ å±‚ Image é‡æ–°æ¸²æŸ“

    console.info(`>>> drawCircleBetweenPixels: circle drawn, drawPixelVersion=${this.drawPixelVersion}`)
  }

  // åœ†å½¢å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œè½¬æˆåƒç´ å¹¶ç”»åœ†
  // åœ†å½¢å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œè½¬æˆåƒç´ å¹¶ç”»åœ†ï¼ˆç»˜åˆ¶åœ¨ overlayï¼‰
  private async handleCircleDrag(startUiX: number, startUiY: number, endUiX: number, endUiY: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    const pm: image.PixelMap = this.pixelMap as image.PixelMap
    const info: image.ImageInfo = await pm.getImageInfo()

    // â€”â€” UI â†’ åƒç´ ï¼ˆå’Œç‚¹ / ç›´çº¿ / çŸ©å½¢ä¿æŒä¸€è‡´ï¼‰â€”â€”
    const scaleBase: number = Math.min(
      this.canvasWidth / info.size.width,
      this.canvasHeight / info.size.height
    )

    const realW: number = info.size.width * scaleBase * this.zoom
    const realH: number = info.size.height * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const startPxFloat: number = (startUiX - imageLeft) * (info.size.width / realW)
    const startPyFloat: number = (startUiY - imageTop) * (info.size.height / realH)
    const endPxFloat: number = (endUiX - imageLeft) * (info.size.width / realW)
    const endPyFloat: number = (endUiY - imageTop) * (info.size.height / realH)

    const x0: number = Math.floor(startPxFloat)
    const y0: number = Math.floor(startPyFloat)
    const x1: number = Math.floor(endPxFloat)
    const y1: number = Math.floor(endPyFloat)

    console.info(
      `>>> handleCircleDrag uiStart=(${startUiX.toFixed(1)},${startUiY.toFixed(1)}), ` +
        `uiEnd=(${endUiX.toFixed(1)},${endUiY.toFixed(1)}) -> ` +
        `pixelStart=(${x0},${y0}), pixelEnd=(${x1},${y1}), imgSize=(${info.size.width},${info.size.height})`
    )

    // 1ï¼‰å…ˆæ±‚å‡ºæ‹–å‡ºçŸ©å½¢çš„å·¦/å³/ä¸Š/ä¸‹
    let left: number = Math.min(x0, x1)
    let right: number = Math.max(x0, x1)
    let top: number = Math.min(y0, y1)
    let bottom: number = Math.max(y0, y1)

    const boxW: number = right - left
    const boxH: number = bottom - top
    const side: number = Math.min(Math.abs(boxW), Math.abs(boxH))

    if (side <= 0) {
      console.info('>>> handleCircleDrag: side too small, skip')
      return
    }

    // ç”¨å·¦ä¸Šè§’ + side æ„é€ ä¸€ä¸ªæ­£æ–¹å½¢åŒºåŸŸ
    right = left + side
    bottom = top + side

    // 2ï¼‰ä¿®æ”¹å‰å‹å…¥æ’¤é”€æ ˆï¼šåªè®°å½•çŠ¶æ€ + ç»˜åˆ¶å±‚å¿«ç…§ï¼ˆåº•å›¾ä¸åŠ¨ï¼‰
    await this.pushFullSnapshotBeforeChange();

    // 3ï¼‰çœŸæ­£ç”»åœ†ï¼ˆåœ¨ç»˜åˆ¶å›¾å±‚ä¸Šï¼‰
    await this.drawCircleBetweenPixels(left, top, right, bottom)


    // 4ï¼‰å†™æ“ä½œè®°å½•
    const desc: string =
      `ç”»äº†ä¸€ä¸ªåœ† å·¦ä¸Šåƒç´ =(${left}, ${top}), å³ä¸‹åƒç´ =(${right}, ${bottom})`

    await this.logAndSyncAfterImageChange(desc)

    promptAction.showToast({ message: 'åœ†å½¢å·²ç»˜åˆ¶' })
  }

  // æ¤­åœ†å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œè½¬æˆåƒç´ å¹¶ç”»æ¤­åœ†
  // æ¤­åœ†å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œè½¬æˆåƒç´ å¹¶åœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»æ¤­åœ†
  private async handleEllipseDrag(startUiX: number, startUiY: number, endUiX: number, endUiY: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    const pm: image.PixelMap = this.pixelMap as image.PixelMap
    const info: image.ImageInfo = await pm.getImageInfo()

    const scaleBase: number = Math.min(
      this.canvasWidth / info.size.width,
      this.canvasHeight / info.size.height
    )

    const realW: number = info.size.width * scaleBase * this.zoom
    const realH: number = info.size.height * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const startPxFloat: number = (startUiX - imageLeft) * (info.size.width / realW)
    const startPyFloat: number = (startUiY - imageTop) * (info.size.height / realH)
    const endPxFloat: number = (endUiX - imageLeft) * (info.size.width / realW)
    const endPyFloat: number = (endUiY - imageTop) * (info.size.height / realH)

    const x0: number = Math.floor(startPxFloat)
    const y0: number = Math.floor(startPyFloat)
    const x1: number = Math.floor(endPxFloat)
    const y1: number = Math.floor(endPyFloat)

    console.info(
      `>>> handleEllipseDrag uiStart=(${startUiX.toFixed(1)},${startUiY.toFixed(1)}), ` +
        `uiEnd=(${endUiX.toFixed(1)},${endUiY.toFixed(1)}) -> ` +
        `pixelStart=(${x0},${y0}), pixelEnd=(${x1},${y1}), imgSize=(${info.size.width},${info.size.height})`
    )

    let left: number = Math.min(x0, x1)
    let right: number = Math.max(x0, x1)
    let top: number = Math.min(y0, y1)
    let bottom: number = Math.max(y0, y1)

    if (right - left <= 0 || bottom - top <= 0) {
      console.info('>>> handleEllipseDrag: rect too small, skip')
      return
    }

    // 1ï¼‰ä¿®æ”¹å‰å‹å…¥æ’¤é”€æ ˆï¼šåªè®°å½•çŠ¶æ€ + ç»˜åˆ¶å±‚å¿«ç…§ï¼ˆåº•å›¾ä¸åŠ¨ï¼‰
    await this.pushFullSnapshotBeforeChange();

    // 2ï¼‰çœŸæ­£åœ¨ç»˜åˆ¶å›¾å±‚é‡Œç”»æ¤­åœ†
    await this.drawEllipseBetweenPixels(left, top, right, bottom)

    // 3ï¼‰å†™æ“ä½œè®°å½•
    const desc: string =
      `ç”»äº†ä¸€ä¸ªæ¤­åœ† å·¦ä¸Šåƒç´ =(${left}, ${top}), å³ä¸‹åƒç´ =(${right}, ${bottom})`

    await this.logAndSyncAfterImageChange(desc)

    promptAction.showToast({ message: 'æ¤­åœ†å·²ç»˜åˆ¶' })
  }

  // åœ¨åƒç´ åæ ‡é‡Œç”»ä¸€ä¸ªæ¤­åœ†è¾¹æ¡†ï¼ˆä½¿ç”¨å½“å‰ stroke å®½åº¦å’Œé¢œè‰²ï¼‰
  // ä¼ å…¥çš„æ˜¯æ¤­åœ†å¤–æ¥çŸ©å½¢å·¦ä¸Š / å³ä¸‹
  // åœ¨åƒç´ åæ ‡é‡Œç”»ä¸€ä¸ªæ¤­åœ†è¾¹æ¡†ï¼ˆä½¿ç”¨å½“å‰ stroke å®½åº¦å’Œé¢œè‰²ï¼‰
  // ä¼ å…¥çš„æ˜¯æ¤­åœ†å¤–æ¥çŸ©å½¢å·¦ä¸Š / å³ä¸‹ï¼Œå®é™…ç»˜åˆ¶åœ¨ drawPixelMap ä¸Š
  private async drawEllipseBetweenPixels(left: number, top: number, right: number, bottom: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    // å…ˆç”¨åº•å›¾åšä¸€æ¬¡è¾¹ç•Œè£å‰ªï¼ˆå°ºå¯¸ä¸ç»˜åˆ¶å±‚ä¸€è‡´ï¼‰
    const basePm: image.PixelMap = this.pixelMap as image.PixelMap
    const baseInfo: image.ImageInfo = await basePm.getImageInfo()
    const baseW: number = baseInfo.size.width
    const baseH: number = baseInfo.size.height

    left = Math.max(0, left)
    right = Math.min(baseW - 1, right)
    top = Math.max(0, top)
    bottom = Math.min(baseH - 1, bottom)

    const w: number = right - left
    const h: number = bottom - top

    if (w <= 0 || h <= 0) {
      console.info('>>> drawEllipseBetweenPixels: rect too small, skip')
      return
    }

    const cx: number = Math.round((left + right) / 2)
    const cy: number = Math.round((top + bottom) / 2)
    const rx: number = w / 2
    const ry: number = h / 2

    // â‘¡ åœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»æ¤­åœ†
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      return
    }

    const info: image.ImageInfo = await layerPm.getImageInfo()
    const width: number = info.size.width
    const height: number = info.size.height

    // 1ï¼‰è¯»ç»˜åˆ¶å±‚åƒç´ 
    const byteLength: number = layerPm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await layerPm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // 2ï¼‰é€šé“é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const thickRadius: number = this.computeStrokeRadiusPixel(width, height)
    const alpha: number = this.getStrokeAlpha()

    const drawThickPoint = (px: number, py: number): void => {
      for (let yy: number = py - thickRadius; yy <= py + thickRadius; yy++) {
        if (yy < 0 || yy >= height) {
          continue
        }
        for (let xx: number = px - thickRadius; xx <= px + thickRadius; xx++) {
          if (xx < 0 || xx >= width) {
            continue
          }
          const dx: number = xx - px
          const dy: number = yy - py
          if (dx * dx + dy * dy > thickRadius * thickRadius) {
            continue
          }

          const baseIndex: number = (yy * width + xx) * 4
          const rIndex: number = baseIndex + rOffset
          const gIndex: number = baseIndex + gOffset
          const bIndex: number = baseIndex + bOffset
          const aIndex: number = baseIndex + aOffset

          if (this.currentBrush === BrushTool.Eraser) {
            // æ©¡çš®æ“¦ï¼šåªæ“¦ç»˜åˆ¶å±‚ï¼Œè®©å®ƒé€æ˜
            data[aIndex] = 0
          } else {
            data[rIndex] = this.strokeR
            data[gIndex] = this.strokeG
            data[bIndex] = this.strokeB
            data[aIndex] = alpha
          }
        }
      }
    }

    // 3ï¼‰å‚æ•°æ–¹ç¨‹æ¤­åœ†ï¼šx = cx + rx cos t, y = cy + ry sin t
    const TWO_PI: number = Math.PI * 2
    const maxR: number = Math.max(rx, ry)
    const steps: number = Math.max(36, Math.floor(TWO_PI * maxR / 2))

    for (let i: number = 0; i < steps; i++) {
      const t: number = (TWO_PI * i) / steps
      const px: number = Math.round(cx + rx * Math.cos(t))
      const py: number = Math.round(cy + ry * Math.sin(t))

      if (px < 0 || px >= width || py < 0 || py >= height) {
        continue
      }
      drawThickPoint(px, py)
    }

    // 4ï¼‰å†™å›ç»˜åˆ¶å±‚åƒç´ 
    await layerPm.writeBufferToPixels(buffer)

    // 5ï¼‰clone ä¸€å¼ æ–°çš„ç»˜åˆ¶å±‚è§¦å‘åˆ·æ–°
    const newLayer: image.PixelMap = await this.clonePixelMap(layerPm)
    if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
      this.drawPixelMap.release?.()
    }
    this.drawPixelMap = newLayer
    this.drawPixelVersion++

    console.info(`>>> drawEllipseBetweenPixels: ellipse drawn, drawPixelVersion=${this.drawPixelVersion}`)
  }

  // åœ¨è‡ªç”±ç»˜åˆ¶æ—¶ï¼Œæ¯ä¸€å°æ®µæ‰‹åŠ¿ç§»åŠ¨ï¼Œå®æ—¶ç”»åˆ°å†…å­˜ buffer é‡Œï¼ˆåŒæ­¥ï¼‰
  private drawFreeStrokeSegmentSync(
    prevUiX: number,
    prevUiY: number,
    curUiX: number,
    curUiY: number
  ): void {
    // è¿™é‡Œè¦æ±‚ï¼šå·²ç»åœ¨æ‰‹åŠ¿å¼€å§‹çš„æ—¶å€™åˆå§‹åŒ–å¥½ freeDrawArrayBuffer / freeDrawBufferï¼Œ
    // ä¸”å®ƒæ˜¯åŸºäº â€œç»˜åˆ¶å±‚ drawPixelMapï¼ˆå¦‚æœæœ‰ï¼‰æˆ–è€…åº•å›¾ pixelMapâ€ çš„åƒç´ æ•°æ®ã€‚
    if (!this.freeDrawBuffer || !this.freeDrawArrayBuffer) {
      return
    }
    if (!this.pixelMap && !this.drawPixelMap) {
      return
    }

    // âœ… ä¼˜å…ˆä½¿ç”¨ç»˜åˆ¶å±‚çš„å°ºå¯¸ / åƒç´ æ ¼å¼
    const basePm: image.PixelMap = (this.drawPixelMap ?? this.pixelMap) as image.PixelMap
    const info: image.ImageInfo = basePm.getImageInfoSync()

    const imgW: number = info.size.width
    const imgH: number = info.size.height

    // â€”â€” UI â†’ åƒç´ æ˜ å°„ï¼Œé€»è¾‘è·Ÿä½ ä¹‹å‰å®Œå…¨ä¸€æ · â€”â€”
    const scaleBase: number = Math.min(
      this.canvasWidth / imgW,
      this.canvasHeight / imgH
    )
    const realW: number = imgW * scaleBase * this.zoom
    const realH: number = imgH * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const x0: number = Math.floor((prevUiX - imageLeft) * (imgW / realW))
    const y0: number = Math.floor((prevUiY - imageTop) * (imgH / realH))
    const x1: number = Math.floor((curUiX - imageLeft) * (imgW / realW))
    const y1: number = Math.floor((curUiY - imageTop) * (imgH / realH))

    // è¶Šç•Œç›´æ¥ä¸¢å¼ƒè¿™æ®µ
    if (
      x0 < 0 || x0 >= imgW || y0 < 0 || y0 >= imgH ||
        x1 < 0 || x1 >= imgW || y1 < 0 || y1 >= imgH
    ) {
      return
    }

    // â­ çœŸæ­£ç”»åˆ° freeDrawBufferï¼ˆåŒæ­¥ã€ä¸ awaitï¼‰
    this.drawLineIntoBuffer(
      x0,
      y0,
      x1,
      y1,
      this.freeDrawBuffer as Uint8Array,
      imgW,
      imgH,
      info.pixelFormat
    )
  }

  // åœ¨ç»™å®šçš„åƒç´ ç¼“å†²åŒºé‡Œç”»ä¸€æ¡â€œå¸¦ç²—ç»†çš„çº¿æ®µâ€ï¼ˆè‡ªç”±ç”»ä¸“ç”¨ï¼Œå®Œå…¨åŒæ­¥ï¼‰
  // x0,y0,x1,y1 æ˜¯åƒç´ åæ ‡ï¼›buffer æ˜¯æ•´å¼ å›¾çš„ BGRA/ARGB/RGBA åƒç´ æ•°æ®
  private drawLineIntoBuffer(
    x0: number,
    y0: number,
    x1: number,
    y1: number,
    buffer: Uint8Array,
    imgW: number,
    imgH: number,
    pixelFormat: image.PixelMapFormat
  ): void {
    const width: number = imgW
    const height: number = imgH

    // é€šé“åç§»
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        // B G R A
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        // A R G B
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
      // R G B A
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const radius: number = this.computeStrokeRadiusPixel(imgW, imgH)
    const alpha: number = this.getStrokeAlpha()

    const drawThickPoint = (cx: number, cy: number): void => {
      for (let yy: number = cy - radius; yy <= cy + radius; yy++) {
        if (yy < 0 || yy >= height) {
          continue
        }
        for (let xx: number = cx - radius; xx <= cx + radius; xx++) {
          if (xx < 0 || xx >= width) {
            continue
          }

          const dx: number = xx - cx
          const dy: number = yy - cy
          if (dx * dx + dy * dy > radius * radius) {
            continue
          }

          const baseIndex: number = (yy * width + xx) * 4
          const rIndex: number = baseIndex + rOffset
          const gIndex: number = baseIndex + gOffset
          const bIndex: number = baseIndex + bOffset
          const aIndex: number = baseIndex + aOffset

          if (aIndex >= buffer.length) {
            // ç†è®ºä¸Šä¸ä¼šè¶Šç•Œï¼Œä¿é™©èµ·è§
            continue
          }

          if (this.currentBrush === BrushTool.Eraser) {
            // ğŸ§½ æ©¡çš®æ“¦ï¼šåªæŠŠç»˜åˆ¶å±‚æ“¦é€æ˜
            buffer[aIndex] = 0
          } else {
            // æ™®é€šç”»ç¬” / è§å…‰ç¬”ï¼šç”¨å½“å‰ç¬”åˆ·é¢œè‰² + é€æ˜åº¦
            buffer[rIndex] = this.strokeR
            buffer[gIndex] = this.strokeG
            buffer[bIndex] = this.strokeB
            buffer[aIndex] = alpha
          }
        }
      }
    }

    // â€”â€” ä¸‹é¢ Bresenham ç”»çº¿ä¿æŒä¸å˜ â€”â€”
    let curX: number = x0
    let curY: number = y0
    const dx: number = Math.abs(x1 - x0)
    const sx: number = x0 < x1 ? 1 : -1
    const dy: number = -Math.abs(y1 - y0)
    const sy: number = y0 < y1 ? 1 : -1
    let err: number = dx + dy

    while (true) {
      drawThickPoint(curX, curY)

      if (curX === x1 && curY === y1) {
        break
      }

      const e2: number = 2 * err
      if (e2 >= dy) {
        err += dy
        curX += sx
      }
      if (e2 <= dx) {
        err += dx
        curY += sy
      }
    }
  }

  private async prepareFreeDrawBuffer() {
    if (!this.pixelMap) {
      return
    }

    // âœ… è‡ªç”±ç»˜åˆ¶åªé’ˆå¯¹ç»˜åˆ¶å±‚ï¼Œå¦‚æœè¿˜æ²¡æœ‰ç»˜åˆ¶å±‚ï¼Œå…ˆåˆ›å»ºä¸€å¼ å…¨é€æ˜çš„
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      return
    }

    this.freeBufferReady = false

    this.freeDrawByteLength = layerPm.getPixelBytesNumber()
    this.freeDrawArrayBuffer = new ArrayBuffer(this.freeDrawByteLength)

    // å¼‚æ­¥è¯»å–ç»˜åˆ¶å±‚åƒç´ ï¼ˆä¸èƒ½åœ¨æ‰‹åŠ¿é‡Œ awaitï¼‰
    layerPm.readPixelsToBuffer(this.freeDrawArrayBuffer).then(() => {
      this.freeDrawBuffer = new Uint8Array(this.freeDrawArrayBuffer as ArrayBuffer)
      this.freeBufferReady = true
    })
  }

  private async handleFreeDrawEnd(): Promise<void> {
    // åªåœ¨ FreeDraw æ¨¡å¼ä¸‹ç»“æŸè‡ªç”±ç»˜åˆ¶
    if (this.currentShape !== ShapeTool.FreeDraw || !this.pixelMap) {
      return
    }

    this.isFreeDrawing = false

    // âœ… è‡ªç”±ç»˜åˆ¶ä½œç”¨äºç»˜åˆ¶å±‚ï¼Œå¦‚æœæ²¡æœ‰åˆ™ç›´æ¥è¿”å›
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      this.freeDrawBuffer = null
      this.freeDrawArrayBuffer = null
      return
    }

    // 1) æŠŠæœ€ç»ˆçš„å†…å­˜ buffer å†™å›ç»˜åˆ¶å±‚ pixelMap
    if (this.freeDrawArrayBuffer) {
      await layerPm.writeBufferToPixels(this.freeDrawArrayBuffer)
    }

    // 2) clone ä¸€ä»½æ–°çš„ç»˜åˆ¶å±‚ â€”â€” è§¦å‘ UI åˆ·æ–°ï¼ˆä¸å…¶å®ƒå›¾å½¢ç»˜åˆ¶é€»è¾‘ä¿æŒä¸€è‡´ï¼‰
    const newLayer: image.PixelMap = await this.clonePixelMap(layerPm)

    if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
      this.drawPixelMap.release?.()
    }
    this.drawPixelMap = newLayer
    this.drawPixelVersion++ // Image(drawPixelMap) ä¼šåˆ·æ–°

    // 3) æ¸…ç©ºç¼“å­˜
    this.freeDrawBuffer = null
    this.freeDrawArrayBuffer = null

    // â­ æ–°å¢ â‘¡ï¼šå†™ä¸€æ¡æ“ä½œè®°å½• + åšåä½œåŒæ­¥
    const desc: string = 'è‡ªç”±ç”»ç¬”ï¼šå®Œæˆäº†ä¸€ç¬”è‡ªç”±ç»˜åˆ¶'
    await this.logAndSyncAfterImageChange(desc)
  }

  // æ ¹æ®å½“å‰ç”»ç¬”é€æ˜åº¦ strokeOpacityï¼ˆ0.0~1.0ï¼‰è®¡ç®—å¯¹åº”çš„ alphaï¼ˆ0~255ï¼‰
  // å½“å‰ç”»ç¬”çš„ alphaï¼ˆ0~255ï¼‰
  private getStrokeAlpha(): number {
    // ä»¥åå¦‚æœè¦åšæ©¡çš®æ“¦ = æŠ¹é€æ˜ï¼Œå¯ä»¥åœ¨è¿™é‡Œ special case
    if (this.currentBrush === BrushTool.Eraser) {
      // æš‚æ—¶å…ˆç•™ç€ 255ï¼Œä¸åšâ€œæŠ¹é€æ˜â€é€»è¾‘ï¼Œåé¢æˆ‘ä»¬å•ç‹¬å¤„ç†æ©¡çš®æ“¦
      // return 0
    }

    let a: number = Math.round(this.strokeOpacity * 255)

    if (a < 0) {
      a = 0
    } else if (a > 255) {
      a = 255
    }
    return a
  }

  // æŠŠ overlayPmï¼ˆdrawPixelMapï¼‰æŒ‰ alpha åˆæˆåˆ° basePm ä¸Šï¼ˆåªä¿®æ”¹ basePmï¼‰
  // æŠŠç»˜åˆ¶å›¾å±‚ overlayPm â€œç›–â€åˆ° basePm ä¸Šï¼š
  // åªè¦ overlay åƒç´  alpha > 0ï¼Œå°±ç›´æ¥ç”¨ overlay çš„ RGBA è¦†ç›– base å¯¹åº”åƒç´ 
  private async mergeDrawLayerIntoBase(
    basePm: image.PixelMap,
    overlayPm: image.PixelMap
  ): Promise<void> {
    const baseInfo: image.ImageInfo = await basePm.getImageInfo()
    const overInfo: image.ImageInfo = await overlayPm.getImageInfo()

    const width: number = baseInfo.size.width
    const height: number = baseInfo.size.height

    // å°ºå¯¸å¯¹ä¸ä¸Šï¼Œå…ˆå°½é‡ä¸å´©ï¼Œç›´æ¥è¿”å›ï¼ˆä¸‹é¢ç¬¬ 2 æ­¥ä¼šä¿è¯è£å‰ªæ—¶åŒæ­¥è£å‰ªç»˜åˆ¶å±‚ï¼‰
    if (overInfo.size.width !== width || overInfo.size.height !== height) {
      console.warn(
        `mergeDrawLayerIntoBase: size mismatch base=${width}x${height} over=${overInfo.size.width}x${overInfo.size.height}`
      )
      return
    }

    const baseLen: number = basePm.getPixelBytesNumber()
    const overLen: number = overlayPm.getPixelBytesNumber()

    const baseBuf: ArrayBuffer = new ArrayBuffer(baseLen)
    const overBuf: ArrayBuffer = new ArrayBuffer(overLen)

    await basePm.readPixelsToBuffer(baseBuf)
    await overlayPm.readPixelsToBuffer(overBuf)

    const baseData: Uint8Array = new Uint8Array(baseBuf)
    const overData: Uint8Array = new Uint8Array(overBuf)

    // ------- base é€šé“åç§» -------
    let brOff: number = 0
    let bgOff: number = 1
    let bbOff: number = 2
    let baOff: number = 3

    switch (baseInfo.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bbOff = 0
        bgOff = 1
        brOff = 2
        baOff = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        baOff = 0
        brOff = 1
        bgOff = 2
        bbOff = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        brOff = 0
        bgOff = 1
        bbOff = 2
        baOff = 3
        break
    }

    // ------- overlay é€šé“åç§» -------
    let orOff: number = 0
    let ogOff: number = 1
    let obOff: number = 2
    let oaOff: number = 3

    switch (overInfo.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        obOff = 0
        ogOff = 1
        orOff = 2
        oaOff = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        oaOff = 0
        orOff = 1
        ogOff = 2
        obOff = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        orOff = 0
        ogOff = 1
        obOff = 2
        oaOff = 3
        break
    }

    // ------- ç®€å•ç²—æš´ï¼šåªè¦ overlay alpha > 0ï¼Œå°±è¦†ç›– base -------
    for (let y: number = 0; y < height; y++) {
      for (let x: number = 0; x < width; x++) {
        const idx: number = (y * width + x) * 4

        const oaIdx: number = idx + oaOff
        const alphaOver: number = overData[oaIdx]

        if (alphaOver === 0) {
          // æ²¡ç”»ä¸œè¥¿/è¢«æ©¡çš®æ“¦æ“¦æ‰çš„åŒºåŸŸ â†’ ç›´æ¥è·³è¿‡
          continue
        }

        const orIdx: number = idx + orOff
        const ogIdx: number = idx + ogOff
        const obIdx: number = idx + obOff

        const brIdx: number = idx + brOff
        const bgIdx: number = idx + bgOff
        const bbIdx: number = idx + bbOff
        const baIdx: number = idx + baOff

        baseData[brIdx] = overData[orIdx]
        baseData[bgIdx] = overData[ogIdx]
        baseData[bbIdx] = overData[obIdx]
        baseData[baIdx] = alphaOver // æˆ–è€… 255ï¼Œçœ‹ä½ éœ€æ±‚ï¼Œè¿™é‡Œä¿ç•™ overlay åŸå§‹ alpha
      }
    }

    await basePm.writeBufferToPixels(baseBuf)
  }

  // ä»…ç”¨äºâ€œä¿å­˜å›¾ç‰‡â€ï¼šæŠŠå½“å‰ brightnessLevel / contrastLevel çƒ˜ç„™åˆ°ç»™å®š pmï¼Œä½†ä¸ä¿®æ”¹ this.brightnessLevel / this.contrastLevel
  private async bakeToneForSave(pm: image.PixelMap): Promise<void> {
    // å½“å‰æ²¡æœ‰è°ƒæ•´å°±ç›´æ¥ä¸å¤„ç†
    if (this.brightnessLevel === 0 && this.contrastLevel === 0) {
      return
    }

    const info: image.ImageInfo = await pm.getImageInfo()
    const byteLength: number = pm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await pm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // é€šé“é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    // å’Œä½ åŸæ¥ä¸€è‡´çš„äº®åº¦/å¯¹æ¯”åº¦è®¡ç®—
    const c: number = 1.0 + this.contrastLevel
    const shiftBrightness: number = this.brightnessLevel * 255.0
    const shiftTotal: number = 128.0 * (1.0 - c) + shiftBrightness

    const clamp = (v: number): number => {
      if (v < 0) {
        return 0
      }
      if (v > 255) {
        return 255
      }
      return v
    }

    for (let i: number = 0; i < data.length; i += 4) {
      const rIndex: number = i + rOffset
      const gIndex: number = i + gOffset
      const bIndex: number = i + bOffset
      const aIndex: number = i + aOffset

      const r = data[rIndex]
      const g = data[gIndex]
      const b = data[bIndex]

      data[rIndex] = clamp(c * r + shiftTotal)
      data[gIndex] = clamp(c * g + shiftTotal)
      data[bIndex] = clamp(c * b + shiftTotal)
      data[aIndex] = data[aIndex] // alpha ä¸å˜
    }

    await pm.writeBufferToPixels(buffer)
  }

  // æŠŠã€Œå±å¹•ç²—ç»†ã€strokeWidth æ¢ç®—æˆã€Œå›¾åƒåƒç´ åŠå¾„ã€
  // imgW / imgH æ˜¯å½“å‰å›¾ç‰‡ï¼ˆæˆ–ç»˜åˆ¶å±‚ï¼‰çš„åƒç´ å°ºå¯¸
  // æŠŠâ€œå±å¹•ä¸Šç²—ç»†â€ strokeWidth æ¢ç®—æˆâ€œå›¾åƒé‡Œçš„åƒç´ åŠå¾„â€
  // imgW / imgH æ˜¯å½“å‰å›¾åƒï¼ˆæˆ–ç»˜åˆ¶å±‚ï¼‰çš„åƒç´ å°ºå¯¸
  private computeStrokeRadiusPixel(imgW: number, imgH: number): number {
    const MIN_RADIUS: number = 1

    if (this.canvasWidth <= 0 || this.canvasHeight <= 0) {
      // å…œåº•ï¼šç”»å¸ƒå°ºå¯¸å¼‚å¸¸æ—¶ï¼Œç›´æ¥ç”¨ strokeWidth å½“åƒç´ åŠå¾„
      return Math.max(MIN_RADIUS, Math.floor(this.strokeWidth))
    }

    // å’Œ UIâ†’åƒç´ æ˜ å°„ä¿æŒåŒä¸€å¥—ç¼©æ”¾ï¼šcontain ç¼©æ”¾ * å½“å‰ç¼©æ”¾å› å­
    const scaleBase: number = Math.min(
      this.canvasWidth / imgW,
      this.canvasHeight / imgH
    )
    const realScale: number = scaleBase * this.zoom

    if (realScale <= 0) {
      return Math.max(MIN_RADIUS, Math.floor(this.strokeWidth))
    }

    // strokeWidth æ˜¯â€œå±å¹•ä¸Šçš„åŠå¾„ï¼ˆpxï¼‰â€ï¼Œé™¤ä»¥ realScale å¾—åˆ°â€œå›¾åƒåƒç´ åŠå¾„â€
    let r: number = this.strokeWidth / realScale

    if (r < MIN_RADIUS) {
      r = MIN_RADIUS
    }

    return Math.floor(r)
  }

  private ensureRemoteUser(clientId: string): void {
    // å·²ç»å­˜åœ¨å°±ä¸é‡å¤æ·»åŠ 
    const existed: OnlineUserInfo | undefined = this.onlineUsers
      .find((u: OnlineUserInfo) => u.clientId === clientId);
    if (existed) {
      return;
    }

    // ğŸ¨ å…³é”®ï¼šé¢œè‰²ç”± clientId å†³å®š
    const color: string = this.pickColorForClient(clientId);

    const remoteUser: OnlineUserInfo = {
      clientId: clientId,
      displayColor: color,
      isSelf: false
    };

    this.onlineUsers = [...this.onlineUsers, remoteUser];
  }

  // æ ¹æ® clientId ç®—ä¸€ä¸ªç¨³å®šçš„é¢œè‰²ç´¢å¼•ï¼ŒåŒä¸€ä¸ª clientId åœ¨ä»»ä½•è®¾å¤‡ä¸Šéƒ½ä¸€æ ·
  // æ ¹æ® clientId é€‰æ‹©ä¸€ä¸ªç¨³å®šçš„é¢œè‰²ï¼šåŒä¸€ä¸ª clientId â†’ åŒä¸€ä¸ªé¢œè‰²
  private pickColorForClient(clientId: string): string {
    let hash: number = 0;
    for (let i = 0; i < clientId.length; i++) {
      hash = (hash * 31 + clientId.charCodeAt(i)) >>> 0; // æ— ç¬¦å· 32bit
    }

    const paletteSize: number = this.userColorPalette.length;
    if (paletteSize === 0) {
      return '#000000'; // å…œåº•
    }

    const idx: number = hash % paletteSize;
    return this.userColorPalette[idx];
  }

  // æŠŠå½“å‰ç”»é¢åŒæ­¥ç»™å…¶ä»–åä½œç«¯ï¼ˆä¸ä¼šå½±å“æœ¬åœ°æ’¤å›æ ˆï¼‰
  private async syncCanvasToOthers(): Promise<void> {
    // æ²¡å¼€åä½œã€æ²¡è¿ä¸Šã€æ²¡å›¾ â†’ ç›´æ¥ä¸å‘
    if (!this.collabEnabled) {
      return;
    }
    if (!this.collabClient || !this.collabClient.connected) {
      console.info('[Collab] not connected, skip syncCanvasToOthers');
      return;
    }
    if (!this.pixelMap) {
      console.info('[Collab] no pixelMap, skip syncCanvasToOthers');
      return;
    }

    // âœ… ç”¨ lastOpDesc ä½œä¸ºè¿™æ¬¡åŒæ­¥çš„â€œæè¿°â€
    const desc: string = this.lastOpDesc || '';

    await this.broadcastImageToPeers(this.pixelMap as image.PixelMap, desc);
  }

  // ===== æ“ä½œè®°å½•ï¼šè¿½åŠ ä¸€æ¡æ—¥å¿— =====
  // ===== æ“ä½œè®°å½•ï¼šè¿½åŠ ä¸€æ¡æ—¥å¿— =====
  private appendOpLog(userId: string, message: string, colorOpt?: string): void {
    // 1) ä¼˜å…ˆä½¿ç”¨å¤–éƒ¨ä¼ è¿›æ¥çš„é¢œè‰²ï¼ˆæ¯”å¦‚æœ¬æœºæ“ä½œç”¨ this.localColorï¼‰
    let color: string | undefined = colorOpt;

    // 2) å¦‚æœæ²¡ä¼ é¢œè‰²ï¼Œå°è¯•ä»åœ¨çº¿ç”¨æˆ·åˆ—è¡¨é‡Œæ‰¾è¿™ä¸ªäººçš„ displayColor
    if (!color) {
      const u: OnlineUserInfo | undefined = this.onlineUsers
        .find((item: OnlineUserInfo) => item.clientId === userId);
      if (u) {
        color = u.displayColor;
      }
    }

    // 3) è¿˜æ‰¾ä¸åˆ°ï¼Œå°±å…œåº•ç”¨æœ¬åœ°çš„ pickColorForClient ä¿è¯ä¸ä¼šæ˜¯ç©º
    if (!color) {
      color = this.pickColorForClient(userId);
    }

    // ç®€å•æ—¶é—´æˆ³
    const now: Date = new Date();
    const ts: string = this.formatTime(now);

    const id: number = ++this.opSeq;
    const item: OperationLogItem = {
      id: id,
      userId: userId,
      userColor: color,
      message: message,
      timestamp: ts
    };

    // æœ€å¤šä¿ç•™ 50 æ¡ï¼Œè¶…è¿‡å°±ä»å‰é¢ä¸¢
    const maxLen: number = 50;
    const list: Array<OperationLogItem> = [...this.opLogList, item];
    if (list.length > maxLen) {
      list.shift();
    }
    this.opLogList = list;
  }

  // æ—¶é—´æ ¼å¼åŒ– HH:MM:SS
  private formatTime(d: Date): string {
    const h: string = d.getHours().toString().padStart(2, '0');
    const m: string = d.getMinutes().toString().padStart(2, '0');
    const s: string = d.getSeconds().toString().padStart(2, '0');
    return `${h}:${m}:${s}`;
  }

  // æŠŠå½“å‰ PixelMap æ‰“åŒ…æˆ PNG + base64ï¼Œé€šè¿‡ WebSocket å‘ç»™æ‰€æœ‰äºº
  // æŠŠå½“å‰ PixelMap æ‰“åŒ…æˆ PNG + base64ï¼Œé€šè¿‡ WebSocket å‘ç»™æ‰€æœ‰äºº
  // æŠŠå½“å‰ç”»é¢ï¼ˆåº•å›¾ + ç»˜åˆ¶å±‚ + äº®åº¦/å¯¹æ¯”åº¦ï¼‰æ‰“åŒ…æˆ PNG + base64ï¼Œé€šè¿‡ WebSocket å‘ç»™æ‰€æœ‰äºº
  private async broadcastImageToPeers(pm: image.PixelMap, opDesc: string): Promise<void> {
    // 1) å…‹éš†ä¸€ä»½ç”¨äºå‘é€çš„ä¸´æ—¶ä»£ç ï¼ˆä¸è¦ç›´æ¥æ”¹ this.pixelMapï¼‰
    const sendPm: image.PixelMap = await this.clonePixelMap(pm)

    try {
      // 2) å¦‚æœæœ‰ç»˜åˆ¶å±‚ï¼ŒæŠŠç»˜åˆ¶å±‚ merge åˆ° sendPm ä¸Šï¼ˆè®©è¿œç«¯ä¹Ÿçœ‹åˆ°ç”»çš„çº¿æ¡/çŸ©å½¢ç­‰ï¼‰
      if (this.drawPixelMap) {
        await this.mergeDrawLayerIntoBase(sendPm, this.drawPixelMap as image.PixelMap)
      }

      // 3) æŠŠå½“å‰äº®åº¦ / å¯¹æ¯”åº¦çƒ˜ç„™åˆ° sendPmï¼ˆåªå½±å“ sendPmï¼Œæœ¬åœ° state ä¸å˜ï¼‰
      await this.bakeToneForSave(sendPm)

      // 4) pack æˆ PNG çš„ ArrayBuffer
      const packer = image.createImagePacker()
      const packOpts: image.PackingOption = {
        format: 'image/png',
        quality: 100
      }
      const pngBuffer: ArrayBuffer = await packer.packToData(sendPm, packOpts)
      packer.release?.()

      // 5) ArrayBuffer -> base64
      const pngBase64: string = this.arrayBufferToBase64(pngBuffer)

      const senderId: string = this.localClientId || this.clientId
      const msg: CollabMessage = {
        type: 'imageSync',
        clientId: senderId,
        payload: {
          format: 'image/png',
          dataBase64: pngBase64,
          opDesc: opDesc, // ğŸ‘ˆ ä½¿ç”¨å‚æ•°é‡Œçš„æè¿°
        } as CollabImageSyncPayload
      }

      this.collabClient.send(msg)
      console.info('[Collab] broadcast image-sync, size(base64)=', pngBase64.length)
    } finally {
      // 6) é‡Šæ”¾ä¸´æ—¶ PixelMap
      sendPm.release?.()
    }
  }

  // ç»Ÿä¸€å°è£…ï¼šå›¾åƒä¿®æ”¹åï¼Œè®°å½•ä¸€æ¡æ“ä½œ + åŒæ­¥åˆ°å…¶ä»–ç«¯
  // ç»Ÿä¸€å°è£…ï¼šå›¾åƒä¿®æ”¹åï¼Œè®°å½•ä¸€æ¡æ“ä½œ + åŒæ­¥åˆ°å…¶ä»–ç«¯
  private async logAndSyncAfterImageChange(opDesc: string): Promise<void> {
    const selfId: string = this.localClientId || this.clientId
    // 1) æœ¬æœºæ“ä½œæ—¥å¿—
    this.appendOpLog(selfId, opDesc, this.localColor)

    // 2) åä½œæè¿°ï¼Œç»™å¯¹ç«¯æ˜¾ç¤ºåŒæ ·çš„æ–‡å­—
    this.lastOpDesc = opDesc

    // 3) å¦‚æœæ²¡åœ¨åä½œ / æ²¡è¿ä¸Š / æ²¡æœ‰å›¾ï¼Œå°±åªè®°æ—¥å¿—ï¼Œä¸å‘å›¾
    if (!this.collabEnabled ||
      !this.collabClient ||
      !this.collabClient.connected ||
      !this.pixelMap) {
      return
    }

    // 4) å‡†å¤‡è¦å‘é€çš„ PixelMapï¼š
    //    - é»˜è®¤æ˜¯å½“å‰ this.pixelMap
    //    - å¦‚æœæœ‰äº®åº¦/å¯¹æ¯”åº¦å‚æ•°ï¼Œå°± clone ä¸€å¼ ä¸´æ—¶å›¾ï¼Œå…ˆæŠŠäº®åº¦/å¯¹æ¯”åº¦çƒ˜ç„™è¿›å»å†å‘
    let pmForSend: image.PixelMap = this.pixelMap as image.PixelMap

    if (this.brightnessLevel !== 0 || this.contrastLevel !== 0) {
      // clone ä¸€ä»½ä¸´æ—¶å›¾
      const cloned: image.PixelMap = await this.clonePixelMap(pmForSend)
      // æŠŠå½“å‰ brightnessLevel / contrastLevel çƒ˜ç„™è¿›å»ï¼ˆä¸ä¼šä¿®æ”¹ this.brightnessLevel / this.contrastLevelï¼‰
      await this.bakeToneForSave(cloned)
      pmForSend = cloned
    }

    // 5) çœŸæ­£é€šè¿‡ WebSocket å¹¿æ’­
    await this.broadcastImageToPeers(pmForSend, opDesc)

    // 6) å¦‚æœç”¨çš„æ˜¯ä¸´æ—¶ cloneï¼Œç”¨å®Œé‡Šæ”¾æ‰
    if (pmForSend !== this.pixelMap) {
      pmForSend.release?.()
    }
  }

  // æŠŠ ArrayBuffer è½¬æˆ base64 å­—ç¬¦ä¸²
  // ArrayBuffer -> base64 å­—ç¬¦ä¸²
  // ArrayBuffer -> base64 string
  private arrayBufferToBase64(buf: ArrayBuffer): string {
    // æ˜¾å¼ç±»å‹ï¼šUint8Array
    const uint8: Uint8Array = new Uint8Array(buf)
    const base64Helper: util.Base64Helper = new util.Base64Helper()
    const base64Str: string = base64Helper.encodeToStringSync(uint8)
    return base64Str
  }

  // base64 string -> ArrayBuffer
  private base64ToArrayBuffer(b64: string): ArrayBuffer {
    const base64Helper: util.Base64Helper = new util.Base64Helper()
    // decodeSync è¿”å› Uint8Array
    const uint8: Uint8Array = base64Helper.decodeSync(b64)
    // Uint8Array è‡ªå¸¦ bufferï¼Œå°±æ˜¯ ArrayBuffer
    const buf: ArrayBuffer = uint8.buffer as ArrayBuffer
    return buf
  }

  // æŠŠè¿œç«¯å‘æ¥çš„ base64 PNG è½¬æˆ PixelMap å¹¶åº”ç”¨åˆ°æœ¬åœ°
  // â­ å»ºè®®ï¼šç›´æ¥ç”¨è¿™ä¸ªç‰ˆæœ¬è¦†ç›–ä½ ç°æœ‰çš„ applyRemoteImage
  private async applyRemoteImage(payload: CollabImageSyncPayload): Promise<void> {
    // 1. å…ˆæŠŠ payload.dataBase64 è§£æˆ PixelMapï¼ˆä½ åŸæ¥çš„é€»è¾‘ï¼‰
    const buf: ArrayBuffer = this.base64ToArrayBuffer(payload.dataBase64);
    const imgSource: image.ImageSource = image.createImageSource(buf);
    const remotePm: image.PixelMap = await imgSource.createPixelMap({
      editable: true
    });
    imgSource.release?.();

    // 2. åœ¨â€œæ¥æ”¶è¿œç«¯ç”»é¢â€ä¹‹å‰ï¼ŒæŠŠå½“å‰æ•´å¼ å›¾å‹ä¸€ä»½å¿«ç…§åˆ° history é‡Œ
    if (this.pixelMap) {
      const currentPm: image.PixelMap = this.pixelMap as image.PixelMap;
      const backupPm: image.PixelMap = await this.clonePixelMap(currentPm);
      await this.pushHistorySnapshot(true, backupPm);
    }

    // 3. é‡Šæ”¾å½“å‰åº•å›¾
    if (this.pixelMap) {
      (this.pixelMap as image.PixelMap).release?.();
    }

    // 4. æ›¿æ¢ä¸ºè¿œç«¯åº•å›¾ï¼ˆåä½œ flatten ä¹‹åçš„â€œæ€»ç”»é¢â€ï¼‰
    this.pixelMap = remotePm;

    // 5. æ›´æ–° originalPixelMapï¼ˆæ–¹ä¾¿ resetView å›åˆ°â€œåä½œåçš„åˆå§‹çŠ¶æ€â€ï¼‰
    if (this.originalPixelMap) {
      this.originalPixelMap.release?.();
    }
    this.originalPixelMap = await this.clonePixelMap(remotePm);

    // 6. â­ å…³é”®ä¿®æ”¹ï¼šåä½œå›¾åƒä¹‹åï¼Œç›´æ¥åœ¨ pixelMap ä¸Šä½œç”»ï¼Œ
    //    æ‰€ä»¥è¿™é‡ŒæŠŠ drawPixelMap æ¸…æ‰ï¼Œä¸å†æ–°å»ºé€æ˜ overlay
    if (this.drawPixelMap) {
      this.drawPixelMap.release?.();
      this.drawPixelMap = undefined;
    }
    this.drawPixelVersion++;
    console.info('[Collab] applyRemoteImage: set pixelMap from remote, clear drawPixelMap, will draw directly on pixelMap.');

    // 7. è§†å›¾å‚æ•°å¯ä»¥æŒ‰ä½ åŸæ¥é€»è¾‘å¤„ç†
    this.zoom = 1.0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.brightnessLevel = 0.0;
    this.contrastLevel = 0.0;
    this.accumulatedRotate = 0;

    this.pixelVersion++;
  }

  // â­ æ–°å¢ï¼šåœ¨ä»»ä½•ä¼šæ”¹ç”»é¢çš„æ“ä½œä¹‹å‰ï¼Œä¿å­˜â€œæ•´å¼ å›¾â€çš„å¿«ç…§
  private async pushFullSnapshotBeforeChange(): Promise<void> {
    if (!this.pixelMap) {
      return;
    }
    const currentPm: image.PixelMap = this.pixelMap as image.PixelMap;
    // ä¸€å®šè¦ cloneï¼Œä¸€å®šä¸èƒ½ç›´æ¥æŠŠ this.pixelMap ä¼ è¿›å»
    const backupPm: image.PixelMap = await this.clonePixelMap(currentPm);

    // includePixel = trueï¼ŒpmForSnapshot ç”¨æˆ‘ä»¬ clone å‡ºæ¥çš„ backupPm
    await this.pushHistorySnapshot(true, backupPm);
  }
}
