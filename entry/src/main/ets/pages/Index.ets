import { promptAction } from '@kit.ArkUI'
import { photoAccessHelper } from '@kit.MediaLibraryKit'
import { image } from '@kit.ImageKit'
import { fileIo } from '@kit.CoreFileKit'
import { common } from '@kit.AbilityKit'
import { BusinessError } from '@kit.BasicServicesKit'
import { effectKit } from '@kit.ArkGraphics2D'


// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
interface ErrorWithCode {
  code?: number | string
  message?: string
}

// æ¯ä¸€æ­¥ç”»å¸ƒçŠ¶æ€å¿«ç…§ï¼Œç”¨äºæ’¤é”€
interface CanvasSnapshot {
  pixelMap?: image.PixelMap
  zoom: number
  offsetX: number
  offsetY: number
  brightnessLevel: number
  contrastLevel: number
  accumulatedRotate: number
}


enum TopMenu {
  None,
  Image, // å›¾ç‰‡æ“ä½œ
  Shape, // å½¢çŠ¶
  Brush // ç”»ç¬”
}

enum ShapeTool {
  None,
  Point,
  Line,
  Rect,
  Circle,
  Ellipse,
  FreeDraw
}

enum BrushTool {
  None,
  Pen,
  Highlighter,
  Eraser
}


@Entry
@Component
struct Index {
  // ç”»å¸ƒçŠ¶æ€
  @State pixelMap?: image.PixelMap = undefined
  @State zoom: number = 1.0
  @State offsetX: number = 0
  @State offsetY: number = 0
  @State pixelVersion: number = 0
  // æ—‹è½¬ä¸­æ ‡å¿—ï¼Œé˜²æ­¢è¿ç‚¹å¯¼è‡´ä¸¤æ¬¡å³æ—‹
  private isRotating: boolean = false
  private accumulatedRotate: number = 0 // ä¹‹å‰æ—‹è½¬çš„æ€»åº¦æ•°
  // æ—‹è½¬ / äº®åº¦ / å¯¹æ¯”åº¦
  @State rotateDeg: number = 0 // æ—‹è½¬è§’åº¦
  @State brightnessLevel: number = 0.0 // -0.5 ~ 0.5 å·¦å³ï¼Œ0 æ˜¯åŸå›¾
  @State contrastLevel: number = 0.0 // -1.0 ~ 1.0ï¼ˆ0 æ˜¯åŸå›¾å¯¹æ¯”åº¦ï¼‰
  @State showLeftPanel: boolean = false // å·¦ä¾§å·¥å…·æ æ˜¯å¦å±•å¼€
  @State currentTool: string = '' // å½“å‰é€‰æ‹©çš„å·¥å…·ç±»å‹ï¼ˆpoint/line/rect...ï¼‰
  @State activeMenu: TopMenu = TopMenu.None // å½“å‰å±•å¼€çš„é¡¶æ èœå•
  @State currentShape: ShapeTool = ShapeTool.None
  @State currentBrush: BrushTool = BrushTool.None
  // é¡¶éƒ¨èœå•å½“å‰é€‰ä¸­çš„ä¸€çº§èœå•ï¼šimage / shape / brush / ''(ä¸æ˜¾ç¤ºäºŒçº§)
  @State currentMenu: string = 'image'
  // å½“å‰äºŒçº§èœå•ï¼ˆå½¢çŠ¶ / ç”»ç¬”æ‰ä¼šä½¿ç”¨ï¼‰
  @State currentSubTool: string = ''
  // æ‰‹åŠ¿å†…éƒ¨çŠ¶æ€
  private lastPanX: number = 0
  private lastPanY: number = 0
  private lastZoom: number = 1.0
  // è£å‰ªæ¨¡å¼ å¼€/å…³
  @State cropMode: boolean = false
  // æ‰‹åŠ¿é€‰æ‹©æ¡†ï¼ˆUI åæ ‡ï¼‰
  @State cropStartX: number = 0
  @State cropStartY: number = 0
  @State cropEndX: number = 0
  @State cropEndY: number = 0
  // ç”»å¸ƒå¤§å°ï¼ˆä¸ºäº†æŠŠ UI åæ ‡æ¯”ä¾‹æ˜ å°„æˆåƒç´ åæ ‡ï¼‰
  @State canvasWidth: number = 0
  @State canvasHeight: number = 0
  // æ’¤é”€ç”¨çš„å†å²æ ˆï¼ˆä¸éœ€è¦å“åº”å¼ï¼‰
  private history: Array<CanvasSnapshot> = []
  private historyIndex: number = -1
  private readonly historyLimit: number = 10
  // æ–°å¢ï¼šè®°å½•â€œæ‰“å¼€å›¾ç‰‡æ—¶çš„åŸå›¾å¿«ç…§â€
  private originalPixelMap?: image.PixelMap = undefined
  // âœ… å…¨å±€ç”»ç¬”æ ·å¼ï¼ˆå½¢çŠ¶ + ç”»ç¬”å…±äº«ï¼‰
  @State strokeWidth: number = 4 // åƒç´ åŠå¾„ï¼Œç»†ç¬”/ç²—ç¬”ä¸€èµ·æ”¹è¿™ä¸ª
  @State strokeR: number = 0 // é»˜è®¤é»‘è‰²
  @State strokeG: number = 0
  @State strokeB: number = 0

  build() {
    Column() {
      // é¡¶éƒ¨å·¥å…·æ 
      Column() {
        Column() {
          // é¡¶éƒ¨å·¥å…·æ 
          Column() {
            // === ä¸€çº§èœå•ï¼šå›¾ç‰‡æ“ä½œ / å½¢çŠ¶ / ç”»ç¬” / æ’¤é”€ ===
            Row({ space: 8 }) {
              // ä¸€çº§æŒ‰é’®ï¼šå›¾ç‰‡æ“ä½œ
              Button('å›¾ç‰‡æ“ä½œ', { type: ButtonType.Capsule })
                .height(32)
                .fontSize(12)
                .backgroundColor(this.currentMenu === 'image' ? '#2563EB' : '#EFF6FF')
                .fontColor(this.currentMenu === 'image' ? '#FFFFFF' : '#1D4ED8')
                .onClick(() => {
                  this.currentMenu = this.currentMenu === 'image' ? '' : 'image'
                })

              // ä¸€çº§æŒ‰é’®ï¼šå½¢çŠ¶
              Button('å½¢çŠ¶', { type: ButtonType.Capsule })
                .height(32)
                .fontSize(12)
                .backgroundColor(this.currentMenu === 'shape' ? '#2563EB' : '#EFF6FF')
                .fontColor(this.currentMenu === 'shape' ? '#FFFFFF' : '#1D4ED8')
                .onClick(() => {
                  this.currentMenu = this.currentMenu === 'shape' ? '' : 'shape'
                })

              // ä¸€çº§æŒ‰é’®ï¼šç”»ç¬”
              Button('ç”»ç¬”', { type: ButtonType.Capsule })
                .height(32)
                .fontSize(12)
                .backgroundColor(this.currentMenu === 'brush' ? '#2563EB' : '#EFF6FF')
                .fontColor(this.currentMenu === 'brush' ? '#FFFFFF' : '#1D4ED8')
                .onClick(() => {
                  this.currentMenu = this.currentMenu === 'brush' ? '' : 'brush'
                })

              // ä¸€çº§æŒ‰é’®ï¼šæ’¤é”€ï¼ˆè¿™é‡Œå…ˆå ä½ï¼Œåé¢ä½ æ¥å…¥çœŸæ­£çš„æ’¤é”€é€»è¾‘ï¼‰
              Button('æ’¤é”€', { type: ButtonType.Capsule })
                .height(32)
                .fontSize(12)
                .backgroundColor('#fff31818')
                .onClick(async () => {
                  await this.undo()
                })
            }
            .width('100%')
            .padding({
              left: 4,
              right: 4,
              top: 4,
              bottom: 4
            })
            .justifyContent(FlexAlign.Center)

            // === äºŒçº§èœå•åŒºåŸŸï¼šæ ¹æ® currentMenu å†³å®šæ˜¾ç¤ºå“ªä¸€è¡Œ ===
            if (this.currentMenu === 'image') {
              // å›¾ç‰‡æ“ä½œï¼šå¸¦æ¨ªå‘æ»šåŠ¨æ¡
              Scroll() {
                Row({ space: 8 }) {
                  Button('è£å‰ª', { type: ButtonType.Capsule })
                    .height(32)
                    .fontSize(12)
                    .backgroundColor(this.cropMode ? '#EF4444' : '#EFF6FF')
                    .fontColor(this.cropMode ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => {
                      if (!this.pixelMap) {
                        // ä¸è¿›å…¥è£å‰ªæ¨¡å¼ï¼Œä½†è°ƒç”¨ doCropï¼Œè®© doCrop è‡ªå·±å¼¹å‡º toast
                        this.doCrop()
                        return
                      }

                      this.cropMode = !this.cropMode
                      if (this.cropMode) {
                        this.cropStartX = 0
                        this.cropStartY = 0
                        this.cropEndX = 0
                        this.cropEndY = 0
                      }
                    })

                  // äºŒçº§æŒ‰é’®ç»Ÿä¸€ç”¨ Normal + æµ…ç°èƒŒæ™¯ï¼Œä¸ä¸€çº§åŒºåˆ†
                  Button('å¯¹æ¯”åº¦+', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.adjustContrast(0.1))

                  Button('å¯¹æ¯”åº¦-', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.adjustContrast(-0.1))

                  Button('å·¦æ—‹90Â°', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.rotateLeft90())

                  Button('å³æ—‹90Â°', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.rotateRight90())

                  Button('å˜äº®', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.adjustBrightness(0.05))

                  Button('å˜æš—', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.adjustBrightness(-0.05))
                }
                .height(32)
                .padding({ left: 4, right: 4 })
              }
              .scrollable(ScrollDirection.Horizontal)
              .width('100%')
              .padding({ bottom: 8 }) // äºŒçº§èœå•å’Œç”»å¸ƒä¹‹é—´ç•™ä¸€ç‚¹ç©ºéš™
            } else if (this.currentMenu === 'shape') {
              Scroll() {
                Row({ space: 8 }) {

                  Button('ç‚¹', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Point ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Point ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.currentShape = ShapeTool.Point)

                  Button('ç›´çº¿', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Line ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Line ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.currentShape = ShapeTool.Line)

                  Button('çŸ©å½¢', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Rect ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Rect ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.currentShape = ShapeTool.Rect)

                  Button('åœ†', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Circle ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Circle ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.currentShape = ShapeTool.Circle)

                  Button('æ¤­åœ†', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Ellipse ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Ellipse ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.currentShape = ShapeTool.Ellipse)

                  Button('çº¿æ¡', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.FreeDraw ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.FreeDraw ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.currentShape = ShapeTool.FreeDraw)

                }
                .height(32)
                .padding({ left: 4, right: 4 })
              }
              .scrollable(ScrollDirection.Horizontal)
              .width('100%')
              .padding({ bottom: 8 })

            } else if (this.currentMenu === 'brush') {
              Scroll() {
                Column() {

                  // ===== ç¬¬ä¸€è¡Œï¼šç²—ç»†ï¼ˆç»†ç¬”/ç²—ç¬”/è§å…‰ï¼‰ =====
                  Row({ space: 8 }) {

                    Button('ç»†ç¬”', { type: ButtonType.Normal })
                      .height(28)
                      .fontSize(11)
                      .backgroundColor(this.currentBrush === BrushTool.Pen ? '#FB923C' : '#FEF3C7')
                      .fontColor(this.currentBrush === BrushTool.Pen ? '#FFFFFF' : '#92400E')
                      .onClick(() => {
                        this.currentBrush = BrushTool.Pen
                        // âœ… å…¨å±€ç²—ç»†ï¼šå½¢çŠ¶ + ç”»ç¬”éƒ½ç”¨è¿™ä¸ª
                        this.strokeWidth = 3
                      })

                    Button('ç²—ç¬”', { type: ButtonType.Normal })
                      .height(28)
                      .fontSize(11)
                      .backgroundColor(this.currentBrush === BrushTool.Highlighter ? '#FB923C' : '#FEF3C7')
                      .fontColor(this.currentBrush === BrushTool.Highlighter ? '#FFFFFF' : '#92400E')
                      .onClick(() => {
                        this.currentBrush = BrushTool.Highlighter
                        this.strokeWidth = 7
                      })

                    Button('è§å…‰', { type: ButtonType.Normal })
                      .height(28)
                      .fontSize(11)
                      .backgroundColor(this.currentBrush === BrushTool.Eraser ? '#FB923C' : '#FEF3C7')
                      .fontColor(this.currentBrush === BrushTool.Eraser ? '#FFFFFF' : '#92400E')
                      .onClick(() => {
                        this.currentBrush = BrushTool.Eraser
                        this.strokeWidth = 10
                      })
                  }
                  .height(32)
                  .padding({ left: 4, right: 4, bottom: 4 })

                  // ===== ç¬¬äºŒè¡Œï¼šé¢œè‰²é€‰æ‹©ï¼ˆå…¨å±€é¢œè‰²ï¼Œå½¢çŠ¶ + ç”»ç¬”é€šç”¨ï¼‰ =====
                  Row({ space: 8 }) {
                    // é»‘è‰²
                    Button('', { type: ButtonType.Normal })
                      .width(24)
                      .height(24)
                      .backgroundColor('#000000')
                      .borderRadius(12)
                      .border({ width: 1, color: '#E5E7EB' })
                      .onClick(() => {
                        this.strokeR = 0
                        this.strokeG = 0
                        this.strokeB = 0
                      })

                    // çº¢è‰²
                    Button('', { type: ButtonType.Normal })
                      .width(24)
                      .height(24)
                      .backgroundColor('#EF4444')
                      .borderRadius(12)
                      .border({ width: 1, color: '#E5E7EB' })
                      .onClick(() => {
                        this.strokeR = 239
                        this.strokeG = 68
                        this.strokeB = 68
                      })

                    // ç»¿è‰²
                    Button('', { type: ButtonType.Normal })
                      .width(24)
                      .height(24)
                      .backgroundColor('#22C55E')
                      .borderRadius(12)
                      .border({ width: 1, color: '#E5E7EB' })
                      .onClick(() => {
                        this.strokeR = 34
                        this.strokeG = 197
                        this.strokeB = 94
                      })

                    // è“è‰²
                    Button('', { type: ButtonType.Normal })
                      .width(24)
                      .height(24)
                      .backgroundColor('#3B82F6')
                      .borderRadius(12)
                      .border({ width: 1, color: '#E5E7EB' })
                      .onClick(() => {
                        this.strokeR = 59
                        this.strokeG = 130
                        this.strokeB = 246
                      })
                  }
                  .height(32)
                  .padding({ left: 4, right: 4 })
                }
              }
              .scrollable(ScrollDirection.Horizontal)
              .width('100%')
              .padding({ bottom: 8 })
            }
          }

          // ç”»å¸ƒ
          Stack() {
            if (!this.pixelMap) {
              Column() {
                Text('ç‚¹å‡»â€œæ‰“å¼€å›¾ç‰‡â€å¼€å§‹ç¼–è¾‘')
                  .fontSize(14)
                  .fontColor('#9AA1A8')
                  .letterSpacing(0.5)
              }
              .width('100%').height('100%')
              .justifyContent(FlexAlign.Center)
              .alignItems(HorizontalAlign.Center)
            } else {

              // ==========================
              // 1. å›¾ç‰‡æ˜¾ç¤ºå±‚
              // ==========================
              Image(this.pixelMap)
                .id(`img-${this.pixelVersion}`)
                .objectFit(ImageFit.Contain)
                .width('100%')
                .height('100%')
                .scale({ x: this.zoom, y: this.zoom })
                .translate({ x: this.offsetX, y: this.offsetY })
                .colorFilter(this.buildToneMatrix())


              // ==========================
              // 2. æ‹–æ‹½ & ç¼©æ”¾æ‰‹åŠ¿å±‚ï¼ˆä¸æ˜¯è£å‰ªæ—¶ç”Ÿæ•ˆï¼‰
              // ==========================
              if (!this.cropMode) {
                Stack()
                  .width('100%')
                  .height('100%')
                  .backgroundColor(Color.Transparent)
                  .hitTestBehavior(HitTestMode.Transparent)
                  .gesture(
                    GestureGroup(GestureMode.Parallel,
                      // ğŸŸ¢ æ–°å¢ï¼šç‚¹å‡»æ‰‹åŠ¿ï¼Œç”¨æ¥ç”»ç‚¹
                      TapGesture()
                        .onAction((ev: GestureEvent) => {
                          // åªæœ‰åœ¨é€‰ä¸­äº†â€œç‚¹â€å·¥å…·ï¼Œä¸”ä¸æ˜¯è£å‰ªæ¨¡å¼æ—¶æ‰å¤„ç†
                          if (this.currentShape !== ShapeTool.Point || this.cropMode) {
                            return
                          }

                          if (!ev.fingerList || ev.fingerList.length === 0) {
                            return
                          }

                          const finger = ev.fingerList[0]
                          const x: number = finger.localX
                          const y: number = finger.localY

                          console.info(`>>> tap at x=${x}, y=${y}`)
                          this.drawPointAtUi(x, y)
                        }),

                      // åŸæ¥çš„æ‹–æ‹½
                      PanGesture({ direction: PanDirection.All })
                        .onActionStart(e => {
                          this.lastPanX = this.offsetX
                          this.lastPanY = this.offsetY
                        })
                        .onActionUpdate(e => {
                          this.offsetX = this.lastPanX + e.offsetX
                          this.offsetY = this.lastPanY + e.offsetY
                        }),

                      // åŸæ¥çš„ç¼©æ”¾
                      PinchGesture()
                        .onActionStart(e => {
                          this.lastZoom = this.zoom
                        })
                        .onActionUpdate(e => {
                          let next = this.lastZoom * e.scale
                          this.zoom = Math.min(5, Math.max(0.3, next))
                        })
                    )
                  )
              }


              // === è£å‰ªæ¨¡å¼ ===
              if (this.cropMode) {
                // æ‰‹åŠ¿ï¼šæ‹–å‡ºè£å‰ªæ¡†
                Stack()
                  .width('100%')
                  .height('100%')
                  .backgroundColor(Color.Transparent)
                  .gesture(
                    PanGesture({ direction: PanDirection.All })
                      .onActionStart(ev => {
                        const f = ev.fingerList[0]
                        this.cropStartX = f.localX
                        this.cropStartY = f.localY
                        this.cropEndX = f.localX
                        this.cropEndY = f.localY
                      })
                      .onActionUpdate(ev => {
                        const f = ev.fingerList[0]
                        this.cropEndX = f.localX
                        this.cropEndY = f.localY
                      })
                      .onActionEnd(() => {
                        this.doCrop()
                      })
                  )

                // ç”»è£å‰ªæ¡†ï¼ˆUIï¼‰
                Rect()
                  .position({
                    x: Math.min(this.cropStartX, this.cropEndX),
                    y: Math.min(this.cropStartY, this.cropEndY)
                  })
                  .width(Math.abs(this.cropEndX - this.cropStartX))
                  .height(Math.abs(this.cropEndY - this.cropStartY))
                  .stroke(Color.Red)
                  .strokeWidth(2)
                  .fill('rgba(255,0,0,0.18)')
              }

            }
          }
          .width('100%')
          .layoutWeight(1)
          .backgroundColor('#FFFFFF')
          .borderRadius(12)
          .padding(2)
          .clip(true)
          .onAreaChange((oldArea, newArea) => {
            this.canvasWidth = Number(newArea.width)
            this.canvasHeight = Number(newArea.height)
          })


          // åº•éƒ¨å·¥å…·æ 
          Row({ space: 10 }) {
            Text('é¸¿ç»˜')
              .fontSize(16)
              .fontWeight(FontWeight.Medium)
              .fontColor('#6B7280')
              .layoutWeight(1)

            Button('æ‰“å¼€å›¾ç‰‡', { type: ButtonType.Capsule })
              .height(40).padding({ left: 14, right: 14 })
              .onClick(() => this.pickImage())

            SaveButton({
              icon: SaveIconStyle.FULL_FILLED,
              text: SaveDescription.SAVE_IMAGE,
              buttonType: ButtonType.Capsule
            })
              .height(40)
              .padding({ left: 14, right: 14 })
              .onClick(async (event, result: SaveButtonOnClickResult) => {
                if (result === SaveButtonOnClickResult.SUCCESS) {
                  // ç”¨æˆ·ç‚¹äº†ä¿å­˜æŒ‰é’®ï¼Œç³»ç»Ÿä¸´æ—¶æˆäºˆç›¸å†Œå†™å…¥æƒé™ï¼ˆçº¦ 5 ç§’ï¼‰
                  await this.saveImage()
                } else {
                  promptAction.showToast({ message: 'æˆæƒå¤±è´¥ï¼Œæ— æ³•ä¿å­˜' })
                }
              })

            Button('é‡ç½®', { type: ButtonType.Capsule })
              .height(40)
              .padding({ left: 14, right: 14 })
              .backgroundColor('#EEF2FF')
              .fontColor('#3B82F6')
              .onClick(() => this.resetView())
          }
          .width('100%')
          .padding({
            left: 12,
            right: 12,
            top: 10,
            bottom: 10
          })
          .backgroundColor('#F7F8FA')
          .border({ width: { top: 0.5 }, color: '#E5E7EB' })
          .alignItems(VerticalAlign.Center)

        }
        .width('100%').height('100%')
        .backgroundColor('#FFFFFF')
        .padding(12)
      }
    }
  }

  // é¸¿è’™ 6.0 å®˜æ–¹å¯ç”¨ã€ä¸å˜è‰²çš„å…‹éš†ï¼špack â†’ decode
  private async clonePixelMap(pm: image.PixelMap): Promise<image.PixelMap> {
    // 1. pack æˆ PNG å†…å­˜æµï¼ˆæ³¨æ„ï¼špackToData åªæœ‰ä¸¤ä¸ªå‚æ•°ï¼‰
    const packer = image.createImagePacker()
    const packOpts: image.PackingOption = {
      format: 'image/png', // PNG æ— æŸï¼Œé¢œè‰²æœ€å®‰å…¨
      quality: 100
    }

    // HarmonyOS 6.0ï¼špackToData è¿”å› Promise<ArrayBuffer>
    const buffer: ArrayBuffer = await packer.packToData(pm, packOpts)
    packer.release?.()

    // 2. å† decode æˆæ–°çš„ PixelMapï¼ˆä¿æŒ editableï¼‰
    const imgSource = image.createImageSource(buffer)
    const clonePm: image.PixelMap = await imgSource.createPixelMap({
      editable: true
    })
    imgSource.release?.()

    return clonePm
  }

  // åœ¨ä¸€æ¬¡â€œä¼šæ”¹å˜å›¾åƒ/çŠ¶æ€â€çš„æ“ä½œä¹‹å‰è°ƒç”¨ï¼Œè®°å½•å¿«ç…§
  // includePixel = trueï¼šæŠŠ pmForSnapshot è¿™å¼ å›¾ä½œä¸ºå¿«ç…§ä¿å­˜ï¼ˆä¸æ‹·è´åƒç´ ï¼‰â€”â€”ä¸“é—¨ç»™è£å‰ªç”¨
  private async pushHistorySnapshot(includePixel: boolean, pmForSnapshot?: image.PixelMap): Promise<void> {
    let snapshotPixel: image.PixelMap | undefined = undefined

    // æ˜¯å¦åŒ…å«åƒç´ å¿«ç…§
    if (includePixel && pmForSnapshot) {
      snapshotPixel = pmForSnapshot
    }

    // å¦‚æœå·²ç»æ’¤é”€åˆ°ä¸­é—´ï¼Œå†åšæ–°æ“ä½œï¼Œåˆ™ç æ‰â€œæœªæ¥â€åˆ†æ”¯
    if (this.historyIndex >= 0 && this.historyIndex < this.history.length - 1) {
      for (let i = this.historyIndex + 1; i < this.history.length; i++) {
        this.history[i].pixelMap?.release?.()
      }
      this.history = this.history.slice(0, this.historyIndex + 1)
    }

    // ç›´æ¥ pushï¼Œä¸åšä»»ä½•ä¸Šé™é™åˆ¶
    this.history.push({
      pixelMap: snapshotPixel,
      zoom: this.zoom,
      offsetX: this.offsetX,
      offsetY: this.offsetY,
      brightnessLevel: this.brightnessLevel,
      contrastLevel: this.contrastLevel,
      accumulatedRotate: this.accumulatedRotate
    })

    // æ°¸è¿œæŒ‡å‘æœ€æ–°
    this.historyIndex = this.history.length - 1
  }

  // é‡ç½®åˆ°â€œåˆšæ‰“å¼€å›¾ç‰‡æ—¶â€çš„çŠ¶æ€
  private async resetView() {
    // æ²¡æœ‰å›¾ï¼Œç›´æ¥è¿”å›
    if (!this.pixelMap) {
      return
    }

    // æ²¡æœ‰åŸå›¾å¿«ç…§ï¼šè¯´æ˜æ˜¯è€æ•°æ®æˆ–å¼‚å¸¸æƒ…å†µï¼Œåªé‡ç½®è§†å›¾å‚æ•°
    if (!this.originalPixelMap) {
      this.zoom = 1.0
      this.offsetX = 0
      this.offsetY = 0
      this.brightnessLevel = 0.0
      this.contrastLevel = 0.0
      this.accumulatedRotate = 0
      this.pixelVersion++
      return
    }

    // â‘  æŠŠå½“å‰çŠ¶æ€æ”¾è¿›å†å²æ ˆï¼Œreset ä¹Ÿå¯ä»¥è¢«â€œæ’¤é”€â€
    const beforeResetPm = await this.clonePixelMap(this.pixelMap as image.PixelMap)
    await this.pushHistorySnapshot(true, beforeResetPm)

    // â‘¡ ç”¨ originalPixelMap è¿˜åŸåƒç´ ï¼ˆé‡æ–° clone ä¸€ä»½å¯ç¼–è¾‘ç‰ˆæœ¬ï¼‰
    const newPm = await this.clonePixelMap(this.originalPixelMap as image.PixelMap)

    // é‡Šæ”¾å½“å‰æ­£åœ¨ä½¿ç”¨çš„ PixelMap
    ;
    (this.pixelMap as image.PixelMap).release?.()

    // æ¢æˆâ€œåˆšæ‰“å¼€æ—¶â€çš„å›¾
    this.pixelMap = newPm

    // â‘¢ è¿˜åŸè§†å›¾å‚æ•°
    this.zoom = 1.0
    this.offsetX = 0
    this.offsetY = 0
    this.brightnessLevel = 0.0
    this.contrastLevel = 0.0
    this.accumulatedRotate = 0

    // â‘£ é€šçŸ¥ UI åˆ·æ–°
    this.pixelVersion++
  }

  // æ‰“å¼€å›¾ç‰‡ï¼ˆ
  private async pickImage() {
    try {
      // é€‰å›¾
      const picker = new photoAccessHelper.PhotoViewPicker()
      const options = new photoAccessHelper.PhotoSelectOptions()
      // åªé€‰æ‹©å›¾ç‰‡
      options.MIMEType = photoAccessHelper.PhotoViewMIMETypes.IMAGE_TYPE
      // ä¸€æ¬¡æœ€å¤šé€‰ä¸€å¼ 
      options.maxSelectNumber = 1

      // ç­‰å¾…ç”¨æˆ·é€‰æ‹©å›¾ç‰‡å¹¶æ‹¿å»ç»“æœ
      const result = await picker.select(options)
      const uris: Array<string> = result.photoUris

      // ç”¨æˆ·æœªé€‰æ‹©å›¾ç‰‡æç¤º
      if (!uris || uris.length === 0) {
        promptAction.showToast({ message: 'æœªé€‰æ‹©å›¾ç‰‡' })
        return
      }

      // å¾—åˆ°å›¾ç‰‡åœ°å€
      const uri: string = uris[0]
      console.info(`>>> Selected URI = ${uri}`)

      // ç”¨ fileIo æ‰“å¼€ uriï¼Œæ‹¿ fd
      const file = await fileIo.open(uri, fileIo.OpenMode.READ_ONLY)

      // æŠŠ fd äº¤ç»™ ImageKit è§£ç  â†’ å¾—åˆ° ImageSource
      const imgSource: image.ImageSource = image.createImageSource(file.fd)
      if (!imgSource) {
        await fileIo.close(file)
        throw new Error('createImageSource è¿”å›ç©º')
      }

      // ä» ImageSource åˆ›å»º PixelMap
      const pm: image.PixelMap = await imgSource.createPixelMap({
        editable: true
      })

      // é‡Šæ”¾åº•å±‚èµ„æº
      imgSource.release?.()
      await fileIo.close(file)

      // æ›´æ–° UI çŠ¶æ€
      // å…ˆé‡Šæ”¾æ—§çš„åŸå›¾å¿«ç…§
      if (this.originalPixelMap) {
        this.originalPixelMap.release?.()
      }
      // ä¿å­˜ä¸€ä»½â€œæ‰“å¼€æ—¶çš„åŸå›¾â€ï¼ˆä»¥å resetView å°±ç”¨å®ƒæ¥è¿˜åŸï¼‰
      this.originalPixelMap = await this.clonePixelMap(pm)

      // é‡Šæ”¾æ—§çš„å½“å‰å›¾
      if (this.pixelMap) {
        this.pixelMap.release?.()
      }
      // å½“å‰æ­£åœ¨ç¼–è¾‘çš„ PixelMap
      this.pixelMap = pm

      // åˆå§‹åŒ–è§†å›¾åˆ°â€œåˆšæ‰“å¼€â€çš„çŠ¶æ€
      this.zoom = 1.0
      this.offsetX = 0
      this.offsetY = 0
      this.brightnessLevel = 0.0
      this.contrastLevel = 0.0
      this.accumulatedRotate = 0
      this.pixelVersion++

      promptAction.showToast({ message: 'å›¾ç‰‡å·²åŠ è½½ ' })
    } catch (err) {
      let code = 'NA'
      let message = 'unknown'

      if (typeof err === 'object' && err !== null) {
        const e = err as ErrorWithCode

        if (e.code !== undefined) {
          code = String(e.code)
        }
        if (e.message !== undefined) {
          message = String(e.message)
        }
      } else {
        message = String(err)
      }

      const msg = `code=${code} msg=${message}`
      console.error(`[pickImage] failed: ${msg}`)
      promptAction.showToast({ message: `æ‰“å¼€å¤±è´¥ï¼š${msg}` })
    }
  }

  // ä¿å­˜å›¾ç‰‡ï¼šæŠŠå½“å‰ PixelMap å†™å…¥ç³»ç»Ÿç›¸å†Œ
  private async saveImage() {
    try {
      if (!this.pixelMap) {
        promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
        return
      }

      const context = getContext(this) as common.UIAbilityContext
      const helper = photoAccessHelper.getPhotoAccessHelper(context)

      // ä¿å­˜å‰æŠŠäº®åº¦çœŸæ­£å†™è¿›åƒç´ 
      const pm: image.PixelMap = this.pixelMap as image.PixelMap
      await this.bakeToneToPixelMap(pm)

      // ä¸‹é¢ä¿æŒåŸæ¥çš„ä¿å­˜é€»è¾‘ä¸å˜ï¼Œç”¨ pm ä¿å­˜
      const uri: string = await helper.createAsset(
        photoAccessHelper.PhotoType.IMAGE,
        'jpg'
      )

      const file = await fileIo.open(
        uri,
        fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE
      )

      const packer = image.createImagePacker()
      const packOpts: image.PackingOption = {
        format: 'image/jpeg',
        quality: 90
      }

      await new Promise<void>((resolve, reject) => {
        packer.packToFile(
          pm, // â† ç”¨å·²ç»çƒ˜ç„™äº®åº¦åçš„ pixelMap
          file.fd,
          packOpts,
          (err: BusinessError) => err ? reject(err) : resolve()
        )
      })

      packer.release?.()
      await fileIo.close(file)

      promptAction.showToast({ message: 'å·²ä¿å­˜åˆ°ç›¸å†Œ ' })
    } catch (err) {
      const e = err as BusinessError
      console.error(`saveImage failed, code=${e?.code}, msg=${e?.message}`)
      promptAction.showToast({ message: 'ä¿å­˜å¤±è´¥' })
    }
  }

  private async doCrop() {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }

    const pm = this.pixelMap as image.PixelMap
    const info = await pm.getImageInfo()

    // æ±‚å®é™…æ˜¾ç¤ºå°ºå¯¸ï¼ˆè€ƒè™‘ contain + zoomï¼‰
    const scaleBase = Math.min(
      this.canvasWidth / info.size.width,
      this.canvasHeight / info.size.height
    )

    const realW = info.size.width * scaleBase * this.zoom
    const realH = info.size.height * scaleBase * this.zoom

    // å›¾ç‰‡å·¦ä¸Šè§’ï¼ˆå— offsetX/Y å½±å“ï¼‰
    const imageLeft = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop = (this.canvasHeight - realH) / 2 + this.offsetY

    // UI è£å‰ªæ¡†ï¼ˆæœªè£è¾¹ç•Œå‰ï¼‰
    let uiX1 = Math.min(this.cropStartX, this.cropEndX)
    let uiY1 = Math.min(this.cropStartY, this.cropEndY)
    let uiX2 = Math.max(this.cropStartX, this.cropEndX)
    let uiY2 = Math.max(this.cropStartY, this.cropEndY)

    // å°†è£å‰ªæ¡†é™åˆ¶åˆ°å›¾ç‰‡æ‰€åœ¨åŒºåŸŸ
    const imgX1 = imageLeft
    const imgY1 = imageTop
    const imgX2 = imageLeft + realW
    const imgY2 = imageTop + realH

    // ä¸å›¾ç‰‡æ˜¾ç¤ºåŒºåŸŸæ±‚äº¤é›†
    uiX1 = Math.max(uiX1, imgX1)
    uiY1 = Math.max(uiY1, imgY1)
    uiX2 = Math.min(uiX2, imgX2)
    uiY2 = Math.min(uiY2, imgY2)

    // è‹¥äº¤é›†æ— æ•ˆï¼Œç›´æ¥ç»“æŸ
    if (uiX2 <= uiX1 || uiY2 <= uiY1) {
      promptAction.showToast({ message: 'è£å‰ªåŒºåŸŸè¶…å‡ºå›¾ç‰‡èŒƒå›´' })
      this.cropMode = false
      return
    }

    // æ˜ å°„åˆ°åƒç´ åæ ‡
    const px1 = (uiX1 - imageLeft) * (info.size.width / realW)
    const py1 = (uiY1 - imageTop) * (info.size.height / realH)
    const px2 = (uiX2 - imageLeft) * (info.size.width / realW)
    const py2 = (uiY2 - imageTop) * (info.size.height / realH)

    const cropX = Math.max(0, Math.floor(px1))
    const cropY = Math.max(0, Math.floor(py1))
    const cropW = Math.floor(px2 - px1)
    const cropH = Math.floor(py2 - py1)

    if (cropW <= 0 || cropH <= 0) {
      promptAction.showToast({ message: 'è£å‰ªåŒºåŸŸå¤ªå°' })
      this.cropMode = false
      return
    }

    // ========= æ ¸å¿ƒä¿®æ”¹éƒ¨åˆ†å¼€å§‹ =========

    // 1) å…ˆ clone ä¸€ä»½â€œè£å‰ªå‰çš„å®Œæ•´å›¾â€ä½œä¸ºå†å²å¿«ç…§
    const backupPm = await this.clonePixelMap(pm)
    await this.pushHistorySnapshot(true, backupPm)

    // 2) åœ¨å½“å‰ pixelMap ä¸ŠåŸåœ°è£å‰ªï¼ˆä¿æŒ this.pixelMap å¼•ç”¨ä¸å˜ï¼‰
    await pm.crop({
      x: cropX,
      y: cropY,
      size: { width: cropW, height: cropH }
    })

    // ========= æ ¸å¿ƒä¿®æ”¹éƒ¨åˆ†ç»“æŸ =========

    // å®Œæˆåå¤ä½è§†å›¾
    this.cropMode = false
    this.zoom = 1
    this.offsetX = 0
    this.offsetY = 0
    this.pixelVersion++

    // æ¸…ç©ºè£å‰ªæ¡†ï¼Œé¿å…ä¸Šæ¬¡æ®‹ç•™
    this.cropStartX = 0
    this.cropStartY = 0
    this.cropEndX = 0
    this.cropEndY = 0

    promptAction.showToast({ message: 'è£å‰ªå®Œæˆ' })
  }

  // å‘å³æ—‹è½¬ 90 åº¦ï¼ˆé¡ºæ—¶é’ˆï¼‰
  private async rotateRight90() {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }
    if (this.isRotating) {
      return
    }

    // å…ˆè®°å½•å†å²å¿«ç…§ï¼ˆä¸åŒ…å«åƒç´ ï¼‰
    await this.pushHistorySnapshot(false)

    this.isRotating = true
    try {
      await (this.pixelMap as image.PixelMap).rotate(90)

      // è¿™é‡Œè®°å½•ç´¯è®¡æ—‹è½¬
      this.accumulatedRotate = (this.accumulatedRotate + 90) % 360

      this.pixelVersion++
    } catch (err) {
      const e = err as ErrorWithCode
      console.error(`rotateRight90 failed, code=${e?.code}, msg=${e?.message}`)
      promptAction.showToast({ message: 'å³æ—‹å¤±è´¥' })
    } finally {
      this.isRotating = false
    }
  }

  // å‘å·¦æ—‹è½¬ 90 åº¦ï¼ˆé€†æ—¶é’ˆï¼‰
  private async rotateLeft90() {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }
    if (this.isRotating) {
      return
    }

    // å…ˆè®°å½•å†å²å¿«ç…§ï¼ˆä¸åŒ…å«åƒç´ ï¼‰
    await this.pushHistorySnapshot(false)

    this.isRotating = true
    try {
      // å®é™…å¯¹ PixelMap åšé¡ºæ—¶é’ˆ 270Â°ï¼ˆç­‰ä»·äºé€†æ—¶é’ˆ 90Â°ï¼‰
      await (this.pixelMap as image.PixelMap).rotate(270)

      // ç´¯è®¡è§’åº¦ä¹ŸåŠ ä¸Š 270Â°
      this.accumulatedRotate = (this.accumulatedRotate + 270) % 360

      this.pixelVersion++
    } catch (err) {
      const e = err as ErrorWithCode
      console.error(`rotateLeft90 failed, code=${e?.code}, msg=${e?.message}`)
      promptAction.showToast({ message: 'å·¦æ—‹å¤±è´¥' })
    } finally {
      this.isRotating = false
    }
  }

  // äº®åº¦è°ƒæ•´
  private async adjustBrightness(delta: number) {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }

    // è®°å½•å½“å‰äº®åº¦/å¯¹æ¯”åº¦å‚æ•°ï¼ˆä¸æ‹·è´åƒç´ ï¼‰
    await this.pushHistorySnapshot(false)

    // brightnessLevel å–ä¸€ä¸ªç›¸å¯¹æ¸©å’Œçš„åŒºé—´ï¼Œé˜²æ­¢å´©å
    this.brightnessLevel += delta

    const MAX_LEVEL: number = 0.5 // å¤§çº¦ +128
    const MIN_LEVEL: number = -0.5 // å¤§çº¦ -128

    if (this.brightnessLevel > MAX_LEVEL) {
      this.brightnessLevel = MAX_LEVEL
    }
    if (this.brightnessLevel < MIN_LEVEL) {
      this.brightnessLevel = MIN_LEVEL
    }
  }

  // æ„å»ºäº®åº¦ + å¯¹æ¯”åº¦çŸ©é˜µ
  private buildToneMatrix(): Array<number> {
    // äº®åº¦ï¼ˆå»ºè®®èŒƒå›´ [-0.5, 0.5]ï¼‰
    const b: number = this.brightnessLevel

    // å¯¹æ¯”åº¦ç³»æ•° cï¼šcontrastLevel âˆˆ [-1,1] å¯¹åº” c âˆˆ [0,2]
    const c: number = 1.0 + this.contrastLevel

    // ä¸ºäº†è®©â€œä¿æŒä¸­å¿ƒç‚¹ä¸å˜â€ï¼Œéœ€è¦é¢å¤–çš„åç§»é¡¹
    // åœ¨å½’ä¸€åŒ–[0,1]ç©ºé—´é‡Œï¼Œä¸­ç‚¹æ˜¯ 0.5ï¼š
    // new = (old - 0.5) * c + 0.5 + b
    //     = c * old + (0.5 * (1 - c) + b)
    const offset: number = 0.5 * (1.0 - c) + b

    return [
      c, 0, 0, 0, offset,
      0, c, 0, 0, offset,
      0, 0, c, 0, offset,
      0, 0, 0, 1, 0
    ]
  }

  // æŠŠå½“å‰ brightnessLevel & contrastLevel ä¸€èµ·çƒ˜ç„™åˆ° pixelMap é‡Œ
  // æ³¨æ„ï¼šè°ƒç”¨åä¼šæŠŠ brightnessLevel / contrastLevel å½’é›¶ï¼Œå¹¶è§¦å‘ä¸€æ¬¡åˆ·æ–°
  private async bakeToneToPixelMap(pm: image.PixelMap): Promise<void> {
    // æ²¡æœ‰è°ƒæ•´äº®åº¦å’Œå¯¹æ¯”åº¦å°±ä¸ç”¨åŠ¨åƒç´ ï¼Œç›´æ¥è¿”å›
    if (this.brightnessLevel === 0 && this.contrastLevel === 0) {
      return
    }

    // è¯»å‡ºåƒç´ æ•°æ®
    const info: image.ImageInfo = await pm.getImageInfo()
    const byteLength: number = pm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await pm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // åˆ¤æ–­é€šé“é¡ºåºï¼Œé˜²æ­¢é¢œè‰²é”™ä¹±
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        // B G R A
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        // A R G B
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
      // R G B A
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    // å¯¹æ¯”åº¦ç³»æ•° cï¼ˆ0~2ï¼‰ï¼Œäº®åº¦åç§» *255
    const c: number = 1.0 + this.contrastLevel
    const shiftBrightness: number = this.brightnessLevel * 255.0
    // æŠŠå…¬å¼ new = (old - 128)*c + 128 + shiftBrightness å±•å¼€ï¼š
    const shiftTotal: number = 128.0 * (1.0 - c) + shiftBrightness

    const clamp = (v: number): number => {
      if (v < 0) {
        return 0
      }
      if (v > 255) {
        return 255
      }
      return v
    }

    // éå†ä¸€æ¬¡åƒç´ ï¼ŒçœŸæ­£æ”¹æ‰ R/G/B é€šé“
    for (let i: number = 0; i < data.length; i += 4) {
      const rIndex: number = i + rOffset
      const gIndex: number = i + gOffset
      const bIndex: number = i + bOffset
      const aIndex: number = i + aOffset

      const r = data[rIndex]
      const g = data[gIndex]
      const b = data[bIndex]

      data[rIndex] = clamp(c * r + shiftTotal)
      data[gIndex] = clamp(c * g + shiftTotal)
      data[bIndex] = clamp(c * b + shiftTotal)
      // alpha åŸæ ·ä¿æŒ
      data[aIndex] = data[aIndex]
    }

    // æŠŠä¿®æ”¹åçš„åƒç´ å†™å› pixelMap
    await pm.writeBufferToPixels(buffer)

    // æŠŠçŠ¶æ€å½’é›¶ï¼šæ­¤æ—¶åº•å±‚åƒç´ å·²ç»æ˜¯â€œæ–°äº®åº¦ + æ–°å¯¹æ¯”åº¦â€
    // å†æŠŠ colorFilter çš„å‚æ•°è®¾å› 0ï¼Œè§†è§‰æ•ˆæœä¿æŒä¸å˜ï¼ˆä¸ä¼šå åŠ ä¸¤æ¬¡ï¼‰
    this.brightnessLevel = 0.0
    this.contrastLevel = 0.0
    this.pixelVersion++ // è§¦å‘ Image é‡æ–°æ¸²æŸ“ä¸€æ¬¡
  }

  // å¯¹æ¯”åº¦è°ƒæ•´
  private async adjustContrast(delta: number) {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }

    // è®°å½•å½“å‰äº®åº¦/å¯¹æ¯”åº¦å‚æ•°ï¼ˆä¸æ‹·è´åƒç´ ï¼‰
    await this.pushHistorySnapshot(false)

    this.contrastLevel += delta

    const MAX_CONTRAST: number = 1.0 // å¯¹æ¯”åº¦å¢å¼ºä¸Šé™
    const MIN_CONTRAST: number = -1.0 // å¯¹æ¯”åº¦é™ä½ä¸‹é™

    if (this.contrastLevel > MAX_CONTRAST) {
      this.contrastLevel = MAX_CONTRAST
    }
    if (this.contrastLevel < MIN_CONTRAST) {
      this.contrastLevel = MIN_CONTRAST
    }
  }

  private onClickTopMenu(menu: TopMenu) {
    // å†æ¬¡ç‚¹å‡»åŒä¸€ä¸ªæŒ‰é’®æ—¶æ”¶èµ·èœå•
    if (this.activeMenu === menu) {
      this.activeMenu = TopMenu.None
    } else {
      this.activeMenu = menu
    }
  }

  private selectShape(shape: ShapeTool) {
    // å…ˆåªè®°å½•å½“å‰å½¢çŠ¶ï¼ŒçœŸæ­£ç»˜åˆ¶é€»è¾‘ä»¥åå†åŠ 
    this.currentShape = shape
  }

  private selectBrush(brush: BrushTool) {
    // å…ˆåªè®°å½•å½“å‰ç”»ç¬”
    this.currentBrush = brush
  }

  private async undo() {
    if (this.historyIndex < 0 || this.history.length === 0) {
      promptAction.showToast({ message: 'æ²¡æœ‰å¯ä»¥æ’¤é”€çš„æ“ä½œ' })
      return
    }

    const snapshot: CanvasSnapshot = this.history[this.historyIndex]
    this.historyIndex--

    // === æƒ…å†µ 1ï¼šæœ‰ pixelMap å¿«ç…§ï¼ˆå¦‚è£å‰ªï¼‰ ===
    if (snapshot.pixelMap) {
      // æŠŠ snapshot.pixelMap å…‹éš†æˆå¯ç¼–è¾‘ç‰ˆæœ¬
      const newPm = await this.clonePixelMap(snapshot.pixelMap)

      // é‡Šæ”¾å½“å‰ pixelMapï¼ˆä¸ç­‰äº snapshot.pixelMapï¼‰
      if (this.pixelMap && this.pixelMap !== snapshot.pixelMap) {
        (this.pixelMap as image.PixelMap).release?.()
      }

      // åˆ‡æ¢åˆ°æ–°çš„ editable PixelMap
      this.pixelMap = newPm
    }

    // === æƒ…å†µ 2ï¼šæ—‹è½¬ / äº®åº¦ / å¯¹æ¯”åº¦ï¼ˆæ—  pixelMapï¼‰===
    else if (this.pixelMap) {
      const currentAngle = this.accumulatedRotate
      const targetAngle = snapshot.accumulatedRotate

      const diff = (360 + targetAngle - currentAngle) % 360
      if (diff === 90 || diff === 180 || diff === 270) {
        try {
          await (this.pixelMap as image.PixelMap).rotate(diff)
        } catch (err) {
          console.error(`undo rotateBack failed: ${JSON.stringify(err)}`)
        }
      }
    }

    // === æ¢å¤å…¶ä»–çŠ¶æ€ï¼ˆç¼©æ”¾/å¹³ç§»/äº®åº¦/å¯¹æ¯”åº¦ç­‰ï¼‰ ===
    this.zoom = snapshot.zoom
    this.offsetX = snapshot.offsetX
    this.offsetY = snapshot.offsetY
    this.brightnessLevel = snapshot.brightnessLevel
    this.contrastLevel = snapshot.contrastLevel
    this.accumulatedRotate = snapshot.accumulatedRotate

    this.pixelVersion++
  }

  // åœ¨å½“å‰ pixelMap ä¸Šç”»ä¸€ä¸ªç‚¹ï¼ˆuiX/uiY æ˜¯ç”»å¸ƒä¸Šçš„ç‚¹å‡»åæ ‡ï¼‰
  private async drawPointAtUi(uiX: number, uiY: number) {
    if (!this.pixelMap) {
      return
    }

    const pm = this.pixelMap as image.PixelMap
    const info: image.ImageInfo = await pm.getImageInfo()

    // 1ï¼‰ç®—å‡ºå½“å‰å›¾ç‰‡åœ¨ç”»å¸ƒä¸Šçš„å®é™…æ˜¾ç¤ºå°ºå¯¸ï¼ˆcontain + zoomï¼‰
    const scaleBase: number = Math.min(
      this.canvasWidth / info.size.width,
      this.canvasHeight / info.size.height
    )

    const realW: number = info.size.width * scaleBase * this.zoom
    const realH: number = info.size.height * scaleBase * this.zoom

    // å›¾ç‰‡å·¦ä¸Šè§’åœ¨ç”»å¸ƒä¸­çš„ä½ç½®ï¼ˆè€ƒè™‘å¹³ç§» offsetX/Yï¼‰
    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    // 2ï¼‰æŠŠ UI åæ ‡æ˜ å°„åˆ°åƒç´ åæ ‡
    const pxFloat: number = (uiX - imageLeft) * (info.size.width / realW)
    const pyFloat: number = (uiY - imageTop) * (info.size.height / realH)

    const px: number = Math.floor(pxFloat)
    const py: number = Math.floor(pyFloat)

    console.info(
      `>>> drawPointAtUi ui=(${uiX.toFixed(1)},${uiY.toFixed(1)}) ` +
        `-> pixel=(${px},${py}), imgSize=(${info.size.width},${info.size.height})`
    )

    // ç‚¹åœ¨å›¾ç‰‡å¤–é¢å°±ä¸ç”¨ç”»
    if (px < 0 || py < 0 || px >= info.size.width || py >= info.size.height) {
      console.info('>>> drawPointAtUi: pixel out of range, skip')
      return
    }

    // 3ï¼‰å…ˆæŠŠå½“å‰å›¾å…‹éš†ä¸€ä»½è¿›å†å²æ ˆï¼Œæ–¹ä¾¿æ’¤é”€
    const backupPm: image.PixelMap = await this.clonePixelMap(pm)
    await this.pushHistorySnapshot(true, backupPm)

    // 4ï¼‰è¯»å‡ºåƒç´ æ•°æ®
    const byteLength: number = pm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await pm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // æ‰“ä¸€è¡Œ log çœ‹çœ‹æ¯åƒç´ å­—èŠ‚æ•°
    const width: number = info.size.width
    const height: number = info.size.height
    const bpp: number = byteLength / (width * height)
    console.info(`>>> pixelFormat=${info.pixelFormat}, bytesPerPixel=${bpp}`)

    // åƒç´ æ ¼å¼åˆ¤æ–­ï¼Œç¡®å®š RGBA é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        // B G R A
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        // A R G B
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
      // R G B A
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const radius: number = this.strokeWidth > 0 ? this.strokeWidth : 4

    for (let yy: number = py - radius; yy <= py + radius; yy++) {
      if (yy < 0 || yy >= height) {
        continue
      }
      for (let xx: number = px - radius; xx <= px + radius; xx++) {
        if (xx < 0 || xx >= width) {
          continue
        }

        const dx: number = xx - px
        const dy: number = yy - py
        if (dx * dx + dy * dy > radius * radius) {
          continue
        }

        const baseIndex: number = (yy * width + xx) * 4
        const rIndex: number = baseIndex + rOffset
        const gIndex: number = baseIndex + gOffset
        const bIndex: number = baseIndex + bOffset
        const aIndex: number = baseIndex + aOffset

        data[rIndex] = this.strokeR
        data[gIndex] = this.strokeG
        data[bIndex] = this.strokeB
        data[aIndex] = 255

      }
    }

    // 5ï¼‰æŠŠä¿®æ”¹åçš„åƒç´ å†™å›åŸ pixelMap
    await pm.writeBufferToPixels(buffer)

    // 6ï¼‰ä¸ºäº†å®Œå…¨ç¡®ä¿ UI åˆ·æ–°ï¼šå† clone ä¸€ä»½æ–°çš„ PixelMap èµ‹ç»™ this.pixelMap
    const newPm: image.PixelMap = await this.clonePixelMap(pm)

    // é‡Šæ”¾æ—§çš„ this.pixelMapï¼Œé¿å…æ³„éœ²
    if (this.pixelMap && this.pixelMap !== newPm) {
      (this.pixelMap as image.PixelMap).release?.()
    }
    this.pixelMap = newPm

    // é€šçŸ¥ Image é‡æ–°æ¸²æŸ“
    this.pixelVersion++
  }
}
