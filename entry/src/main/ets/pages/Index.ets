import { promptAction } from '@kit.ArkUI'
import { photoAccessHelper } from '@kit.MediaLibraryKit'
import { image } from '@kit.ImageKit'
import { fileIo } from '@kit.CoreFileKit'
import { common } from '@kit.AbilityKit'
import { BusinessError } from '@kit.BasicServicesKit'
import util from '@ohos.util'

// entry/src/main/ets/pages/Index.ets
import { ColorWheelPicker } from './ColorPicker'
import {
  CollabClient,
  CollabMessage,
  buildClearMessage,
  CollabAssignIdPayload,
  CollabImageSyncPayload
} from '../common/net/CollabClient';

// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
interface ErrorWithCode {
  code?: number | string
  message?: string
}

// åœ¨çº¿ç”¨æˆ·ä¿¡æ¯
interface OnlineUserInfo {
  clientId: string; // ä»åä½œæ¶ˆæ¯é‡Œçš„ clientId æ‹¿
  displayColor: string; // æ¯ä¸ª client ç”¨ä¸€ä¸ªå›ºå®šé¢œè‰²
  isSelf: boolean; // æ˜¯å¦æ˜¯æœ¬æœº
}

interface CanvasSnapshot {
  pixelMap?: image.PixelMap // åº•å›¾å¿«ç…§
  drawPixelMap?: image.PixelMap // â­ æ–°å¢ï¼šç»˜åˆ¶å›¾å±‚å¿«ç…§
  zoom: number
  offsetX: number
  offsetY: number
  brightnessLevel: number
  contrastLevel: number
  accumulatedRotate: number
}


enum TopMenu {
  None,
  Image, // å›¾ç‰‡æ“ä½œ
  Shape, // å½¢çŠ¶
  Brush // ç”»ç¬”
}

enum ShapeTool {
  None,
  Point,
  Line,
  Rect,
  Circle,
  Ellipse,
  FreeDraw
}

enum BrushTool {
  None,
  Pen,
  Highlighter,
  Eraser
}


@Entry
@Component
struct Index {
  // ç”»å¸ƒçŠ¶æ€
  @State pixelMap?: image.PixelMap = undefined
  @State zoom: number = 1.0
  @State offsetX: number = 0
  @State offsetY: number = 0
  @State pixelVersion: number = 0
  // ================= æ–°å¢ï¼šç»˜åˆ¶å›¾å±‚ =================
  // ä¸“é—¨ç”¨æ¥ç”»çº¿æ¡/å½¢çŠ¶ï¼Œæ©¡çš®æ“¦åªæ“¦è¿™ä¸ªå±‚
  @State drawPixelMap?: image.PixelMap = undefined
  @State drawPixelVersion: number = 0
  // ==================================================
  // æ—‹è½¬ä¸­æ ‡å¿—ï¼Œé˜²æ­¢è¿ç‚¹å¯¼è‡´ä¸¤æ¬¡å³æ—‹
  private isRotating: boolean = false
  private accumulatedRotate: number = 0 // ä¹‹å‰æ—‹è½¬çš„æ€»åº¦æ•°
  // æ—‹è½¬ / äº®åº¦ / å¯¹æ¯”åº¦
  @State rotateDeg: number = 0 // æ—‹è½¬è§’åº¦
  @State brightnessLevel: number = 0.0 // -0.5 ~ 0.5 å·¦å³ï¼Œ0 æ˜¯åŸå›¾
  @State contrastLevel: number = 0.0 // -1.0 ~ 1.0ï¼ˆ0 æ˜¯åŸå›¾å¯¹æ¯”åº¦ï¼‰
  @State showLeftPanel: boolean = false // å·¦ä¾§å·¥å…·æ æ˜¯å¦å±•å¼€
  @State currentTool: string = '' // å½“å‰é€‰æ‹©çš„å·¥å…·ç±»å‹ï¼ˆpoint/line/rect...ï¼‰
  @State activeMenu: TopMenu = TopMenu.None // å½“å‰å±•å¼€çš„é¡¶æ èœå•
  @State currentShape: ShapeTool = ShapeTool.None
  @State currentBrush: BrushTool = BrushTool.Pen // é»˜è®¤å°±æ˜¯æ™®é€šç”»ç¬”
  // é¡¶éƒ¨èœå•å½“å‰é€‰ä¸­çš„ä¸€çº§èœå•ï¼šimage / shape / brush / ''(ä¸æ˜¾ç¤ºäºŒçº§)
  @State currentMenu: string = 'image'
  // å½“å‰äºŒçº§èœå•ï¼ˆå½¢çŠ¶ / ç”»ç¬”æ‰ä¼šä½¿ç”¨ï¼‰
  @State currentSubTool: string = ''
  // æ‰‹åŠ¿å†…éƒ¨çŠ¶æ€
  private lastPanX: number = 0
  private lastPanY: number = 0
  private lastZoom: number = 1.0
  // è£å‰ªæ¨¡å¼ å¼€/å…³
  @State cropMode: boolean = false
  // æ‰‹åŠ¿é€‰æ‹©æ¡†ï¼ˆUI åæ ‡ï¼‰
  @State cropStartX: number = 0
  @State cropStartY: number = 0
  @State cropEndX: number = 0
  @State cropEndY: number = 0
  // ç”»å¸ƒå¤§å°ï¼ˆä¸ºäº†æŠŠ UI åæ ‡æ¯”ä¾‹æ˜ å°„æˆåƒç´ åæ ‡ï¼‰
  @State canvasWidth: number = 0
  @State canvasHeight: number = 0
  // æ’¤é”€ç”¨çš„å†å²æ ˆï¼ˆä¸éœ€è¦å“åº”å¼ï¼‰
  private history: Array<CanvasSnapshot> = []
  private historyIndex: number = -1
  private readonly historyLimit: number = 10
  // æ–°å¢ï¼šè®°å½•â€œæ‰“å¼€å›¾ç‰‡æ—¶çš„åŸå›¾å¿«ç…§â€
  private originalPixelMap?: image.PixelMap = undefined
  //å…¨å±€ç”»ç¬”æ ·å¼ï¼ˆå½¢çŠ¶ + ç”»ç¬”å…±äº«ï¼‰
  @State strokeWidth: number = 4 // åƒç´ åŠå¾„ï¼Œç»†ç¬”/ç²—ç¬”ä¸€èµ·æ”¹è¿™ä¸ª
  @State strokeR: number = 0 // é»˜è®¤é»‘è‰²
  @State strokeG: number = 0
  @State strokeB: number = 0
  @State strokeOpacity: number = 1.0 // 0.0 ~ 1.0 ç”»ç¬”é€æ˜åº¦ï¼ˆæš‚æ—¶åªä½œä¸º UIï¼‰
  // å½“å‰æ˜¯å¦æ­£åœ¨ç»˜åˆ¶ä¸€ä¸ªå½¢çŠ¶ï¼ˆçº¿ã€çŸ©å½¢ã€åœ†ç­‰ï¼‰
  private isShapeDrawing: boolean = false
  // é€šç”¨å½¢çŠ¶ç»˜åˆ¶çš„èµ·ç‚¹ï¼ˆUI åæ ‡ï¼‰
  private shapeStartUiX: number = 0
  private shapeStartUiY: number = 0
  // è‡ªç”±ç»˜åˆ¶çŠ¶æ€ï¼ˆå½¢çŠ¶ = ShapeTool.FreeDraw æ—¶ä½¿ç”¨ï¼‰
  private isFreeDrawing: boolean = false
  private freeLastUiX: number = 0
  private freeLastUiY: number = 0
  // è‡ªç”±ç”»å¼€å§‹æ—¶ç¼“å­˜åŸå›¾åƒç´ 
  private freeDrawBuffer: Uint8Array | null = null
  private freeDrawArrayBuffer: ArrayBuffer | null = null
  private freeDrawByteLength: number = 0
  private freeBufferReady: boolean = false
  // å½“å‰åº•å›¾çš„å¯¹è§’çº¿é•¿åº¦ï¼ˆåƒç´ ï¼‰ï¼Œç”¨äºè£å‰ªæ—¶æ¸©å’Œç¼©æ”¾ç”»ç¬”
  @State imageDiag: number = 0
  // ==== æ–°å¢ï¼šåä½œ WebSocket å®¢æˆ·ç«¯ ====
  // æŠŠä¸‹é¢çš„ 192.168.1.100 æ¢æˆä½ è¿è¡Œ Node.js æœåŠ¡å™¨é‚£å°ç”µè„‘çš„å±€åŸŸç½‘ IP
  // ä¸èƒ½ç”¨ 0.0.0.0ï¼Œè¦ç”¨å…·ä½“ IPï¼Œæ¯”å¦‚ 192.168.0.5
  private collabClient: CollabClient = new CollabClient(
    'ws://192.168.1.11:8080/collab'
  );
  // ç»™å½“å‰è®¾å¤‡ä¸€ä¸ªå›ºå®š idï¼ˆä¸è¦æ¯æ¬¡ç‚¹å‡»éƒ½å˜ï¼‰
  @State localClientId: string = ''; // æœåŠ¡å™¨åˆ†é…ç»™è‡ªå·±çš„ id
  @State localColor: string = '#000000'; // è‡ªå·±çš„ä»£è¡¨è‰²
  // åœ¨çº¿ç”¨æˆ·åˆ—è¡¨ï¼ˆåŒ…å«è‡ªå·±å’Œåˆ«äººï¼‰
  @State onlineUsers: Array<OnlineUserInfo> = [];
  // æœ¬æœº clientIdï¼ˆç»™ CollabClient ç”¨çš„é‚£ä¸ª idï¼Œè¦ä¿æŒä¸€è‡´ï¼‰
  private clientId: string = 'client-' + Date.now().toString();
  // ç®€å•çš„é¢œè‰²æ± ï¼ŒæŒ‰é¡ºåºç»™ä¸åŒç”¨æˆ·åˆ†é¢œè‰²
  private userColorPalette: Array<string> = [
    '#2563EB', // è“
    '#EC4899', // ç²‰
    '#10B981', // ç»¿
    '#F97316', // æ©™
    '#A855F7',// ç´«
  ];
  private nextColorIndex: number = 0;

  // ====== æ–°å¢ï¼šç”Ÿå‘½å‘¨æœŸé‡Œåˆå§‹åŒ– / å…³é—­ WebSocket ======
  // ====== ç”Ÿå‘½å‘¨æœŸï¼šé¡µé¢å‡ºç°æ—¶åˆå§‹åŒ– WebSocket ======
  aboutToAppear(): void {
    this.collabClient.setCallbacks(
      () => {
        // onOpen
        console.log('[Collab] WebSocket open');

        // âœ… è‡ªå·±çš„é¢œè‰²ï¼šç”± clientId å†³å®šï¼ˆç¨³å®šï¼‰
        const selfColor: string = this.pickColorForClient(this.clientId);
        this.localColor = selfColor;

        const selfUser: OnlineUserInfo = {
          clientId: this.clientId,
          displayColor: selfColor,
          isSelf: true
        };
        this.onlineUsers = [selfUser];
      },
      () => {
        console.log('[Collab] WebSocket close');
        this.onlineUsers = [];
      },
      (msg: CollabMessage) => {
        console.log('[Collab] message = ' + JSON.stringify(msg));

        // ğŸ”´ è¿œç«¯ç”¨æˆ·ï¼šæ ¹æ® msg.clientId æ³¨å†Œï¼Œé¢œè‰²ç”± clientId å†³å®š
        if (msg.clientId && msg.clientId !== this.clientId) {
          this.ensureRemoteUser(msg.clientId);
        }

        if (msg.type === 'clear') {
          console.log('[Collab] remote clear layer, do resetView()');
          this.resetView();
        }

        // âœ… æ–°å¢ï¼šæ”¶åˆ°å›¾ç‰‡åŒæ­¥æ¶ˆæ¯
        if (msg.type === 'imageSync') {
          const payload = msg.payload as CollabImageSyncPayload;
          console.info('[Collab] receive image-sync from: ' + msg.clientId);

          this.applyRemoteImage(payload).then(() => {
            console.info('[Collab] remote image applied');
            promptAction.showToast({ message: 'å·²åŠ è½½åä½œå›¾ç‰‡' })
          })
        }

        // ä»¥åä½ è¿™é‡Œå¯ä»¥åŠ  stroke ç­‰å…¶ä»–ç±»å‹ï¼š
        // if (msg.type === 'stroke') { ... }
      },
      (err: string) => {
        console.error('[Collab] error = ' + err);
      }
    );

    this.collabClient.connect();
  }

  aboutToDisappear(): void {
    // é¡µé¢é”€æ¯æ—¶è®°å¾—æ–­å¼€è¿æ¥
    this.collabClient.close();
  }

  build() {
    Column() {
      // é¡¶éƒ¨å·¥å…·æ 
      Column() {
        Column() {

          // é¡¶éƒ¨å·¥å…·æ 
          Column() {
            // === ä¸€çº§èœå•ï¼šå›¾ç‰‡æ“ä½œ / å½¢çŠ¶ / ç”»ç¬” / æ’¤é”€ ===
            Row({ space: 8 }) {
              // ä¸€çº§æŒ‰é’®ï¼šå›¾ç‰‡æ“ä½œ
              Button('å›¾ç‰‡æ“ä½œ', { type: ButtonType.Capsule })
                .height(32)
                .fontSize(12)
                .backgroundColor(this.currentMenu === 'image' ? '#2563EB' : '#EFF6FF')
                .fontColor(this.currentMenu === 'image' ? '#FFFFFF' : '#1D4ED8')
                .onClick(() => {
                  this.currentMenu = this.currentMenu === 'image' ? '' : 'image'
                })

              // ä¸€çº§æŒ‰é’®ï¼šå½¢çŠ¶
              Button('å½¢çŠ¶', { type: ButtonType.Capsule })
                .height(32)
                .fontSize(12)
                .backgroundColor(this.currentMenu === 'shape' ? '#2563EB' : '#EFF6FF')
                .fontColor(this.currentMenu === 'shape' ? '#FFFFFF' : '#1D4ED8')
                .onClick(() => {
                  this.currentMenu = this.currentMenu === 'shape' ? '' : 'shape'
                })

              // ä¸€çº§æŒ‰é’®ï¼šç”»ç¬”
              Button('ç”»ç¬”', { type: ButtonType.Capsule })
                .height(32)
                .fontSize(12)
                .backgroundColor(this.currentMenu === 'brush' ? '#2563EB' : '#EFF6FF')
                .fontColor(this.currentMenu === 'brush' ? '#FFFFFF' : '#1D4ED8')
                .onClick(() => {
                  this.currentMenu = this.currentMenu === 'brush' ? '' : 'brush'
                })

              // ä¸€çº§æŒ‰é’®ï¼šæ’¤é”€ï¼ˆè¿™é‡Œå…ˆå ä½ï¼Œåé¢ä½ æ¥å…¥çœŸæ­£çš„æ’¤é”€é€»è¾‘ï¼‰
              Button('æ’¤é”€', { type: ButtonType.Capsule })
                .height(32)
                .fontSize(12)
                .backgroundColor('#fff31818')
                .onClick(async () => {
                  await this.undo()
                })
            }
            .width('100%')
            .padding({
              left: 4,
              right: 4,
              top: 4,
              bottom: 4
            })
            .justifyContent(FlexAlign.Center)

            // === äºŒçº§èœå•åŒºåŸŸï¼šæ ¹æ® currentMenu å†³å®šæ˜¾ç¤ºå“ªä¸€è¡Œ ===
            if (this.currentMenu === 'image') {
              // å›¾ç‰‡æ“ä½œï¼šå¸¦æ¨ªå‘æ»šåŠ¨æ¡
              Scroll() {
                Row({ space: 8 }) {
                  Button('è£å‰ª', { type: ButtonType.Capsule })
                    .height(32)
                    .fontSize(12)
                    .backgroundColor(this.cropMode ? '#EF4444' : '#EFF6FF')
                    .fontColor(this.cropMode ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => {
                      if (!this.pixelMap) {
                        // ä¸è¿›å…¥è£å‰ªæ¨¡å¼ï¼Œä½†è°ƒç”¨ doCropï¼Œè®© doCrop è‡ªå·±å¼¹å‡º toast
                        this.doCrop()
                        return
                      }

                      this.cropMode = !this.cropMode
                      if (this.cropMode) {
                        this.cropStartX = 0
                        this.cropStartY = 0
                        this.cropEndX = 0
                        this.cropEndY = 0
                      }
                    })

                  // äºŒçº§æŒ‰é’®ç»Ÿä¸€ç”¨ Normal + æµ…ç°èƒŒæ™¯ï¼Œä¸ä¸€çº§åŒºåˆ†
                  Button('å¯¹æ¯”åº¦+', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.adjustContrast(0.1))

                  Button('å¯¹æ¯”åº¦-', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.adjustContrast(-0.1))

                  Button('å·¦æ—‹90Â°', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.rotateLeft90())

                  Button('å³æ—‹90Â°', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.rotateRight90())

                  Button('å˜äº®', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.adjustBrightness(0.05))

                  Button('å˜æš—', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor('#F3F4F6')
                    .fontColor('#374151')
                    .onClick(() => this.adjustBrightness(-0.05))
                }
                .height(32)
                .padding({ left: 4, right: 4 })
              }
              .scrollable(ScrollDirection.Horizontal)
              .width('100%')
              .padding({ bottom: 8 }) // äºŒçº§èœå•å’Œç”»å¸ƒä¹‹é—´ç•™ä¸€ç‚¹ç©ºéš™
            } else if (this.currentMenu === 'shape') {
              Scroll() {
                Row({ space: 8 }) {

                  Button('ç‚¹', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Point ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Point ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.selectShape(ShapeTool.Point))

                  Button('ç›´çº¿', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Line ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Line ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.selectShape(ShapeTool.Line))

                  Button('çŸ©å½¢', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Rect ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Rect ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.selectShape(ShapeTool.Rect))

                  Button('åœ†', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Circle ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Circle ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.selectShape(ShapeTool.Circle))

                  Button('æ¤­åœ†', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.Ellipse ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.Ellipse ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.selectShape(ShapeTool.Ellipse))

                  Button('çº¿æ¡', { type: ButtonType.Normal })
                    .height(28)
                    .fontSize(11)
                    .backgroundColor(this.currentShape === ShapeTool.FreeDraw ? '#2563EB' : '#E5F3FF')
                    .fontColor(this.currentShape === ShapeTool.FreeDraw ? '#FFFFFF' : '#1D4ED8')
                    .onClick(() => this.selectShape(ShapeTool.FreeDraw))

                }
                .height(32)
                .padding({ left: 4, right: 4 })
              }
              .scrollable(ScrollDirection.Horizontal)
              .width('100%')
              .padding({ bottom: 8 })

            } else if (this.currentMenu === 'brush') {
              Scroll() {
                Column() {


                  // ===== ç¬¬ 2 è¡Œï¼šç²—ç»†è°ƒèŠ‚ Slider =====
                  Row({ space: 8 }) {
                    Text('ç²—ç»†')
                      .fontSize(11)
                      .fontColor('#4B5563')
                      .width(36)

                    Slider({
                      value: this.strokeWidth,
                      min: 1,
                      max: 40,
                      step: 1
                    })
                      .width('60%')
                      .onChange((value: number) => {
                        this.strokeWidth = value
                      })

                    Text(`${this.strokeWidth.toFixed(0)} px`)
                      .fontSize(10)
                      .fontColor('#6B7280')
                      .width(40)
                  }
                  .height(32)
                  .padding({ left: 4, right: 4, bottom: 4 })
                  .alignItems(VerticalAlign.Center)


                  // ===== ç¬¬ 3 è¡Œï¼šé€æ˜åº¦ Slider =====
                  Row({ space: 8 }) {
                    Text('é€æ˜åº¦')
                      .fontSize(11)
                      .fontColor('#4B5563')
                      .width(36)

                    Slider({
                      value: this.strokeOpacity,
                      min: 0.1, // æœ€ä½ 10%ï¼Œé˜²æ­¢å®Œå…¨çœ‹ä¸è§
                      max: 1.0,
                      step: 0.05
                    })
                      .width('60%')
                      .onChange((value: number) => {
                        this.strokeOpacity = value
                      })

                    Text(`${Math.round(this.strokeOpacity * 100)}%`)
                      .fontSize(10)
                      .fontColor('#6B7280')
                      .width(40)
                  }
                  .height(32)
                  .padding({ left: 4, right: 4, bottom: 4 })
                  .alignItems(VerticalAlign.Center)


                  // ---- ç¬¬äº”è¡Œï¼šé¢œè‰²é¢„è§ˆï¼ˆå¯é€‰ï¼‰ ----
                  Row() {
                    // ===== ç¬¬ 1 è¡Œï¼šæ©¡çš®æ“¦ =====
                    Row({ space: 8 }) {
                      Button('æ©¡çš®æ“¦', { type: ButtonType.Normal })
                        .height(28)
                        .fontSize(11)
                        .backgroundColor(this.currentBrush === BrushTool.Eraser ? '#FB923C' : '#FEF3C7')
                        .fontColor(this.currentBrush === BrushTool.Eraser ? '#FFFFFF' : '#92400E')
                        .onClick(() => {
                          if (this.currentBrush === BrushTool.Eraser) {
                            // ğŸ‘‰ å†ç‚¹ä¸€æ¬¡ï¼šå…³é—­æ©¡çš®æ“¦ï¼Œæ¢å¤æ™®é€šç”»ç¬”
                            this.currentBrush = BrushTool.Pen
                            // è‡ªç”±ç”»ä¿æŒä¸å˜ï¼Œç”¨æˆ·å¯ä»¥ç»§ç»­ç”¨æ™®é€šç”»ç¬”è‡ªç”±ç”»
                          } else {
                            // ğŸ‘‰ ç¬¬ä¸€æ¬¡ç‚¹ï¼šå¼€å¯æ©¡çš®æ“¦ + è¿›å…¥è‡ªç”±ç»˜åˆ¶æ¨¡å¼
                            this.currentBrush = BrushTool.Eraser
                            this.currentShape = ShapeTool.FreeDraw
                          }
                        })

                    }
                    .height(32)
                    .padding({ left: 4, right: 4, bottom: 4 })

                    ColorWheelPicker({
                      strokeR: $strokeR,
                      strokeG: $strokeG,
                      strokeB: $strokeB
                    }).margin({ top: 6 })

                    Text('å½“å‰é¢œè‰²é¢„è§ˆ').fontSize(14)

                    Blank()
                      .width(24)
                      .height(24)
                      .backgroundColor(
                        // strokeR/G/B æ˜¯ 0~255ï¼Œéœ€è¦ç»„è£…æˆ 0xAARRGGBB
                        (0xFF000000 +
                          (this.strokeR << 16) +
                          (this.strokeG << 8) +
                        this.strokeB)
                      )
                      .border({ width: 1, color: '#111827' })
                      .margin({ left: 8 })
                  }

                }
              }
              .scrollable(ScrollDirection.Horizontal)
              .width('100%')
              .padding({ bottom: 8 })
            }
          }

          // ===== é¡¶éƒ¨ï¼šåœ¨çº¿åä½œç”¨æˆ·æ¡ =====
          Row({ space: 8 }) {
            ForEach(this.onlineUsers, (u: OnlineUserInfo) => {
              Row() {
                // ğŸ”¥ ä¸åŒé¢œè‰²çš„çŸ©å½¢
                Blank()
                  .width(20)
                  .height(12)
                  .backgroundColor(u.displayColor)
                  .borderRadius(3) // æˆ–è€…ç”¨ 0 = çº¯çŸ©å½¢
                  .margin({ right: 6 })

                Text(u.isSelf ? 'æˆ‘ (' + u.clientId + ')' : u.clientId)
                  .fontSize(11)
                  .fontColor('#111827')
              }
              .padding({
                left: 8,
                right: 8,
                top: 4,
                bottom: 4
              })
              .backgroundColor('#F3F4F6')
              .borderRadius(8)
            }, (u: OnlineUserInfo) => u.clientId)
          }
          .margin({ top: 12, left: 12, right: 12 })


          // ç”»å¸ƒ
          Stack() {
            if (!this.pixelMap) {
              Column() {
                Text('ç‚¹å‡»â€œæ‰“å¼€å›¾ç‰‡â€å¼€å§‹ç¼–è¾‘')
                  .fontSize(14)
                  .fontColor('#9AA1A8')
                  .letterSpacing(0.5)
              }
              .width('100%').height('100%')
              .justifyContent(FlexAlign.Center)
              .alignItems(HorizontalAlign.Center)
            } else {
              // =======================
              // 1. å›¾ç‰‡æ˜¾ç¤ºå±‚ï¼ˆåº•å›¾ï¼‰
              // =======================
              Image(this.pixelMap)
                .id(`img-${this.pixelVersion}`)
                .objectFit(ImageFit.Contain)
                .width('100%')
                .height('100%')
                .scale({ x: this.zoom, y: this.zoom })
                .translate({ x: this.offsetX, y: this.offsetY })
                .colorFilter(this.buildToneMatrix())

              // =======================
              // 1.5 ç»˜åˆ¶å›¾å±‚ï¼ˆå åŠ ï¼‰
              // =======================
              if (this.drawPixelMap) {
                Image(this.drawPixelMap)
                  .id(`draw-${this.drawPixelVersion}`)
                  .objectFit(ImageFit.Contain)
                  .width('100%')
                  .height('100%')
                  .scale({ x: this.zoom, y: this.zoom })
                  .translate({ x: this.offsetX, y: this.offsetY })
              }


              // ==========================
              // 2. æ‹–æ‹½ & ç¼©æ”¾æ‰‹åŠ¿å±‚ï¼ˆä¸æ˜¯è£å‰ªæ—¶ç”Ÿæ•ˆï¼‰
              // ==========================
              if (!this.cropMode) {
                Stack()
                  .width('100%')
                  .height('100%')
                  .backgroundColor(Color.Transparent)
                  .hitTestBehavior(HitTestMode.Transparent)
                  .gesture(
                    GestureGroup(GestureMode.Parallel,

                      // ç‚¹å‡»ï¼šç”»ç‚¹
                      TapGesture()
                        .onAction((ev: GestureEvent) => {
                          if (!ev.fingerList || ev.fingerList.length === 0) {
                            return
                          }
                          const finger = ev.fingerList[0]
                          const x: number = finger.localX
                          const y: number = finger.localY

                          console.info(`>>> tap at x=${x}, y=${y}`)

                          if (this.currentShape === ShapeTool.Point) {
                            this.drawPointAtUi(x, y)
                          }
                        }),

                      // æ‹–æ‹½ï¼šå¹³ç§» / ç›´çº¿ / çŸ©å½¢ / åœ† / æ¤­åœ† / è‡ªç”±ç”»
                      PanGesture({ direction: PanDirection.All })
                        .onActionStart(e => {
                          if (!e.fingerList || e.fingerList.length === 0) {
                            return
                          }
                          const f = e.fingerList[0]

                          if (this.currentShape === ShapeTool.FreeDraw) {
                            this.isFreeDrawing = true
                            this.freeLastUiX = f.localX
                            this.freeLastUiY = f.localY

                            // å¼‚æ­¥å‡†å¤‡ bufferï¼ˆä¸èƒ½ awaitï¼‰
                            this.prepareFreeDrawBuffer()

                            // å­˜ä¸€æ¬¡å¿«ç…§æ–¹ä¾¿æ’¤é”€æ•´ç¬”
                            if (this.pixelMap) {
                              this.clonePixelMap(this.pixelMap as image.PixelMap)
                                .then(pmBackup => this.pushHistorySnapshot(true, pmBackup))
                            }
                            return
                          }


                          // âœ… æƒ…å†µ 2ï¼šç›´çº¿ / çŸ©å½¢ / åœ† / æ¤­åœ†ï¼šæ‹–å‡ºä¸€ä¸ªå½¢çŠ¶
                          if (this.currentShape === ShapeTool.Line ||
                            this.currentShape === ShapeTool.Rect ||
                            this.currentShape === ShapeTool.Circle ||
                            this.currentShape === ShapeTool.Ellipse) {
                            this.isShapeDrawing = true
                            this.shapeStartUiX = f.localX
                            this.shapeStartUiY = f.localY
                            console.info(`>>> shape start ui=(${this.shapeStartUiX}, ${this.shapeStartUiY})`)
                            return
                          }

                          // âœ… æƒ…å†µ 3ï¼šå…¶ä»–æƒ…å†µ â†’ å½“æˆå¹³ç§»ç”»å¸ƒ
                          this.lastPanX = this.offsetX
                          this.lastPanY = this.offsetY
                        })
                        .onActionUpdate(e => {
                          if (!e.fingerList || e.fingerList.length === 0) {
                            return
                          }
                          const f = e.fingerList[0]

                          if (this.isFreeDrawing && this.currentShape === ShapeTool.FreeDraw) {
                            this.drawFreeStrokeSegmentSync(
                              this.freeLastUiX,
                              this.freeLastUiY,
                              f.localX,
                              f.localY
                            )

                            this.freeLastUiX = f.localX
                            this.freeLastUiY = f.localY
                            return
                          }

                          // ğŸ‘‰ æ­£åœ¨ç”»å›¾å½¢ï¼ˆçº¿ / çŸ©å½¢ / åœ† / æ¤­åœ†ï¼‰æ—¶ï¼Œä¸å¹³ç§»
                          if (this.isShapeDrawing &&
                            (this.currentShape === ShapeTool.Line ||
                              this.currentShape === ShapeTool.Rect ||
                              this.currentShape === ShapeTool.Circle ||
                              this.currentShape === ShapeTool.Ellipse)) {
                            return
                          }

                          // ğŸ‘‰ å¦åˆ™ï¼šå¹³ç§»ç”»å¸ƒ
                          this.offsetX = this.lastPanX + e.offsetX
                          this.offsetY = this.lastPanY + e.offsetY
                        })
                        .onActionEnd((e: GestureEvent) => {
                          // è‡ªç”±ç”»ç»“æŸ
                          if (this.isFreeDrawing && this.currentShape === ShapeTool.FreeDraw) {
                            this.handleFreeDrawEnd()
                            return
                          }

                          // å›¾å½¢ç»“æŸ
                          if (!e.fingerList || e.fingerList.length === 0) {
                            this.isShapeDrawing = false
                            return
                          }

                          const f = e.fingerList[0] // â† å·²å»æ‰ GestureFinger

                          const endUiX: number = f.localX
                          const endUiY: number = f.localY


                          // â‘¢ å›¾å½¢ç»“æŸï¼šç›´çº¿ / çŸ©å½¢ / åœ† / æ¤­åœ†
                          if (this.isShapeDrawing &&
                            (this.currentShape === ShapeTool.Line ||
                              this.currentShape === ShapeTool.Rect ||
                              this.currentShape === ShapeTool.Circle ||
                              this.currentShape === ShapeTool.Ellipse)) {

                            this.isShapeDrawing = false

                            if (this.currentShape === ShapeTool.Line) {
                              this.handleLineDrag(this.shapeStartUiX, this.shapeStartUiY, endUiX, endUiY)
                            } else if (this.currentShape === ShapeTool.Rect) {
                              this.handleRectDrag(this.shapeStartUiX, this.shapeStartUiY, endUiX, endUiY)
                            } else if (this.currentShape === ShapeTool.Circle) {
                              this.handleCircleDrag(this.shapeStartUiX, this.shapeStartUiY, endUiX, endUiY)
                            } else if (this.currentShape === ShapeTool.Ellipse) {
                              this.handleEllipseDrag(this.shapeStartUiX, this.shapeStartUiY, endUiX, endUiY)
                            }
                          }
                        }),
                      // ç¼©æ”¾ï¼šä¿æŒåŸæ¥çš„é€»è¾‘
                      PinchGesture()
                        .onActionStart(e => {
                          this.lastZoom = this.zoom
                        })
                        .onActionUpdate(e => {
                          let next = this.lastZoom * e.scale
                          this.zoom = Math.min(5, Math.max(0.3, next))
                        })
                    )
                  )
              }


              // === è£å‰ªæ¨¡å¼ ===
              if (this.cropMode) {
                // æ‰‹åŠ¿ï¼šæ‹–å‡ºè£å‰ªæ¡†
                Stack()
                  .width('100%')
                  .height('100%')
                  .backgroundColor(Color.Transparent)
                  .gesture(
                    PanGesture({ direction: PanDirection.All })
                      .onActionStart(ev => {
                        const f = ev.fingerList[0]
                        this.cropStartX = f.localX
                        this.cropStartY = f.localY
                        this.cropEndX = f.localX
                        this.cropEndY = f.localY
                      })
                      .onActionUpdate(ev => {
                        const f = ev.fingerList[0]
                        this.cropEndX = f.localX
                        this.cropEndY = f.localY
                      })
                      .onActionEnd(() => {
                        this.doCrop()
                      })
                  )

                // ç”»è£å‰ªæ¡†ï¼ˆUIï¼‰
                Rect()
                  .position({
                    x: Math.min(this.cropStartX, this.cropEndX),
                    y: Math.min(this.cropStartY, this.cropEndY)
                  })
                  .width(Math.abs(this.cropEndX - this.cropStartX))
                  .height(Math.abs(this.cropEndY - this.cropStartY))
                  .stroke(Color.Red)
                  .strokeWidth(2)
                  .fill('rgba(255,0,0,0.18)')
              }

            }
          }
          .width('100%')
          .layoutWeight(1)
          .backgroundColor('#FFFFFF')
          .borderRadius(12)
          .padding(2)
          .clip(true)
          .onAreaChange((oldArea, newArea) => {
            this.canvasWidth = Number(newArea.width)
            this.canvasHeight = Number(newArea.height)
          })


          // åº•éƒ¨å·¥å…·æ 
          Row({ space: 10 }) {
            Text('é¸¿ç»˜')
              .fontSize(16)
              .fontWeight(FontWeight.Medium)
              .fontColor('#6B7280')
              .layoutWeight(1)

            Button('æ‰“å¼€å›¾ç‰‡', { type: ButtonType.Capsule })
              .height(40).padding({ left: 14, right: 14 })
              .onClick(() => this.pickImage())

            SaveButton({
              icon: SaveIconStyle.FULL_FILLED,
              text: SaveDescription.SAVE_IMAGE,
              buttonType: ButtonType.Capsule
            })
              .height(40)
              .padding({ left: 14, right: 14 })
              .onClick(async (event, result: SaveButtonOnClickResult) => {
                if (result === SaveButtonOnClickResult.SUCCESS) {
                  // ç”¨æˆ·ç‚¹äº†ä¿å­˜æŒ‰é’®ï¼Œç³»ç»Ÿä¸´æ—¶æˆäºˆç›¸å†Œå†™å…¥æƒé™ï¼ˆçº¦ 5 ç§’ï¼‰
                  await this.saveImage()
                } else {
                  promptAction.showToast({ message: 'æˆæƒå¤±è´¥ï¼Œæ— æ³•ä¿å­˜' })
                }
              })

            Button('é‡ç½®', { type: ButtonType.Capsule })
              .height(40)
              .padding({ left: 14, right: 14 })
              .backgroundColor('#EEF2FF')
              .fontColor('#3B82F6')
              .onClick(() => {
                // â‘  æœ¬åœ°é‡ç½®
                this.resetView();

                // â‘¡ å¦‚æœ WebSocket å·²è¿æ¥ï¼ŒåŒæ­¥å‘ä¸€æ¡æ¶ˆæ¯
                if (this.collabClient.connected) {
                  const msg: CollabMessage = buildClearMessage(
                    this.localClientId, // å’Œä¸Šé¢çš„ localClientId ä¿æŒä¸€è‡´
                    'main-layer'        // ä½ è‡ªå·±çš„å›¾å±‚ id
                  );
                  this.collabClient.send(msg);
                } else {
                  console.error('[Collab] not connected, skip send clear');
                }
              })
          }
          .width('100%')
          .padding({
            left: 12,
            right: 12,
            top: 10,
            bottom: 10
          })
          .backgroundColor('#F7F8FA')
          .border({ width: { top: 0.5 }, color: '#E5E7EB' })
          .alignItems(VerticalAlign.Center)

        }
        .width('100%').height('100%')
        .backgroundColor('#FFFFFF')
        .padding(12)
      }
    }
  }

  // æ ¹æ®åº•å›¾ pm åˆ›å»ºä¸€å¼ â€œå®Œå…¨é€æ˜â€çš„ç»˜åˆ¶å›¾å±‚ï¼ˆå°ºå¯¸ & åƒç´ æ ¼å¼ä¸€è‡´ï¼‰
  private async createEmptyDrawLayerLike(pm: image.PixelMap): Promise<image.PixelMap> {
    // 1. å…ˆ clone ä¸€ä»½ï¼Œä¿è¯ editable
    const layer: image.PixelMap = await this.clonePixelMap(pm)

    // 2. æŠŠæ‰€æœ‰åƒç´ æ¸…æˆé€æ˜
    const byteLength: number = layer.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await layer.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    for (let i = 0; i < data.length; i += 4) {
      data[i] = 0 // R
      data[i + 1] = 0 // G
      data[i + 2] = 0 // B
      data[i + 3] = 0 // A = 0 å®Œå…¨é€æ˜
    }

    await layer.writeBufferToPixels(buffer)
    return layer
  }

  // ç¡®ä¿å­˜åœ¨ç»˜åˆ¶å›¾å±‚ï¼šæ²¡æœ‰å°±åˆ›å»ºï¼Œæœ‰å°±ç›´æ¥è¿”å›
  private async ensureDrawLayer(): Promise<image.PixelMap | undefined> {
    if (!this.pixelMap) {
      return undefined
    }

    if (!this.drawPixelMap) {
      const basePm = this.pixelMap as image.PixelMap
      this.drawPixelMap = await this.createEmptyDrawLayerLike(basePm)
      this.drawPixelVersion++
    }

    return this.drawPixelMap as image.PixelMap
  }

  // é¸¿è’™ 6.0 å®˜æ–¹å¯ç”¨ã€ä¸å˜è‰²çš„å…‹éš†ï¼špack â†’ decode
  private async clonePixelMap(pm: image.PixelMap): Promise<image.PixelMap> {
    // 1. pack æˆ PNG å†…å­˜æµï¼ˆæ³¨æ„ï¼špackToData åªæœ‰ä¸¤ä¸ªå‚æ•°ï¼‰
    const packer = image.createImagePacker()
    const packOpts: image.PackingOption = {
      format: 'image/png', // PNG æ— æŸï¼Œé¢œè‰²æœ€å®‰å…¨
      quality: 100
    }

    // HarmonyOS 6.0ï¼špackToData è¿”å› Promise<ArrayBuffer>
    const buffer: ArrayBuffer = await packer.packToData(pm, packOpts)
    packer.release?.()

    // 2. å† decode æˆæ–°çš„ PixelMapï¼ˆä¿æŒ editableï¼‰
    const imgSource = image.createImageSource(buffer)
    const clonePm: image.PixelMap = await imgSource.createPixelMap({
      editable: true
    })
    imgSource.release?.()

    return clonePm
  }

  // åœ¨ä¸€æ¬¡â€œä¼šæ”¹å˜å›¾åƒ/çŠ¶æ€â€çš„æ“ä½œä¹‹å‰è°ƒç”¨ï¼Œè®°å½•å¿«ç…§
  // includePixel = trueï¼šæŠŠ pmForSnapshot è¿™å¼ å›¾ä½œä¸ºå¿«ç…§ä¿å­˜ï¼ˆä¸æ‹·è´åƒç´ ï¼‰â€”â€”ä¸“é—¨ç»™è£å‰ªç”¨
  private async pushHistorySnapshot(includePixel: boolean, pmForSnapshot?: image.PixelMap): Promise<void> {
    let snapshotPixel: image.PixelMap | undefined = undefined
    let snapshotDraw: image.PixelMap | undefined = undefined // â­ æ–°å¢

    // æ˜¯å¦åŒ…å«åƒç´ å¿«ç…§ï¼ˆåº•å›¾ï¼‰
    if (includePixel && pmForSnapshot) {
      snapshotPixel = pmForSnapshot
    }

    // â­ ä¸ç®¡åº•å›¾è¦ä¸è¦ä¿å­˜ï¼Œç»˜åˆ¶å›¾å±‚å¦‚æœå­˜åœ¨ï¼Œéƒ½ clone ä¸€ä»½ä¿å­˜å¿«ç…§
    if (this.drawPixelMap) {
      snapshotDraw = await this.clonePixelMap(this.drawPixelMap as image.PixelMap)
    }

    // å¦‚æœå·²ç»æ’¤é”€åˆ°ä¸­é—´ï¼Œå†åšæ–°æ“ä½œï¼Œåˆ™ç æ‰â€œæœªæ¥â€åˆ†æ”¯
    if (this.historyIndex >= 0 && this.historyIndex < this.history.length - 1) {
      for (let i = this.historyIndex + 1; i < this.history.length; i++) {
        this.history[i].pixelMap?.release?.()
        this.history[i].drawPixelMap?.release?.() // â­ è®°å¾—é‡Šæ”¾ç»˜åˆ¶å±‚å¿«ç…§
      }
      this.history = this.history.slice(0, this.historyIndex + 1)
    }

    this.history.push({
      pixelMap: snapshotPixel,
      drawPixelMap: snapshotDraw, // â­ å­˜è¿›å»
      zoom: this.zoom,
      offsetX: this.offsetX,
      offsetY: this.offsetY,
      brightnessLevel: this.brightnessLevel,
      contrastLevel: this.contrastLevel,
      accumulatedRotate: this.accumulatedRotate
    })

    this.historyIndex = this.history.length - 1
  }

  // é‡ç½®åˆ°â€œåˆšæ‰“å¼€å›¾ç‰‡æ—¶â€çš„çŠ¶æ€
  private async resetView(): Promise<void> {
    // â‘  æ²¡æœ‰å›¾ï¼Œç›´æ¥è¿”å›
    if (!this.pixelMap) {
      return;
    }

    // â‘¡ æ²¡æœ‰åŸå›¾å¿«ç…§ï¼šåªé‡ç½®è§†å›¾å‚æ•°ï¼ˆå…¼å®¹è€æ•°æ®ï¼‰
    if (!this.originalPixelMap) {
      this.zoom = 1.0;
      this.offsetX = 0;
      this.offsetY = 0;
      this.brightnessLevel = 0.0;
      this.contrastLevel = 0.0;
      this.accumulatedRotate = 0;
      this.pixelVersion++;
      return;
    }

    // â‘¢ åœ¨é‡ç½®ä¹‹å‰ï¼Œå…ˆæŠŠå½“å‰çŠ¶æ€æ”¾è¿›å†å²æ ˆï¼Œreset ä¹Ÿèƒ½â€œæ’¤é”€â€
    const currentPm: image.PixelMap = this.pixelMap as image.PixelMap;
    const beforeResetPm: image.PixelMap = await this.clonePixelMap(currentPm);
    await this.pushHistorySnapshot(true, beforeResetPm);

    // â‘£ ç”¨ originalPixelMap è¿˜åŸåº•å›¾ï¼ˆé‡æ–° clone ä¸€ä»½å¯ç¼–è¾‘ç‰ˆæœ¬ï¼‰
    const originalPm: image.PixelMap = this.originalPixelMap as image.PixelMap;
    const newPm: image.PixelMap = await this.clonePixelMap(originalPm);

    // é‡Šæ”¾å½“å‰åº•å›¾
    currentPm.release();

    // æ›¿æ¢ä¸ºâ€œåˆšæ‰“å¼€å›¾ç‰‡æ—¶â€çš„åº•å›¾
    this.pixelMap = newPm;

    // â‘¤ é‡å»ºç»˜åˆ¶å›¾å±‚ï¼šç›¸å½“äºæ–°å»ºä¸€å¼ å…¨é€æ˜çš„ overlay
    if (this.drawPixelMap) {
      const currentDrawPm: image.PixelMap = this.drawPixelMap as image.PixelMap;
      currentDrawPm.release();
    }
    const drawLayer: image.PixelMap = await this.createEmptyDrawLayerLike(newPm);
    this.drawPixelMap = drawLayer;
    this.drawPixelVersion++; // è§¦å‘å åŠ å±‚ Image åˆ·æ–°

    // â‘¥ è¿˜åŸè§†å›¾å‚æ•°
    this.zoom = 1.0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.brightnessLevel = 0.0;
    this.contrastLevel = 0.0;
    this.accumulatedRotate = 0;

    // â‘¦ é€šçŸ¥åº•å›¾åˆ·æ–°
    this.pixelVersion++;
  }

  // æ‰“å¼€å›¾ç‰‡ï¼ˆ
  private async pickImage() {
    try {
      // é€‰å›¾
      const picker = new photoAccessHelper.PhotoViewPicker()
      const options = new photoAccessHelper.PhotoSelectOptions()
      // åªé€‰æ‹©å›¾ç‰‡
      options.MIMEType = photoAccessHelper.PhotoViewMIMETypes.IMAGE_TYPE
      // ä¸€æ¬¡æœ€å¤šé€‰ä¸€å¼ 
      options.maxSelectNumber = 1

      // ç­‰å¾…ç”¨æˆ·é€‰æ‹©å›¾ç‰‡å¹¶æ‹¿å»ç»“æœ
      const result = await picker.select(options)
      const uris: Array<string> = result.photoUris

      // ç”¨æˆ·æœªé€‰æ‹©å›¾ç‰‡æç¤º
      if (!uris || uris.length === 0) {
        promptAction.showToast({ message: 'æœªé€‰æ‹©å›¾ç‰‡' })
        return
      }

      // å¾—åˆ°å›¾ç‰‡åœ°å€
      const uri: string = uris[0]
      console.info(`>>> Selected URI = ${uri}`)

      // ç”¨ fileIo æ‰“å¼€ uriï¼Œæ‹¿ fd
      const file = await fileIo.open(uri, fileIo.OpenMode.READ_ONLY)

      // æŠŠ fd äº¤ç»™ ImageKit è§£ç  â†’ å¾—åˆ° ImageSource
      const imgSource: image.ImageSource = image.createImageSource(file.fd)
      if (!imgSource) {
        await fileIo.close(file)
        throw new Error('createImageSource è¿”å›ç©º')
      }

      // ä» ImageSource åˆ›å»º PixelMap
      const pm: image.PixelMap = await imgSource.createPixelMap({
        editable: true
      })

      // é‡Šæ”¾åº•å±‚èµ„æº
      imgSource.release?.()
      await fileIo.close(file)

      // æ›´æ–° UI çŠ¶æ€
      // å…ˆé‡Šæ”¾æ—§çš„åŸå›¾å¿«ç…§
      if (this.originalPixelMap) {
        this.originalPixelMap.release?.()
      }
      // ä¿å­˜ä¸€ä»½â€œæ‰“å¼€æ—¶çš„åŸå›¾â€ï¼ˆä»¥å resetView å°±ç”¨å®ƒæ¥è¿˜åŸï¼‰
      this.originalPixelMap = await this.clonePixelMap(pm)

      // é‡Šæ”¾æ—§çš„å½“å‰å›¾
      if (this.pixelMap) {
        this.pixelMap.release?.()
      }
      // å½“å‰æ­£åœ¨ç¼–è¾‘çš„ PixelMap
      this.pixelMap = pm

      // åˆå§‹åŒ–è§†å›¾åˆ°â€œåˆšæ‰“å¼€â€çš„çŠ¶æ€
      this.zoom = 1.0
      this.offsetX = 0
      this.offsetY = 0
      this.brightnessLevel = 0.0
      this.contrastLevel = 0.0
      this.accumulatedRotate = 0
      this.pixelVersion++

      // ğŸ‘‰ æ–°å¢ï¼šè®°å½•å½“å‰å›¾ç‰‡å¯¹è§’çº¿ï¼Œç”¨äºåç»­è£å‰ªæ—¶è®¡ç®—æ¯”ä¾‹
      const openInfo: image.ImageInfo = await pm.getImageInfo()
      const openW: number = openInfo.size.width
      const openH: number = openInfo.size.height
      this.imageDiag = Math.hypot(openW, openH)

      // ========== æ–°å¢ï¼šä¸ºè¿™å¼ å›¾ç‰‡åˆ›å»ºä¸€å±‚é€æ˜çš„ç»˜åˆ¶å±‚ ==========
      if (this.drawPixelMap) {
        this.drawPixelMap.release?.()
      }
      this.drawPixelMap = await this.createEmptyDrawLayerLike(pm)
      this.drawPixelVersion++
      // =========================================================
      if (this.collabClient.connected && this.pixelMap) {
        await this.broadcastImageToPeers(this.pixelMap as image.PixelMap);
      }
      promptAction.showToast({ message: 'å›¾ç‰‡å·²åŠ è½½ ' })
    } catch (err) {
      let code = 'NA'
      let message = 'unknown'

      if (typeof err === 'object' && err !== null) {
        const e = err as ErrorWithCode

        if (e.code !== undefined) {
          code = String(e.code)
        }
        if (e.message !== undefined) {
          message = String(e.message)
        }
      } else {
        message = String(err)
      }

      const msg = `code=${code} msg=${message}`
      console.error(`[pickImage] failed: ${msg}`)
      promptAction.showToast({ message: `æ‰“å¼€å¤±è´¥ï¼š${msg}` })
    }
  }

  // ä¿å­˜å›¾ç‰‡ï¼šæŠŠå½“å‰ PixelMap å†™å…¥ç³»ç»Ÿç›¸å†Œ
  private async saveImage() {
    try {
      if (!this.pixelMap) {
        promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
        return
      }

      const context = getContext(this) as common.UIAbilityContext
      const helper = photoAccessHelper.getPhotoAccessHelper(context)

      // 1) å…‹éš†ä¸€ä»½åº•å›¾ï¼Œç”¨äºä¿å­˜
      const basePm: image.PixelMap = this.pixelMap as image.PixelMap
      const pmForSave: image.PixelMap = await this.clonePixelMap(basePm)

      // 2) æœ‰ç»˜åˆ¶å±‚çš„è¯ï¼Œå…ˆåˆæˆä¸Šå»
      if (this.drawPixelMap) {
        await this.mergeDrawLayerIntoBase(pmForSave, this.drawPixelMap as image.PixelMap)
      }

      // 3) æŠŠäº®åº¦/å¯¹æ¯”åº¦çƒ˜ç„™è¿› pmForSaveï¼ˆåªå½±å“ä¿å­˜ï¼Œä¸æ”¹çœŸå®çŠ¶æ€ï¼‰
      await this.bakeToneForSave(pmForSave)

      // 4) æ­£å¸¸ packToFile ä¿å­˜ pmForSave ...
      const uri: string = await helper.createAsset(
        photoAccessHelper.PhotoType.IMAGE,
        'jpg'
      )

      const file = await fileIo.open(
        uri,
        fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE
      )

      const packer = image.createImagePacker()
      const packOpts: image.PackingOption = {
        format: 'image/jpeg',
        quality: 90
      }

      await new Promise<void>((resolve, reject) => {
        packer.packToFile(
          pmForSave,
          file.fd,
          packOpts,
          (err: BusinessError) => err ? reject(err) : resolve()
        )
      })

      packer.release?.()
      await fileIo.close(file)

      promptAction.showToast({ message: 'å·²ä¿å­˜åˆ°ç›¸å†Œ ' })
    } catch (err) {
      const e = err as BusinessError
      console.error(`saveImage failed, code=${e?.code}, msg=${e?.message}`)
      promptAction.showToast({ message: 'ä¿å­˜å¤±è´¥' })
    }
  }

  // è£å‰ªå½“å‰å›¾ç‰‡ï¼ˆæ”¯æŒç¼©æ”¾ + å¹³ç§» + å åŠ ç»˜åˆ¶å±‚ï¼‰
  // è£å‰ªå½“å‰å›¾ç‰‡ï¼Œå¹¶è®©ç¬”åˆ·ç²—ç»†æŒ‰è£å‰ªæ¯”ä¾‹è‡ªåŠ¨å˜ç»†
  // è£å‰ªï¼šæ ¹æ®å½“å‰è£å‰ªæ¡†ï¼ŒæŠŠåº•å›¾å’Œç»˜åˆ¶å±‚ä¸€èµ·è£å‰ªï¼Œå¹¶â€œæ¸©å’Œâ€è°ƒæ•´ç”»ç¬”ç²—ç»†
  private async doCrop(): Promise<void> {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }

    const pm: image.PixelMap = this.pixelMap as image.PixelMap
    const info: image.ImageInfo = await pm.getImageInfo()

    // ç”»å¸ƒå°ºå¯¸ã€é˜²å¾¡
    if (this.canvasWidth <= 0 || this.canvasHeight <= 0) {
      promptAction.showToast({ message: 'ç”»å¸ƒå°šæœªåˆå§‹åŒ–' })
      this.cropMode = false
      return
    }

    // === 1. è®¡ç®—å›¾ç‰‡åœ¨ç”»å¸ƒä¸Šçš„å®é™…æ˜¾ç¤ºåŒºåŸŸï¼ˆè€ƒè™‘ contain + zoom + å¹³ç§»ï¼‰===
    const imgW: number = info.size.width
    const imgH: number = info.size.height

    const scaleBase: number = Math.min(
      this.canvasWidth / imgW,
      this.canvasHeight / imgH
    )

    if (scaleBase <= 0) {
      promptAction.showToast({ message: 'ç¼©æ”¾å‚æ•°å¼‚å¸¸' })
      this.cropMode = false
      return
    }

    const realW: number = imgW * scaleBase * this.zoom
    const realH: number = imgH * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY
    const imageRight: number = imageLeft + realW
    const imageBottom: number = imageTop + realH

    // === 2. è¯»å– UI è£å‰ªæ¡†ï¼Œå¹¶ä¸å›¾ç‰‡æ˜¾ç¤ºåŒºåŸŸæ±‚äº¤é›† ===
    let uiX1: number = Math.min(this.cropStartX, this.cropEndX)
    let uiY1: number = Math.min(this.cropStartY, this.cropEndY)
    let uiX2: number = Math.max(this.cropStartX, this.cropEndX)
    let uiY2: number = Math.max(this.cropStartY, this.cropEndY)

    // å’Œå›¾ç‰‡å¯è§åŒºåŸŸæ±‚äº¤
    uiX1 = Math.max(uiX1, imageLeft)
    uiY1 = Math.max(uiY1, imageTop)
    uiX2 = Math.min(uiX2, imageRight)
    uiY2 = Math.min(uiY2, imageBottom)

    if (uiX2 <= uiX1 || uiY2 <= uiY1) {
      promptAction.showToast({ message: 'è£å‰ªåŒºåŸŸè¶…å‡ºå›¾ç‰‡èŒƒå›´' })
      this.cropMode = false
      return
    }

    // === 3. UI åæ ‡æ˜ å°„åˆ°åƒç´ åæ ‡ ===
    const px1Float: number = (uiX1 - imageLeft) * (imgW / realW)
    const py1Float: number = (uiY1 - imageTop) * (imgH / realH)
    const px2Float: number = (uiX2 - imageLeft) * (imgW / realW)
    const py2Float: number = (uiY2 - imageTop) * (imgH / realH)

    const cropX: number = Math.max(0, Math.floor(px1Float))
    const cropY: number = Math.max(0, Math.floor(py1Float))
    const cropW: number = Math.floor(px2Float - px1Float)
    const cropH: number = Math.floor(py2Float - py1Float)

    if (cropW <= 0 || cropH <= 0) {
      promptAction.showToast({ message: 'è£å‰ªåŒºåŸŸå¤ªå°' })
      this.cropMode = false
      return
    }

    // ========= 4. çœŸæ­£è£å‰ªï¼ˆåº•å›¾ + ç»˜åˆ¶å±‚ï¼‰ï¼Œå¹¶è®°å½•æ’¤é”€ =========

    // 4.1 è£å‰ªå‰å¤‡ä»½ä¸€ä»½å®Œæ•´åº•å›¾ï¼ˆç”¨äºæ’¤é”€ï¼‰
    const backupPm: image.PixelMap = await this.clonePixelMap(pm)
    await this.pushHistorySnapshot(true, backupPm)

    // 4.2 åœ¨å½“å‰ pixelMap ä¸ŠåŸåœ°è£å‰ªï¼ˆå¼•ç”¨ä¸å˜ï¼‰
    await pm.crop({
      x: cropX,
      y: cropY,
      size: { width: cropW, height: cropH }
    })

    // 4.3 è‹¥å­˜åœ¨ç»˜åˆ¶å›¾å±‚ï¼ŒåŒæ­¥è£å‰ªåŒä¸€åŒºåŸŸï¼Œä¿è¯å°ºå¯¸å¯¹é½
    if (this.drawPixelMap) {
      const overlayPm: image.PixelMap = this.drawPixelMap as image.PixelMap
      try {
        await overlayPm.crop({
          x: cropX,
          y: cropY,
          size: { width: cropW, height: cropH }
        })
        this.drawPixelVersion++
      } catch (e) {
        const err: Error = e as Error
        console.warn(`crop drawPixelMap failed: ${err.message}`)
      }
    }

    // ========= 5. æ¸©å’Œè°ƒæ•´ç”»ç¬”ç²—ç»†ï¼ˆé¿å…ä¸€æ¬¡è£å‰ªå˜åŒ–è¿‡çŒ›ï¼‰ =========

    // æ—§å¯¹è§’çº¿ï¼šä¼˜å…ˆç”¨ imageDiagï¼ˆå¦‚æœä½ åœ¨æ‰“å¼€å›¾ç‰‡æˆ– reset æ—¶æœ‰è®¾ç½®ï¼‰
    const oldDiag: number = this.imageDiag > 0
      ? this.imageDiag
      : Math.sqrt(imgW * imgW + imgH * imgH)

    const newDiag: number = Math.sqrt(cropW * cropW + cropH * cropH)

    if (oldDiag > 0 && newDiag > 0) {
      const rawRatio: number = newDiag / oldDiag // <1 è¡¨ç¤ºå›¾å˜å°

      // è¿™é‡Œæ˜¯â€œæ¸©å’Œç¼©æ”¾â€ï¼š
      // - ä¸æ”¾å¤§ç”»ç¬”ï¼šratio æœ€å¤§ 1.0
      // - æ¯æ¬¡æœ€å¤šç¼©å°åˆ° 80%ï¼šratio æœ€å° 0.8
      let ratio: number = rawRatio
      if (ratio > 1.0) {
        ratio = 1.0
      }
      if (ratio < 0.8) {
        ratio = 0.8
      }

      // åº”ç”¨ç¼©æ”¾ï¼Œæœ€ä½ä¸å°äº 1 åƒç´ 
      this.strokeWidth = Math.max(1, this.strokeWidth * ratio)

      // æ›´æ–°å½“å‰å›¾ç‰‡å¯¹è§’çº¿ï¼Œä½œä¸ºä¸‹ä¸€æ¬¡è£å‰ªçš„åŸºå‡†
      this.imageDiag = newDiag
    } else {
      // å…œåº•ï¼šæ— æ³•è®¡ç®—æ—¶ï¼Œåªè®°å½•æ–°å¯¹è§’çº¿ï¼Œä¸è°ƒæ•´ç”»ç¬”
      this.imageDiag = newDiag
    }

    // ========= 6. æ”¶å°¾ï¼šå¤ä½è§†å›¾ / æ¸…ç†çŠ¶æ€ =========
    this.cropMode = false
    this.zoom = 1.0
    this.offsetX = 0
    this.offsetY = 0
    this.pixelVersion++

    this.cropStartX = 0
    this.cropStartY = 0
    this.cropEndX = 0
    this.cropEndY = 0

    promptAction.showToast({ message: 'è£å‰ªå®Œæˆ' })
  }

  private async rotateRight90(): Promise<void> {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }
    if (this.isRotating) {
      return
    }

    await this.pushHistorySnapshot(false)

    this.isRotating = true
    try {
      // â‘  æ—‹è½¬åº•å›¾
      await (this.pixelMap as image.PixelMap).rotate(90)

      // â‘¡ è‹¥æœ‰ç»˜åˆ¶å±‚ï¼Œä¹Ÿä¸€èµ·æ—‹è½¬ï¼ˆå…³é”®ï¼‰
      if (this.drawPixelMap) {
        await (this.drawPixelMap as image.PixelMap).rotate(90)
        this.drawPixelVersion++
      }

      // â‘¢ æ›´æ–°ç´¯è®¡è§’åº¦
      this.accumulatedRotate = (this.accumulatedRotate + 90) % 360

      this.pixelVersion++
    } catch (err) {
      const e = err as Error
      console.error(`rotateRight90 failed: ${e.message}`)
      promptAction.showToast({ message: 'å³æ—‹å¤±è´¥' })
    } finally {
      this.isRotating = false
    }
  }

  // å‘å·¦æ—‹è½¬ 90 åº¦ï¼ˆé€†æ—¶é’ˆï¼‰
  private async rotateLeft90(): Promise<void> {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }
    if (this.isRotating) {
      return
    }

    await this.pushHistorySnapshot(false)

    this.isRotating = true
    try {
      // â‘  åº•å›¾æ—‹è½¬
      await (this.pixelMap as image.PixelMap).rotate(270)

      // â‘¡ ç»˜åˆ¶å›¾å±‚åŒæ­¥æ—‹è½¬
      if (this.drawPixelMap) {
        await (this.drawPixelMap as image.PixelMap).rotate(270)
        this.drawPixelVersion++
      }

      // â‘¢ æ›´æ–°ç´¯è®¡è§’åº¦
      this.accumulatedRotate = (this.accumulatedRotate + 270) % 360

      this.pixelVersion++
    } catch (err) {
      const e = err as Error
      console.error(`rotateLeft90 failed: ${e.message}`)
      promptAction.showToast({ message: 'å·¦æ—‹å¤±è´¥' })
    } finally {
      this.isRotating = false
    }
  }

  // äº®åº¦è°ƒæ•´
  private async adjustBrightness(delta: number) {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }

    // è®°å½•å½“å‰äº®åº¦/å¯¹æ¯”åº¦å‚æ•°ï¼ˆä¸æ‹·è´åƒç´ ï¼‰
    await this.pushHistorySnapshot(false)

    // brightnessLevel å–ä¸€ä¸ªç›¸å¯¹æ¸©å’Œçš„åŒºé—´ï¼Œé˜²æ­¢å´©å
    this.brightnessLevel += delta

    const MAX_LEVEL: number = 0.5 // å¤§çº¦ +128
    const MIN_LEVEL: number = -0.5 // å¤§çº¦ -128

    if (this.brightnessLevel > MAX_LEVEL) {
      this.brightnessLevel = MAX_LEVEL
    }
    if (this.brightnessLevel < MIN_LEVEL) {
      this.brightnessLevel = MIN_LEVEL
    }
  }

  // æ„å»ºäº®åº¦ + å¯¹æ¯”åº¦çŸ©é˜µ
  private buildToneMatrix(): Array<number> {
    // äº®åº¦ï¼ˆå»ºè®®èŒƒå›´ [-0.5, 0.5]ï¼‰
    const b: number = this.brightnessLevel

    // å¯¹æ¯”åº¦ç³»æ•° cï¼šcontrastLevel âˆˆ [-1,1] å¯¹åº” c âˆˆ [0,2]
    const c: number = 1.0 + this.contrastLevel

    // ä¸ºäº†è®©â€œä¿æŒä¸­å¿ƒç‚¹ä¸å˜â€ï¼Œéœ€è¦é¢å¤–çš„åç§»é¡¹
    // åœ¨å½’ä¸€åŒ–[0,1]ç©ºé—´é‡Œï¼Œä¸­ç‚¹æ˜¯ 0.5ï¼š
    // new = (old - 0.5) * c + 0.5 + b
    //     = c * old + (0.5 * (1 - c) + b)
    const offset: number = 0.5 * (1.0 - c) + b

    return [
      c, 0, 0, 0, offset,
      0, c, 0, 0, offset,
      0, 0, c, 0, offset,
      0, 0, 0, 1, 0
    ]
  }

  // æŠŠå½“å‰ brightnessLevel & contrastLevel ä¸€èµ·çƒ˜ç„™åˆ° pixelMap é‡Œ
  // æ³¨æ„ï¼šè°ƒç”¨åä¼šæŠŠ brightnessLevel / contrastLevel å½’é›¶ï¼Œå¹¶è§¦å‘ä¸€æ¬¡åˆ·æ–°
  private async bakeToneToPixelMap(pm: image.PixelMap): Promise<void> {
    // æ²¡æœ‰è°ƒæ•´äº®åº¦å’Œå¯¹æ¯”åº¦å°±ä¸ç”¨åŠ¨åƒç´ ï¼Œç›´æ¥è¿”å›
    if (this.brightnessLevel === 0 && this.contrastLevel === 0) {
      return
    }

    // è¯»å‡ºåƒç´ æ•°æ®
    const info: image.ImageInfo = await pm.getImageInfo()
    const byteLength: number = pm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await pm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // åˆ¤æ–­é€šé“é¡ºåºï¼Œé˜²æ­¢é¢œè‰²é”™ä¹±
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        // B G R A
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        // A R G B
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
      // R G B A
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    // å¯¹æ¯”åº¦ç³»æ•° cï¼ˆ0~2ï¼‰ï¼Œäº®åº¦åç§» *255
    const c: number = 1.0 + this.contrastLevel
    const shiftBrightness: number = this.brightnessLevel * 255.0
    // æŠŠå…¬å¼ new = (old - 128)*c + 128 + shiftBrightness å±•å¼€ï¼š
    const shiftTotal: number = 128.0 * (1.0 - c) + shiftBrightness

    const clamp = (v: number): number => {
      if (v < 0) {
        return 0
      }
      if (v > 255) {
        return 255
      }
      return v
    }

    // éå†ä¸€æ¬¡åƒç´ ï¼ŒçœŸæ­£æ”¹æ‰ R/G/B é€šé“
    for (let i: number = 0; i < data.length; i += 4) {
      const rIndex: number = i + rOffset
      const gIndex: number = i + gOffset
      const bIndex: number = i + bOffset
      const aIndex: number = i + aOffset

      const r = data[rIndex]
      const g = data[gIndex]
      const b = data[bIndex]

      data[rIndex] = clamp(c * r + shiftTotal)
      data[gIndex] = clamp(c * g + shiftTotal)
      data[bIndex] = clamp(c * b + shiftTotal)
      // alpha åŸæ ·ä¿æŒ
      data[aIndex] = data[aIndex]
    }

    // æŠŠä¿®æ”¹åçš„åƒç´ å†™å› pixelMap
    await pm.writeBufferToPixels(buffer)

    // æŠŠçŠ¶æ€å½’é›¶ï¼šæ­¤æ—¶åº•å±‚åƒç´ å·²ç»æ˜¯â€œæ–°äº®åº¦ + æ–°å¯¹æ¯”åº¦â€
    // å†æŠŠ colorFilter çš„å‚æ•°è®¾å› 0ï¼Œè§†è§‰æ•ˆæœä¿æŒä¸å˜ï¼ˆä¸ä¼šå åŠ ä¸¤æ¬¡ï¼‰
    this.brightnessLevel = 0.0
    this.contrastLevel = 0.0
    this.pixelVersion++ // è§¦å‘ Image é‡æ–°æ¸²æŸ“ä¸€æ¬¡
  }

  // å¯¹æ¯”åº¦è°ƒæ•´
  private async adjustContrast(delta: number) {
    if (!this.pixelMap) {
      promptAction.showToast({ message: 'è¯·å…ˆæ‰“å¼€å›¾ç‰‡' })
      return
    }

    // è®°å½•å½“å‰äº®åº¦/å¯¹æ¯”åº¦å‚æ•°ï¼ˆä¸æ‹·è´åƒç´ ï¼‰
    await this.pushHistorySnapshot(false)

    this.contrastLevel += delta

    const MAX_CONTRAST: number = 1.0 // å¯¹æ¯”åº¦å¢å¼ºä¸Šé™
    const MIN_CONTRAST: number = -1.0 // å¯¹æ¯”åº¦é™ä½ä¸‹é™

    if (this.contrastLevel > MAX_CONTRAST) {
      this.contrastLevel = MAX_CONTRAST
    }
    if (this.contrastLevel < MIN_CONTRAST) {
      this.contrastLevel = MIN_CONTRAST
    }
  }

  private onClickTopMenu(menu: TopMenu) {
    // å†æ¬¡ç‚¹å‡»åŒä¸€ä¸ªæŒ‰é’®æ—¶æ”¶èµ·èœå•
    if (this.activeMenu === menu) {
      this.activeMenu = TopMenu.None
    } else {
      this.activeMenu = menu
    }
  }

  private selectShape(shape: ShapeTool) {
    this.currentShape = shape

    // å¦‚æœä¹‹å‰æ˜¯æ©¡çš®æ“¦ï¼Œåˆ‡æ¢å½¢çŠ¶æ—¶è‡ªåŠ¨æ¢å¤ä¸ºæ™®é€šç”»ç¬”
    if (this.currentBrush === BrushTool.Eraser) {
      this.currentBrush = BrushTool.Pen
    }
  }

  private selectBrush(brush: BrushTool) {
    // å…ˆåªè®°å½•å½“å‰ç”»ç¬”
    this.currentBrush = brush
  }

  private async undo() {
    if (this.historyIndex < 0 || this.history.length === 0) {
      promptAction.showToast({ message: 'æ²¡æœ‰å¯ä»¥æ’¤é”€çš„æ“ä½œ' })
      return
    }

    const snapshot: CanvasSnapshot = this.history[this.historyIndex]
    this.historyIndex--

    // === æƒ…å†µ 1ï¼šæœ‰ pixelMap å¿«ç…§ï¼ˆå¦‚è£å‰ªï¼‰ ===
    if (snapshot.pixelMap) {
      // æŠŠ snapshot.pixelMap å…‹éš†æˆå¯ç¼–è¾‘ç‰ˆæœ¬
      const newPm = await this.clonePixelMap(snapshot.pixelMap)

      // é‡Šæ”¾å½“å‰ pixelMapï¼ˆä¸ç­‰äº snapshot.pixelMapï¼‰
      if (this.pixelMap && this.pixelMap !== snapshot.pixelMap) {
        (this.pixelMap as image.PixelMap).release?.()
      }

      // åˆ‡æ¢åˆ°æ–°çš„ editable PixelMap
      this.pixelMap = newPm
    }

    // === æƒ…å†µ 2ï¼šæ—‹è½¬ / äº®åº¦ / å¯¹æ¯”åº¦ï¼ˆæ—  pixelMapï¼‰===
    else if (this.pixelMap) {
      const currentAngle = this.accumulatedRotate
      const targetAngle = snapshot.accumulatedRotate

      const diff = (360 + targetAngle - currentAngle) % 360
      if (diff === 90 || diff === 180 || diff === 270) {
        try {
          await (this.pixelMap as image.PixelMap).rotate(diff)
        } catch (err) {
          console.error(`undo rotateBack failed: ${JSON.stringify(err)}`)
        }
      }
    }

    // â­ æ–°å¢ï¼šæ¢å¤ç»˜åˆ¶å›¾å±‚ï¼ˆdrawPixelMapï¼‰
    if (snapshot.drawPixelMap) {
      const newDraw = await this.clonePixelMap(snapshot.drawPixelMap)

      if (this.drawPixelMap && this.drawPixelMap !== snapshot.drawPixelMap) {
        this.drawPixelMap.release?.()
      }
      this.drawPixelMap = newDraw
      this.drawPixelVersion++ // è®© Image(drawPixelMap) ä¹Ÿåˆ·æ–°
    } else {
      // è¿™ä¸€æ­¥è¡¨ç¤ºå½“æ—¶æ²¡æœ‰ç»˜åˆ¶å±‚å¿«ç…§ â†’ æ’¤é”€åˆ°ä¸€ä¸ªâ€œæ²¡æœ‰ç»˜åˆ¶å±‚â€çš„çŠ¶æ€
      if (this.drawPixelMap) {
        this.drawPixelMap.release?.()
        this.drawPixelMap = undefined
        this.drawPixelVersion++
      }
    }

    // === æ¢å¤å…¶ä»–çŠ¶æ€ï¼ˆç¼©æ”¾/å¹³ç§»/äº®åº¦/å¯¹æ¯”åº¦ç­‰ï¼‰ ===
    this.zoom = snapshot.zoom
    this.offsetX = snapshot.offsetX
    this.offsetY = snapshot.offsetY
    this.brightnessLevel = snapshot.brightnessLevel
    this.contrastLevel = snapshot.contrastLevel
    this.accumulatedRotate = snapshot.accumulatedRotate

    this.pixelVersion++
  }

  // åœ¨ã€Œç»˜åˆ¶å›¾å±‚ã€ä¸Šç”»ä¸€ä¸ªç‚¹ï¼ˆuiX/uiY æ˜¯ç”»å¸ƒä¸Šçš„ç‚¹å‡»åæ ‡ï¼‰
  private async drawPointAtUi(uiX: number, uiY: number) {
    if (!this.pixelMap) {
      return
    }

    await this.pushHistorySnapshot(false)

    // 1. ç”»å¸ƒå°ºå¯¸é˜²å¾¡
    if (this.canvasWidth <= 0 || this.canvasHeight <= 0) {
      console.info('>>> drawPointAtUi: canvas size is 0, skip')
      return
    }

    // 2. å¿…é¡»å·²ç»æœ‰ç»˜åˆ¶å›¾å±‚ï¼ˆåœ¨ pickImage é‡Œåˆ›å»ºï¼‰
    if (!this.drawPixelMap) {
      promptAction.showToast({ message: 'ç»˜åˆ¶å›¾å±‚ä¸å­˜åœ¨ï¼Œè¯·é‡æ–°æ‰“å¼€å›¾ç‰‡' })
      return
    }

    const basePm = this.pixelMap as image.PixelMap
    const baseInfo: image.ImageInfo = await basePm.getImageInfo()

    const imgW: number = baseInfo.size.width
    const imgH: number = baseInfo.size.height

    // ===== 1) UI -> åƒç´  åæ ‡æ˜ å°„ =====
    const scaleBase: number = Math.min(
      this.canvasWidth / imgW,
      this.canvasHeight / imgH
    )

    if (scaleBase <= 0) {
      console.info('>>> drawPointAtUi: scaleBase <= 0, skip')
      return
    }

    const realW: number = imgW * scaleBase * this.zoom
    const realH: number = imgH * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const pxFloat: number = (uiX - imageLeft) * (imgW / realW)
    const pyFloat: number = (uiY - imageTop) * (imgH / realH)

    const px: number = Math.floor(pxFloat)
    const py: number = Math.floor(pyFloat)

    console.info(`>>> drawPointAtUi: ui=(${uiX.toFixed(1)}, ${uiY.toFixed(1)}) -> pixel=(${px}, ${py})`)

    if (px < 0 || py < 0 || px >= imgW || py >= imgH) {
      // ç‚¹å‡»åœ¨å›¾ç‰‡å¤–é¢ï¼Œç›´æ¥ä¸¢å¼ƒ
      return
    }

    // ===== 2) åœ¨ã€Œç»˜åˆ¶å›¾å±‚ã€ä¸Šæ”¹åƒç´  =====
    const layerPm: image.PixelMap = this.drawPixelMap as image.PixelMap
    const info: image.ImageInfo = await layerPm.getImageInfo()
    const width: number = info.size.width
    const height: number = info.size.height

    if (px < 0 || py < 0 || px >= width || py >= height) {
      console.info('>>> drawPointAtUi: pixel out of layer range')
      return
    }

    const byteLength: number = layerPm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await layerPm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // é€šé“é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    // imgW / imgH å‰é¢å·²ç»ç®—è¿‡
    const radius: number = this.computeStrokeRadiusPixel(imgW, imgH)
    const alpha: number = this.getStrokeAlpha()

    for (let yy: number = py - radius; yy <= py + radius; yy++) {
      if (yy < 0 || yy >= height) {
        continue
      }
      for (let xx: number = px - radius; xx <= px + radius; xx++) {
        if (xx < 0 || xx >= width) {
          continue
        }

        const dx: number = xx - px
        const dy: number = yy - py
        if (dx * dx + dy * dy > radius * radius) {
          continue
        }

        const baseIndex: number = (yy * width + xx) * 4
        const rIndex: number = baseIndex + rOffset
        const gIndex: number = baseIndex + gOffset
        const bIndex: number = baseIndex + bOffset
        const aIndex: number = baseIndex + aOffset

        if (this.currentBrush === BrushTool.Eraser) {
          // æ©¡çš®æ“¦ï¼šåªæ“¦æ‰ç»˜åˆ¶å±‚çš„ alpha
          data[aIndex] = 0
        } else {
          data[rIndex] = this.strokeR
          data[gIndex] = this.strokeG
          data[bIndex] = this.strokeB
          data[aIndex] = alpha
        }
      }
    }

    // ===== 3) å†™å› + æ¢ä¸€ä¸ªæ–°çš„ PixelMap å¼•ç”¨ï¼Œå¼ºåˆ¶ UI åˆ·æ–° =====
    await layerPm.writeBufferToPixels(buffer)

    // å’Œä½ å¯¹ä¸»å›¾çš„åšæ³•ä¿æŒä¸€è‡´ï¼šclone ä¸€ä»½æ–°çš„ï¼Œèµ‹ç»™ @State
    const newLayer: image.PixelMap = await this.clonePixelMap(layerPm)
    // æ—§çš„å›¾å±‚å¯ä»¥é‡Šæ”¾ï¼ˆå¯é€‰ï¼‰
    if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
      this.drawPixelMap.release?.()
    }
    this.drawPixelMap = newLayer

    console.info(`>>> draw layer created: size=${(await this.drawPixelMap!.getImageInfo()).size.width}x${(await this.drawPixelMap!.getImageInfo()).size.height}`)


    this.drawPixelVersion++ // id(`draw-${drawPixelVersion}`) ä¹Ÿä¸€èµ·å˜
  }

  // ç›´çº¿å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œåœ¨è¿™é‡Œè½¬æ¢æˆåƒç´ å¹¶ç”»çº¿
  // ç›´çº¿å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œåœ¨è¿™é‡Œè½¬æ¢æˆåƒç´ å¹¶åœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»çº¿
  private async handleLineDrag(startUiX: number, startUiY: number, endUiX: number, endUiY: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    const pm: image.PixelMap = this.pixelMap as image.PixelMap
    const info: image.ImageInfo = await pm.getImageInfo()

    // â€”â€” UI â†’ åƒç´ ï¼ˆå’Œç”»ç‚¹å®Œå…¨ä¸€è‡´çš„æ˜ å°„é€»è¾‘ï¼‰â€”â€”
    const scaleBase: number = Math.min(
      this.canvasWidth / info.size.width,
      this.canvasHeight / info.size.height
    )

    const realW: number = info.size.width * scaleBase * this.zoom
    const realH: number = info.size.height * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const startPxFloat: number = (startUiX - imageLeft) * (info.size.width / realW)
    const startPyFloat: number = (startUiY - imageTop) * (info.size.height / realH)
    const endPxFloat: number = (endUiX - imageLeft) * (info.size.width / realW)
    const endPyFloat: number = (endUiY - imageTop) * (info.size.height / realH)

    const x0: number = Math.floor(startPxFloat)
    const y0: number = Math.floor(startPyFloat)
    const x1: number = Math.floor(endPxFloat)
    const y1: number = Math.floor(endPyFloat)

    console.info(
      `>>> handleLineDrag uiStart=(${startUiX.toFixed(1)},${startUiY.toFixed(1)}), ` +
        `uiEnd=(${endUiX.toFixed(1)},${endUiY.toFixed(1)}) -> ` +
        `pixelStart=(${x0},${y0}), pixelEnd=(${x1},${y1}), imgSize=(${info.size.width},${info.size.height})`
    )

    // å°è¯•ç¡®ä¿æœ‰ç»˜åˆ¶å›¾å±‚ï¼ˆè¿™é‡Œä¸ç›´æ¥ç”¨è¿”å›å€¼ï¼Œåªåšå­˜åœ¨æ€§æ£€æŸ¥ï¼‰
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      return
    }

    // äº¤ç»™ä¸“é—¨å‡½æ•°åœ¨â€œç»˜åˆ¶å›¾å±‚â€ä¸Šç”»çº¿
    await this.drawLineBetweenPixels(x0, y0, x1, y1)

    promptAction.showToast({ message: 'ç›´çº¿å·²ç»˜åˆ¶' })
  }

  // åœ¨ç»˜åˆ¶å›¾å±‚ drawPixelMap ä¸Šç”»ä¸€æ¡â€œå¸¦ç²—ç»†çš„ç›´çº¿â€
  private async drawLineBetweenPixels(x0: number, y0: number, x1: number, y1: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    // â­ å’Œç”»ç‚¹ä¸€æ ·ï¼Œå…ˆè®°å½•ä¸€æ¬¡å†å²å¿«ç…§ï¼ˆåªè®°å½•çŠ¶æ€ + ç»˜åˆ¶å±‚ï¼‰
    await this.pushHistorySnapshot(false)

    // 1. ç”¨åº•å›¾åšä¸€æ¬¡å°ºå¯¸è¾¹ç•Œæ£€æŸ¥ï¼ˆæ­£å¸¸å’Œç»˜åˆ¶å±‚ä¸€è‡´ï¼‰
    const basePm: image.PixelMap = this.pixelMap as image.PixelMap
    const baseInfo: image.ImageInfo = await basePm.getImageInfo()
    const baseW: number = baseInfo.size.width
    const baseH: number = baseInfo.size.height

    if (
      x0 < 0 || y0 < 0 || x0 >= baseW || y0 >= baseH ||
        x1 < 0 || y1 < 0 || x1 >= baseW || y1 >= baseH
    ) {
      console.info('>>> drawLineBetweenPixels: endpoints out of base range, skip')
      return
    }

    // 2. åªåœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»çº¿
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      return
    }

    const info: image.ImageInfo = await layerPm.getImageInfo()
    const width: number = info.size.width
    const height: number = info.size.height

    if (
      x0 < 0 || y0 < 0 || x0 >= width || y0 >= height ||
        x1 < 0 || y1 < 0 || x1 >= width || y1 >= height
    ) {
      console.info('>>> drawLineBetweenPixels: endpoints out of layer range, skip')
      return
    }

    // 3. è¯»å–ç»˜åˆ¶å±‚åƒç´ 
    const byteLength: number = layerPm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await layerPm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // 4. é€šé“é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const radius: number = this.computeStrokeRadiusPixel(width, height)
    const alpha: number = this.getStrokeAlpha()

    const drawThickPoint = (cx: number, cy: number): void => {
      for (let yy: number = cy - radius; yy <= cy + radius; yy++) {
        if (yy < 0 || yy >= height) {
          continue
        }
        for (let xx: number = cx - radius; xx <= cx + radius; xx++) {
          if (xx < 0 || xx >= width) {
            continue
          }

          const dx: number = xx - cx
          const dy: number = yy - cy
          if (dx * dx + dy * dy > radius * radius) {
            continue
          }

          const baseIndex: number = (yy * width + xx) * 4
          const rIndex: number = baseIndex + rOffset
          const gIndex: number = baseIndex + gOffset
          const bIndex: number = baseIndex + bOffset
          const aIndex: number = baseIndex + aOffset

          if (this.currentBrush === BrushTool.Eraser) {
            // æ©¡çš®æ“¦ï¼šåªæ“¦ç»˜åˆ¶å±‚ï¼Œå˜æˆé€æ˜
            data[aIndex] = 0
          } else {
            data[rIndex] = this.strokeR
            data[gIndex] = this.strokeG
            data[bIndex] = this.strokeB
            data[aIndex] = alpha
          }
        }
      }
    }

    // 5. Bresenham ç”»çº¿
    let curX: number = x0
    let curY: number = y0
    const dx: number = Math.abs(x1 - x0)
    const sx: number = x0 < x1 ? 1 : -1
    const dy: number = -Math.abs(y1 - y0)
    const sy: number = y0 < y1 ? 1 : -1
    let err: number = dx + dy

    // eslint-disable-next-line no-constant-condition
    while (true) {
      drawThickPoint(curX, curY)

      if (curX === x1 && curY === y1) {
        break
      }

      const e2: number = 2 * err
      if (e2 >= dy) {
        err += dy
        curX += sx
      }
      if (e2 <= dx) {
        err += dx
        curY += sy
      }
    }

    // 6. å†™å›ç»˜åˆ¶å±‚åƒç´ 
    await layerPm.writeBufferToPixels(buffer)

    // â­ å…³é”®ï¼šå’Œç”»ç‚¹ä¸€æ ·ï¼Œclone ä¸€å¼ æ–°çš„å›¾å±‚ï¼Œæ¢å¼•ç”¨ï¼Œå¼ºåˆ¶ UI åˆ·æ–°
    const newLayer: image.PixelMap = await this.clonePixelMap(layerPm)

    if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
      this.drawPixelMap.release?.()
    }
    this.drawPixelMap = newLayer

    this.drawPixelVersion++ // id("draw-xxx") å˜åŒ–ï¼Œå åŠ å±‚ Image ä¼šé‡å»º

    console.info(`>>> drawLineBetweenPixels: line drawn, drawPixelVersion=${this.drawPixelVersion}`)
  }

  // çŸ©å½¢å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œåœ¨è¿™é‡Œè½¬æˆåƒç´ å¹¶ç”»çŸ©å½¢
  private async handleRectDrag(startUiX: number, startUiY: number, endUiX: number, endUiY: number) {
    if (!this.pixelMap) {
      return
    }

    const pm = this.pixelMap as image.PixelMap
    const info: image.ImageInfo = await pm.getImageInfo()

    // â€”â€” UI â†’ åƒç´ ï¼ˆå’Œç”»ç‚¹ / ç”»ç›´çº¿ä¿æŒå®Œå…¨ä¸€è‡´çš„æ˜ å°„é€»è¾‘ï¼‰â€”â€”
    const scaleBase: number = Math.min(
      this.canvasWidth / info.size.width,
      this.canvasHeight / info.size.height
    )

    const realW: number = info.size.width * scaleBase * this.zoom
    const realH: number = info.size.height * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const startPxFloat: number = (startUiX - imageLeft) * (info.size.width / realW)
    const startPyFloat: number = (startUiY - imageTop) * (info.size.height / realH)
    const endPxFloat: number = (endUiX - imageLeft) * (info.size.width / realW)
    const endPyFloat: number = (endUiY - imageTop) * (info.size.height / realH)

    const x0: number = Math.floor(startPxFloat)
    const y0: number = Math.floor(startPyFloat)
    const x1: number = Math.floor(endPxFloat)
    const y1: number = Math.floor(endPyFloat)

    console.info(
      `>>> handleRectDrag uiStart=(${startUiX.toFixed(1)},${startUiY.toFixed(1)}), ` +
        `uiEnd=(${endUiX.toFixed(1)},${endUiY.toFixed(1)}) -> ` +
        `pixelStart=(${x0},${y0}), pixelEnd=(${x1},${y1}), imgSize=(${info.size.width},${info.size.height})`
    )

    // è¿™é‡Œä¸å¼ºåˆ¶è¦æ±‚å®Œå…¨åœ¨å›¾å†…ï¼ŒçœŸæ­£çš„è¾¹ç•Œè£å‰ªäº¤ç»™ drawRectBetweenPixels å»åš

    // 1ï¼‰ä¿®æ”¹å‰å…ˆæŠŠå½“å‰æ•´å›¾å‹å…¥æ’¤é”€æ ˆï¼ˆå¯æ’¤å›ï¼‰
    // 1ï¼‰ä¿®æ”¹å‰ï¼šåªè®°å½•çŠ¶æ€ + ç»˜åˆ¶å±‚å¿«ç…§ï¼ˆåº•å›¾ä¸åŠ¨ï¼‰
    await this.pushHistorySnapshot(false)

    // 2ï¼‰åœ¨ç»˜åˆ¶å±‚ä¸Šç”»çŸ©å½¢
    await this.drawRectBetweenPixels(x0, y0, x1, y1)

    promptAction.showToast({ message: 'çŸ©å½¢å·²ç»˜åˆ¶' })
  }

  // åœ¨åƒç´ åæ ‡é‡Œç”»ä¸€ä¸ªçŸ©å½¢è¾¹æ¡†ï¼ˆä½¿ç”¨å½“å‰ stroke å®½åº¦å’Œé¢œè‰²ï¼‰
  // åœ¨ç»˜åˆ¶å›¾å±‚ drawPixelMap ä¸Šç”»ä¸€ä¸ªçŸ©å½¢è¾¹æ¡†ï¼ˆä½¿ç”¨å½“å‰ stroke å®½åº¦å’Œé¢œè‰²ï¼‰
  private async drawRectBetweenPixels(x0: number, y0: number, x1: number, y1: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    // 1ï¼‰å…ˆç”¨åº•å›¾åšä¸€æ¬¡å°ºå¯¸è¾¹ç•Œæ£€æŸ¥
    const basePm: image.PixelMap = this.pixelMap as image.PixelMap
    const baseInfo: image.ImageInfo = await basePm.getImageInfo()
    const baseW: number = baseInfo.size.width
    const baseH: number = baseInfo.size.height

    // å½’ä¸€åŒ–æˆå·¦ä¸Š / å³ä¸‹
    let left: number = Math.min(x0, x1)
    let right: number = Math.max(x0, x1)
    let top: number = Math.min(y0, y1)
    let bottom: number = Math.max(y0, y1)

    // è£å‰ªåœ¨å›¾ç‰‡èŒƒå›´ä¹‹å†…ï¼ˆç”¨åº•å›¾å°ºå¯¸ï¼‰
    left = Math.max(0, left)
    right = Math.min(baseW - 1, right)
    top = Math.max(0, top)
    bottom = Math.min(baseH - 1, bottom)

    if (left >= right || top >= bottom) {
      console.info('>>> drawRectBetweenPixels: rect too small, skip')
      return
    }

    // 2ï¼‰åªåœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»çŸ©å½¢
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      return
    }

    const info: image.ImageInfo = await layerPm.getImageInfo()
    const width: number = info.size.width
    const height: number = info.size.height

    // 3ï¼‰è¯»ç»˜åˆ¶å±‚çš„åƒç´ 
    const byteLength: number = layerPm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await layerPm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // 4ï¼‰ç¡®å®šé€šé“é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const radius: number = this.computeStrokeRadiusPixel(width, height)
    const alpha: number = this.getStrokeAlpha()

    const drawThickPoint = (cx: number, cy: number): void => {
      for (let yy: number = cy - radius; yy <= cy + radius; yy++) {
        if (yy < 0 || yy >= height) {
          continue
        }
        for (let xx: number = cx - radius; xx <= cx + radius; xx++) {
          if (xx < 0 || xx >= width) {
            continue
          }

          const dx: number = xx - cx
          const dy: number = yy - cy
          if (dx * dx + dy * dy > radius * radius) {
            continue
          }

          const baseIndex: number = (yy * width + xx) * 4
          const rIndex: number = baseIndex + rOffset
          const gIndex: number = baseIndex + gOffset
          const bIndex: number = baseIndex + bOffset
          const aIndex: number = baseIndex + aOffset

          if (this.currentBrush === BrushTool.Eraser) {
            // æ©¡çš®æ“¦ï¼šåªæ“¦ç»˜åˆ¶å±‚çš„ alpha
            data[aIndex] = 0
          } else {
            data[rIndex] = this.strokeR
            data[gIndex] = this.strokeG
            data[bIndex] = this.strokeB
            data[aIndex] = alpha
          }
        }
      }
    }

    // 5ï¼‰ç”»å››æ¡è¾¹ï¼šä¸Šã€ä¸‹ã€å·¦ã€å³
    for (let x: number = left; x <= right; x++) {
      drawThickPoint(x, top) // ä¸Šè¾¹
      drawThickPoint(x, bottom) // ä¸‹è¾¹
    }
    for (let y: number = top; y <= bottom; y++) {
      drawThickPoint(left, y) // å·¦è¾¹
      drawThickPoint(right, y) // å³è¾¹
    }

    // 6ï¼‰å†™å›ç»˜åˆ¶å±‚åƒç´ 
    await layerPm.writeBufferToPixels(buffer)

    // 7ï¼‰clone ä¸€ä»½æ–°çš„ç»˜åˆ¶å±‚ï¼Œæ¢å¼•ç”¨ï¼Œå¼ºåˆ¶ UI åˆ·æ–°
    const newLayer: image.PixelMap = await this.clonePixelMap(layerPm)
    if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
      this.drawPixelMap.release?.()
    }
    this.drawPixelMap = newLayer
    this.drawPixelVersion++ // è§¦å‘ Image(drawPixelMap) é‡å»º

    console.info(`>>> drawRectBetweenPixels: rect drawn, drawPixelVersion=${this.drawPixelVersion}`)
  }

  // åœ¨åƒç´ åæ ‡é‡Œç”»ä¸€ä¸ªåœ†å½¢è¾¹æ¡†ï¼ˆä½¿ç”¨å½“å‰ stroke å®½åº¦å’Œé¢œè‰²ï¼‰
  // è¿™é‡Œä¼ å…¥çš„æ˜¯åœ†çš„å¤–æ¥æ­£æ–¹å½¢çš„å·¦ä¸Š / å³ä¸‹
  // è¿™é‡Œä¼ å…¥çš„æ˜¯åœ†çš„å¤–æ¥æ­£æ–¹å½¢çš„å·¦ä¸Š / å³ä¸‹ï¼Œåœ¨â€œç»˜åˆ¶å›¾å±‚â€ä¸Šç”»åœ†
  private async drawCircleBetweenPixels(left: number, top: number, right: number, bottom: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    // ç”¨åº•å›¾åšä¸€æ¬¡è¾¹ç•Œè£å‰ªï¼ˆå°ºå¯¸ä¸ç»˜åˆ¶å±‚ä¸€è‡´ï¼‰
    const basePm: image.PixelMap = this.pixelMap as image.PixelMap
    const baseInfo: image.ImageInfo = await basePm.getImageInfo()
    const baseW: number = baseInfo.size.width
    const baseH: number = baseInfo.size.height

    left = Math.max(0, left)
    right = Math.min(baseW - 1, right)
    top = Math.max(0, top)
    bottom = Math.min(baseH - 1, bottom)

    const w: number = right - left
    const h: number = bottom - top
    const side: number = Math.min(w, h)

    if (side <= 0) {
      console.info('>>> drawCircleBetweenPixels: side too small, skip')
      return
    }

    // ç”¨æ­£æ–¹å½¢åŒ…ä½åœ†
    right = left + side
    bottom = top + side

    const cx: number = Math.round((left + right) / 2)
    const cy: number = Math.round((top + bottom) / 2)
    const radius: number = side / 2

    // â‘¡ åœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»åœ†
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      return
    }

    const info: image.ImageInfo = await layerPm.getImageInfo()
    const width: number = info.size.width
    const height: number = info.size.height

    // 1ï¼‰è¯»ç»˜åˆ¶å±‚åƒç´ 
    const byteLength: number = layerPm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await layerPm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // 2ï¼‰é€šé“é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const strokeRadius: number = this.computeStrokeRadiusPixel(width, height)

    const alpha: number = this.getStrokeAlpha()

    const drawThickPoint = (px: number, py: number): void => {
      for (let yy: number = py - strokeRadius; yy <= py + strokeRadius; yy++) {
        if (yy < 0 || yy >= height) {
          continue
        }
        for (let xx: number = px - strokeRadius; xx <= px + strokeRadius; xx++) {
          if (xx < 0 || xx >= width) {
            continue
          }
          const dx: number = xx - px
          const dy: number = yy - py
          if (dx * dx + dy * dy > strokeRadius * strokeRadius) {
            continue
          }

          const baseIndex: number = (yy * width + xx) * 4
          const rIndex: number = baseIndex + rOffset
          const gIndex: number = baseIndex + gOffset
          const bIndex: number = baseIndex + bOffset
          const aIndex: number = baseIndex + aOffset

          if (this.currentBrush === BrushTool.Eraser) {
            // æ©¡çš®æ“¦ï¼šåªæ“¦æ‰ç»˜åˆ¶å±‚ alpha
            data[aIndex] = 0
          } else {
            data[rIndex] = this.strokeR
            data[gIndex] = this.strokeG
            data[bIndex] = this.strokeB
            data[aIndex] = alpha
          }
        }
      }
    }

    // 3ï¼‰ç”¨å‚æ•°æ–¹ç¨‹ç”»ä¸€åœˆï¼šx = cx + r cos t, y = cy + r sin t
    const TWO_PI: number = Math.PI * 2
    // æ­¥æ•°ä¸åŠå¾„æˆæ¯”ä¾‹ï¼Œä¿è¯è¶Šå¤§è¶Šå¹³æ»‘
    const steps: number = Math.max(36, Math.floor(TWO_PI * radius / 2))

    for (let i: number = 0; i < steps; i++) {
      const t: number = (TWO_PI * i) / steps
      const px: number = Math.round(cx + radius * Math.cos(t))
      const py: number = Math.round(cy + radius * Math.sin(t))

      if (px < 0 || px >= width || py < 0 || py >= height) {
        continue
      }
      drawThickPoint(px, py)
    }

    // 4ï¼‰å†™å›ç»˜åˆ¶å±‚åƒç´ 
    await layerPm.writeBufferToPixels(buffer)

    // 5ï¼‰clone ä¸€ä»½æ–°çš„ç»˜åˆ¶å±‚ï¼Œè§¦å‘ UI åˆ·æ–°
    const newLayer: image.PixelMap = await this.clonePixelMap(layerPm)
    if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
      this.drawPixelMap.release?.()
    }
    this.drawPixelMap = newLayer
    this.drawPixelVersion++ // å åŠ å±‚ Image é‡æ–°æ¸²æŸ“

    console.info(`>>> drawCircleBetweenPixels: circle drawn, drawPixelVersion=${this.drawPixelVersion}`)
  }

  // åœ†å½¢å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œè½¬æˆåƒç´ å¹¶ç”»åœ†
  // åœ†å½¢å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œè½¬æˆåƒç´ å¹¶ç”»åœ†ï¼ˆç»˜åˆ¶åœ¨ overlayï¼‰
  private async handleCircleDrag(startUiX: number, startUiY: number, endUiX: number, endUiY: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    const pm: image.PixelMap = this.pixelMap as image.PixelMap
    const info: image.ImageInfo = await pm.getImageInfo()

    // â€”â€” UI â†’ åƒç´ ï¼ˆå’Œç‚¹ / ç›´çº¿ / çŸ©å½¢ä¿æŒä¸€è‡´ï¼‰â€”â€”
    const scaleBase: number = Math.min(
      this.canvasWidth / info.size.width,
      this.canvasHeight / info.size.height
    )

    const realW: number = info.size.width * scaleBase * this.zoom
    const realH: number = info.size.height * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const startPxFloat: number = (startUiX - imageLeft) * (info.size.width / realW)
    const startPyFloat: number = (startUiY - imageTop) * (info.size.height / realH)
    const endPxFloat: number = (endUiX - imageLeft) * (info.size.width / realW)
    const endPyFloat: number = (endUiY - imageTop) * (info.size.height / realH)

    const x0: number = Math.floor(startPxFloat)
    const y0: number = Math.floor(startPyFloat)
    const x1: number = Math.floor(endPxFloat)
    const y1: number = Math.floor(endPyFloat)

    console.info(
      `>>> handleCircleDrag uiStart=(${startUiX.toFixed(1)},${startUiY.toFixed(1)}), ` +
        `uiEnd=(${endUiX.toFixed(1)},${endUiY.toFixed(1)}) -> ` +
        `pixelStart=(${x0},${y0}), pixelEnd=(${x1},${y1}), imgSize=(${info.size.width},${info.size.height})`
    )

    // 1ï¼‰å…ˆæ±‚å‡ºæ‹–å‡ºçŸ©å½¢çš„å·¦/å³/ä¸Š/ä¸‹
    let left: number = Math.min(x0, x1)
    let right: number = Math.max(x0, x1)
    let top: number = Math.min(y0, y1)
    let bottom: number = Math.max(y0, y1)

    const boxW: number = right - left
    const boxH: number = bottom - top
    const side: number = Math.min(Math.abs(boxW), Math.abs(boxH))

    if (side <= 0) {
      console.info('>>> handleCircleDrag: side too small, skip')
      return
    }

    // ç”¨å·¦ä¸Šè§’ + side æ„é€ ä¸€ä¸ªæ­£æ–¹å½¢åŒºåŸŸ
    right = left + side
    bottom = top + side

    // 2ï¼‰ä¿®æ”¹å‰å‹å…¥æ’¤é”€æ ˆï¼šåªè®°å½•çŠ¶æ€ + ç»˜åˆ¶å±‚å¿«ç…§ï¼ˆåº•å›¾ä¸åŠ¨ï¼‰
    await this.pushHistorySnapshot(false)

    // 3ï¼‰çœŸæ­£ç”»åœ†ï¼ˆåœ¨ç»˜åˆ¶å›¾å±‚ä¸Šï¼‰
    await this.drawCircleBetweenPixels(left, top, right, bottom)

    promptAction.showToast({ message: 'åœ†å½¢å·²ç»˜åˆ¶' })
  }

  // æ¤­åœ†å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œè½¬æˆåƒç´ å¹¶ç”»æ¤­åœ†
  // æ¤­åœ†å·¥å…·ï¼šæ‹–æ‹½äº§ç”Ÿçš„èµ·ç‚¹/ç»ˆç‚¹ï¼ˆUI åæ ‡ï¼‰ï¼Œè½¬æˆåƒç´ å¹¶åœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»æ¤­åœ†
  private async handleEllipseDrag(startUiX: number, startUiY: number, endUiX: number, endUiY: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    const pm: image.PixelMap = this.pixelMap as image.PixelMap
    const info: image.ImageInfo = await pm.getImageInfo()

    const scaleBase: number = Math.min(
      this.canvasWidth / info.size.width,
      this.canvasHeight / info.size.height
    )

    const realW: number = info.size.width * scaleBase * this.zoom
    const realH: number = info.size.height * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const startPxFloat: number = (startUiX - imageLeft) * (info.size.width / realW)
    const startPyFloat: number = (startUiY - imageTop) * (info.size.height / realH)
    const endPxFloat: number = (endUiX - imageLeft) * (info.size.width / realW)
    const endPyFloat: number = (endUiY - imageTop) * (info.size.height / realH)

    const x0: number = Math.floor(startPxFloat)
    const y0: number = Math.floor(startPyFloat)
    const x1: number = Math.floor(endPxFloat)
    const y1: number = Math.floor(endPyFloat)

    console.info(
      `>>> handleEllipseDrag uiStart=(${startUiX.toFixed(1)},${startUiY.toFixed(1)}), ` +
        `uiEnd=(${endUiX.toFixed(1)},${endUiY.toFixed(1)}) -> ` +
        `pixelStart=(${x0},${y0}), pixelEnd=(${x1},${y1}), imgSize=(${info.size.width},${info.size.height})`
    )

    let left: number = Math.min(x0, x1)
    let right: number = Math.max(x0, x1)
    let top: number = Math.min(y0, y1)
    let bottom: number = Math.max(y0, y1)

    if (right - left <= 0 || bottom - top <= 0) {
      console.info('>>> handleEllipseDrag: rect too small, skip')
      return
    }

    // 1ï¼‰ä¿®æ”¹å‰å‹å…¥æ’¤é”€æ ˆï¼šåªè®°å½•çŠ¶æ€ + ç»˜åˆ¶å±‚å¿«ç…§ï¼ˆåº•å›¾ä¸åŠ¨ï¼‰
    await this.pushHistorySnapshot(false)

    // 2ï¼‰çœŸæ­£åœ¨ç»˜åˆ¶å›¾å±‚é‡Œç”»æ¤­åœ†
    await this.drawEllipseBetweenPixels(left, top, right, bottom)

    promptAction.showToast({ message: 'æ¤­åœ†å·²ç»˜åˆ¶' })
  }

  // åœ¨åƒç´ åæ ‡é‡Œç”»ä¸€ä¸ªæ¤­åœ†è¾¹æ¡†ï¼ˆä½¿ç”¨å½“å‰ stroke å®½åº¦å’Œé¢œè‰²ï¼‰
  // ä¼ å…¥çš„æ˜¯æ¤­åœ†å¤–æ¥çŸ©å½¢å·¦ä¸Š / å³ä¸‹
  // åœ¨åƒç´ åæ ‡é‡Œç”»ä¸€ä¸ªæ¤­åœ†è¾¹æ¡†ï¼ˆä½¿ç”¨å½“å‰ stroke å®½åº¦å’Œé¢œè‰²ï¼‰
  // ä¼ å…¥çš„æ˜¯æ¤­åœ†å¤–æ¥çŸ©å½¢å·¦ä¸Š / å³ä¸‹ï¼Œå®é™…ç»˜åˆ¶åœ¨ drawPixelMap ä¸Š
  private async drawEllipseBetweenPixels(left: number, top: number, right: number, bottom: number): Promise<void> {
    if (!this.pixelMap) {
      return
    }

    // å…ˆç”¨åº•å›¾åšä¸€æ¬¡è¾¹ç•Œè£å‰ªï¼ˆå°ºå¯¸ä¸ç»˜åˆ¶å±‚ä¸€è‡´ï¼‰
    const basePm: image.PixelMap = this.pixelMap as image.PixelMap
    const baseInfo: image.ImageInfo = await basePm.getImageInfo()
    const baseW: number = baseInfo.size.width
    const baseH: number = baseInfo.size.height

    left = Math.max(0, left)
    right = Math.min(baseW - 1, right)
    top = Math.max(0, top)
    bottom = Math.min(baseH - 1, bottom)

    const w: number = right - left
    const h: number = bottom - top

    if (w <= 0 || h <= 0) {
      console.info('>>> drawEllipseBetweenPixels: rect too small, skip')
      return
    }

    const cx: number = Math.round((left + right) / 2)
    const cy: number = Math.round((top + bottom) / 2)
    const rx: number = w / 2
    const ry: number = h / 2

    // â‘¡ åœ¨ç»˜åˆ¶å›¾å±‚ä¸Šç”»æ¤­åœ†
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      return
    }

    const info: image.ImageInfo = await layerPm.getImageInfo()
    const width: number = info.size.width
    const height: number = info.size.height

    // 1ï¼‰è¯»ç»˜åˆ¶å±‚åƒç´ 
    const byteLength: number = layerPm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await layerPm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // 2ï¼‰é€šé“é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const thickRadius: number = this.computeStrokeRadiusPixel(width, height)
    const alpha: number = this.getStrokeAlpha()

    const drawThickPoint = (px: number, py: number): void => {
      for (let yy: number = py - thickRadius; yy <= py + thickRadius; yy++) {
        if (yy < 0 || yy >= height) {
          continue
        }
        for (let xx: number = px - thickRadius; xx <= px + thickRadius; xx++) {
          if (xx < 0 || xx >= width) {
            continue
          }
          const dx: number = xx - px
          const dy: number = yy - py
          if (dx * dx + dy * dy > thickRadius * thickRadius) {
            continue
          }

          const baseIndex: number = (yy * width + xx) * 4
          const rIndex: number = baseIndex + rOffset
          const gIndex: number = baseIndex + gOffset
          const bIndex: number = baseIndex + bOffset
          const aIndex: number = baseIndex + aOffset

          if (this.currentBrush === BrushTool.Eraser) {
            // æ©¡çš®æ“¦ï¼šåªæ“¦ç»˜åˆ¶å±‚ï¼Œè®©å®ƒé€æ˜
            data[aIndex] = 0
          } else {
            data[rIndex] = this.strokeR
            data[gIndex] = this.strokeG
            data[bIndex] = this.strokeB
            data[aIndex] = alpha
          }
        }
      }
    }

    // 3ï¼‰å‚æ•°æ–¹ç¨‹æ¤­åœ†ï¼šx = cx + rx cos t, y = cy + ry sin t
    const TWO_PI: number = Math.PI * 2
    const maxR: number = Math.max(rx, ry)
    const steps: number = Math.max(36, Math.floor(TWO_PI * maxR / 2))

    for (let i: number = 0; i < steps; i++) {
      const t: number = (TWO_PI * i) / steps
      const px: number = Math.round(cx + rx * Math.cos(t))
      const py: number = Math.round(cy + ry * Math.sin(t))

      if (px < 0 || px >= width || py < 0 || py >= height) {
        continue
      }
      drawThickPoint(px, py)
    }

    // 4ï¼‰å†™å›ç»˜åˆ¶å±‚åƒç´ 
    await layerPm.writeBufferToPixels(buffer)

    // 5ï¼‰clone ä¸€å¼ æ–°çš„ç»˜åˆ¶å±‚è§¦å‘åˆ·æ–°
    const newLayer: image.PixelMap = await this.clonePixelMap(layerPm)
    if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
      this.drawPixelMap.release?.()
    }
    this.drawPixelMap = newLayer
    this.drawPixelVersion++

    console.info(`>>> drawEllipseBetweenPixels: ellipse drawn, drawPixelVersion=${this.drawPixelVersion}`)
  }

  // åœ¨è‡ªç”±ç»˜åˆ¶æ—¶ï¼Œæ¯ä¸€å°æ®µæ‰‹åŠ¿ç§»åŠ¨ï¼Œå®æ—¶ç”»åˆ°å†…å­˜ buffer é‡Œï¼ˆåŒæ­¥ï¼‰
  private drawFreeStrokeSegmentSync(
    prevUiX: number,
    prevUiY: number,
    curUiX: number,
    curUiY: number
  ): void {
    // è¿™é‡Œè¦æ±‚ï¼šå·²ç»åœ¨æ‰‹åŠ¿å¼€å§‹çš„æ—¶å€™åˆå§‹åŒ–å¥½ freeDrawArrayBuffer / freeDrawBufferï¼Œ
    // ä¸”å®ƒæ˜¯åŸºäº â€œç»˜åˆ¶å±‚ drawPixelMapï¼ˆå¦‚æœæœ‰ï¼‰æˆ–è€…åº•å›¾ pixelMapâ€ çš„åƒç´ æ•°æ®ã€‚
    if (!this.freeDrawBuffer || !this.freeDrawArrayBuffer) {
      return
    }
    if (!this.pixelMap && !this.drawPixelMap) {
      return
    }

    // âœ… ä¼˜å…ˆä½¿ç”¨ç»˜åˆ¶å±‚çš„å°ºå¯¸ / åƒç´ æ ¼å¼
    const basePm: image.PixelMap = (this.drawPixelMap ?? this.pixelMap) as image.PixelMap
    const info: image.ImageInfo = basePm.getImageInfoSync()

    const imgW: number = info.size.width
    const imgH: number = info.size.height

    // â€”â€” UI â†’ åƒç´ æ˜ å°„ï¼Œé€»è¾‘è·Ÿä½ ä¹‹å‰å®Œå…¨ä¸€æ · â€”â€”
    const scaleBase: number = Math.min(
      this.canvasWidth / imgW,
      this.canvasHeight / imgH
    )
    const realW: number = imgW * scaleBase * this.zoom
    const realH: number = imgH * scaleBase * this.zoom

    const imageLeft: number = (this.canvasWidth - realW) / 2 + this.offsetX
    const imageTop: number = (this.canvasHeight - realH) / 2 + this.offsetY

    const x0: number = Math.floor((prevUiX - imageLeft) * (imgW / realW))
    const y0: number = Math.floor((prevUiY - imageTop) * (imgH / realH))
    const x1: number = Math.floor((curUiX - imageLeft) * (imgW / realW))
    const y1: number = Math.floor((curUiY - imageTop) * (imgH / realH))

    // è¶Šç•Œç›´æ¥ä¸¢å¼ƒè¿™æ®µ
    if (
      x0 < 0 || x0 >= imgW || y0 < 0 || y0 >= imgH ||
        x1 < 0 || x1 >= imgW || y1 < 0 || y1 >= imgH
    ) {
      return
    }

    // â­ çœŸæ­£ç”»åˆ° freeDrawBufferï¼ˆåŒæ­¥ã€ä¸ awaitï¼‰
    this.drawLineIntoBuffer(
      x0,
      y0,
      x1,
      y1,
      this.freeDrawBuffer as Uint8Array,
      imgW,
      imgH,
      info.pixelFormat
    )
  }

  // åœ¨ç»™å®šçš„åƒç´ ç¼“å†²åŒºé‡Œç”»ä¸€æ¡â€œå¸¦ç²—ç»†çš„çº¿æ®µâ€ï¼ˆè‡ªç”±ç”»ä¸“ç”¨ï¼Œå®Œå…¨åŒæ­¥ï¼‰
  // x0,y0,x1,y1 æ˜¯åƒç´ åæ ‡ï¼›buffer æ˜¯æ•´å¼ å›¾çš„ BGRA/ARGB/RGBA åƒç´ æ•°æ®
  private drawLineIntoBuffer(
    x0: number,
    y0: number,
    x1: number,
    y1: number,
    buffer: Uint8Array,
    imgW: number,
    imgH: number,
    pixelFormat: image.PixelMapFormat
  ): void {
    const width: number = imgW
    const height: number = imgH

    // é€šé“åç§»
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        // B G R A
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        // A R G B
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
      // R G B A
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    const radius: number = this.computeStrokeRadiusPixel(imgW, imgH)
    const alpha: number = this.getStrokeAlpha()

    const drawThickPoint = (cx: number, cy: number): void => {
      for (let yy: number = cy - radius; yy <= cy + radius; yy++) {
        if (yy < 0 || yy >= height) {
          continue
        }
        for (let xx: number = cx - radius; xx <= cx + radius; xx++) {
          if (xx < 0 || xx >= width) {
            continue
          }

          const dx: number = xx - cx
          const dy: number = yy - cy
          if (dx * dx + dy * dy > radius * radius) {
            continue
          }

          const baseIndex: number = (yy * width + xx) * 4
          const rIndex: number = baseIndex + rOffset
          const gIndex: number = baseIndex + gOffset
          const bIndex: number = baseIndex + bOffset
          const aIndex: number = baseIndex + aOffset

          if (aIndex >= buffer.length) {
            // ç†è®ºä¸Šä¸ä¼šè¶Šç•Œï¼Œä¿é™©èµ·è§
            continue
          }

          if (this.currentBrush === BrushTool.Eraser) {
            // ğŸ§½ æ©¡çš®æ“¦ï¼šåªæŠŠç»˜åˆ¶å±‚æ“¦é€æ˜
            buffer[aIndex] = 0
          } else {
            // æ™®é€šç”»ç¬” / è§å…‰ç¬”ï¼šç”¨å½“å‰ç¬”åˆ·é¢œè‰² + é€æ˜åº¦
            buffer[rIndex] = this.strokeR
            buffer[gIndex] = this.strokeG
            buffer[bIndex] = this.strokeB
            buffer[aIndex] = alpha
          }
        }
      }
    }

    // â€”â€” ä¸‹é¢ Bresenham ç”»çº¿ä¿æŒä¸å˜ â€”â€”
    let curX: number = x0
    let curY: number = y0
    const dx: number = Math.abs(x1 - x0)
    const sx: number = x0 < x1 ? 1 : -1
    const dy: number = -Math.abs(y1 - y0)
    const sy: number = y0 < y1 ? 1 : -1
    let err: number = dx + dy

    while (true) {
      drawThickPoint(curX, curY)

      if (curX === x1 && curY === y1) {
        break
      }

      const e2: number = 2 * err
      if (e2 >= dy) {
        err += dy
        curX += sx
      }
      if (e2 <= dx) {
        err += dx
        curY += sy
      }
    }
  }

  private async prepareFreeDrawBuffer() {
    if (!this.pixelMap) {
      return
    }

    // âœ… è‡ªç”±ç»˜åˆ¶åªé’ˆå¯¹ç»˜åˆ¶å±‚ï¼Œå¦‚æœè¿˜æ²¡æœ‰ç»˜åˆ¶å±‚ï¼Œå…ˆåˆ›å»ºä¸€å¼ å…¨é€æ˜çš„
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      return
    }

    this.freeBufferReady = false

    this.freeDrawByteLength = layerPm.getPixelBytesNumber()
    this.freeDrawArrayBuffer = new ArrayBuffer(this.freeDrawByteLength)

    // å¼‚æ­¥è¯»å–ç»˜åˆ¶å±‚åƒç´ ï¼ˆä¸èƒ½åœ¨æ‰‹åŠ¿é‡Œ awaitï¼‰
    layerPm.readPixelsToBuffer(this.freeDrawArrayBuffer).then(() => {
      this.freeDrawBuffer = new Uint8Array(this.freeDrawArrayBuffer as ArrayBuffer)
      this.freeBufferReady = true
    })
  }

  private async handleFreeDrawEnd(): Promise<void> {
    // åªåœ¨ FreeDraw æ¨¡å¼ä¸‹ç»“æŸè‡ªç”±ç»˜åˆ¶
    if (this.currentShape !== ShapeTool.FreeDraw || !this.pixelMap) {
      return
    }

    this.isFreeDrawing = false

    // âœ… è‡ªç”±ç»˜åˆ¶ä½œç”¨äºç»˜åˆ¶å±‚ï¼Œå¦‚æœæ²¡æœ‰åˆ™ç›´æ¥è¿”å›
    const layerPm: image.PixelMap | undefined = await this.ensureDrawLayer()
    if (!layerPm) {
      this.freeDrawBuffer = null
      this.freeDrawArrayBuffer = null
      return
    }

    // 1) æŠŠæœ€ç»ˆçš„å†…å­˜ buffer å†™å›ç»˜åˆ¶å±‚ pixelMap
    if (this.freeDrawArrayBuffer) {
      await layerPm.writeBufferToPixels(this.freeDrawArrayBuffer)
    }

    // 2) clone ä¸€ä»½æ–°çš„ç»˜åˆ¶å±‚ â€”â€” è§¦å‘ UI åˆ·æ–°ï¼ˆä¸å…¶å®ƒå›¾å½¢ç»˜åˆ¶é€»è¾‘ä¿æŒä¸€è‡´ï¼‰
    const newLayer: image.PixelMap = await this.clonePixelMap(layerPm)

    if (this.drawPixelMap && this.drawPixelMap !== newLayer) {
      this.drawPixelMap.release?.()
    }
    this.drawPixelMap = newLayer
    this.drawPixelVersion++ // Image(drawPixelMap) ä¼šåˆ·æ–°

    // 3) æ¸…ç©ºç¼“å­˜
    this.freeDrawBuffer = null
    this.freeDrawArrayBuffer = null
  }

  // æ ¹æ®å½“å‰ç”»ç¬”é€æ˜åº¦ strokeOpacityï¼ˆ0.0~1.0ï¼‰è®¡ç®—å¯¹åº”çš„ alphaï¼ˆ0~255ï¼‰
  // å½“å‰ç”»ç¬”çš„ alphaï¼ˆ0~255ï¼‰
  private getStrokeAlpha(): number {
    // ä»¥åå¦‚æœè¦åšæ©¡çš®æ“¦ = æŠ¹é€æ˜ï¼Œå¯ä»¥åœ¨è¿™é‡Œ special case
    if (this.currentBrush === BrushTool.Eraser) {
      // æš‚æ—¶å…ˆç•™ç€ 255ï¼Œä¸åšâ€œæŠ¹é€æ˜â€é€»è¾‘ï¼Œåé¢æˆ‘ä»¬å•ç‹¬å¤„ç†æ©¡çš®æ“¦
      // return 0
    }

    let a: number = Math.round(this.strokeOpacity * 255)

    if (a < 0) {
      a = 0
    } else if (a > 255) {
      a = 255
    }
    return a
  }

  // æŠŠ overlayPmï¼ˆdrawPixelMapï¼‰æŒ‰ alpha åˆæˆåˆ° basePm ä¸Šï¼ˆåªä¿®æ”¹ basePmï¼‰
  // æŠŠç»˜åˆ¶å›¾å±‚ overlayPm â€œç›–â€åˆ° basePm ä¸Šï¼š
  // åªè¦ overlay åƒç´  alpha > 0ï¼Œå°±ç›´æ¥ç”¨ overlay çš„ RGBA è¦†ç›– base å¯¹åº”åƒç´ 
  private async mergeDrawLayerIntoBase(
    basePm: image.PixelMap,
    overlayPm: image.PixelMap
  ): Promise<void> {
    const baseInfo: image.ImageInfo = await basePm.getImageInfo()
    const overInfo: image.ImageInfo = await overlayPm.getImageInfo()

    const width: number = baseInfo.size.width
    const height: number = baseInfo.size.height

    // å°ºå¯¸å¯¹ä¸ä¸Šï¼Œå…ˆå°½é‡ä¸å´©ï¼Œç›´æ¥è¿”å›ï¼ˆä¸‹é¢ç¬¬ 2 æ­¥ä¼šä¿è¯è£å‰ªæ—¶åŒæ­¥è£å‰ªç»˜åˆ¶å±‚ï¼‰
    if (overInfo.size.width !== width || overInfo.size.height !== height) {
      console.warn(
        `mergeDrawLayerIntoBase: size mismatch base=${width}x${height} over=${overInfo.size.width}x${overInfo.size.height}`
      )
      return
    }

    const baseLen: number = basePm.getPixelBytesNumber()
    const overLen: number = overlayPm.getPixelBytesNumber()

    const baseBuf: ArrayBuffer = new ArrayBuffer(baseLen)
    const overBuf: ArrayBuffer = new ArrayBuffer(overLen)

    await basePm.readPixelsToBuffer(baseBuf)
    await overlayPm.readPixelsToBuffer(overBuf)

    const baseData: Uint8Array = new Uint8Array(baseBuf)
    const overData: Uint8Array = new Uint8Array(overBuf)

    // ------- base é€šé“åç§» -------
    let brOff: number = 0
    let bgOff: number = 1
    let bbOff: number = 2
    let baOff: number = 3

    switch (baseInfo.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bbOff = 0
        bgOff = 1
        brOff = 2
        baOff = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        baOff = 0
        brOff = 1
        bgOff = 2
        bbOff = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        brOff = 0
        bgOff = 1
        bbOff = 2
        baOff = 3
        break
    }

    // ------- overlay é€šé“åç§» -------
    let orOff: number = 0
    let ogOff: number = 1
    let obOff: number = 2
    let oaOff: number = 3

    switch (overInfo.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        obOff = 0
        ogOff = 1
        orOff = 2
        oaOff = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        oaOff = 0
        orOff = 1
        ogOff = 2
        obOff = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        orOff = 0
        ogOff = 1
        obOff = 2
        oaOff = 3
        break
    }

    // ------- ç®€å•ç²—æš´ï¼šåªè¦ overlay alpha > 0ï¼Œå°±è¦†ç›– base -------
    for (let y: number = 0; y < height; y++) {
      for (let x: number = 0; x < width; x++) {
        const idx: number = (y * width + x) * 4

        const oaIdx: number = idx + oaOff
        const alphaOver: number = overData[oaIdx]

        if (alphaOver === 0) {
          // æ²¡ç”»ä¸œè¥¿/è¢«æ©¡çš®æ“¦æ“¦æ‰çš„åŒºåŸŸ â†’ ç›´æ¥è·³è¿‡
          continue
        }

        const orIdx: number = idx + orOff
        const ogIdx: number = idx + ogOff
        const obIdx: number = idx + obOff

        const brIdx: number = idx + brOff
        const bgIdx: number = idx + bgOff
        const bbIdx: number = idx + bbOff
        const baIdx: number = idx + baOff

        baseData[brIdx] = overData[orIdx]
        baseData[bgIdx] = overData[ogIdx]
        baseData[bbIdx] = overData[obIdx]
        baseData[baIdx] = alphaOver // æˆ–è€… 255ï¼Œçœ‹ä½ éœ€æ±‚ï¼Œè¿™é‡Œä¿ç•™ overlay åŸå§‹ alpha
      }
    }

    await basePm.writeBufferToPixels(baseBuf)
  }

  // ä»…ç”¨äºâ€œä¿å­˜å›¾ç‰‡â€ï¼šæŠŠå½“å‰ brightnessLevel / contrastLevel çƒ˜ç„™åˆ°ç»™å®š pmï¼Œä½†ä¸ä¿®æ”¹ this.brightnessLevel / this.contrastLevel
  private async bakeToneForSave(pm: image.PixelMap): Promise<void> {
    // å½“å‰æ²¡æœ‰è°ƒæ•´å°±ç›´æ¥ä¸å¤„ç†
    if (this.brightnessLevel === 0 && this.contrastLevel === 0) {
      return
    }

    const info: image.ImageInfo = await pm.getImageInfo()
    const byteLength: number = pm.getPixelBytesNumber()
    const buffer: ArrayBuffer = new ArrayBuffer(byteLength)
    await pm.readPixelsToBuffer(buffer)
    const data: Uint8Array = new Uint8Array(buffer)

    // é€šé“é¡ºåº
    let rOffset: number = 0
    let gOffset: number = 1
    let bOffset: number = 2
    let aOffset: number = 3

    switch (info.pixelFormat) {
      case image.PixelMapFormat.BGRA_8888:
        bOffset = 0
        gOffset = 1
        rOffset = 2
        aOffset = 3
        break
      case image.PixelMapFormat.ARGB_8888:
        aOffset = 0
        rOffset = 1
        gOffset = 2
        bOffset = 3
        break
      case image.PixelMapFormat.RGBA_8888:
      default:
        rOffset = 0
        gOffset = 1
        bOffset = 2
        aOffset = 3
        break
    }

    // å’Œä½ åŸæ¥ä¸€è‡´çš„äº®åº¦/å¯¹æ¯”åº¦è®¡ç®—
    const c: number = 1.0 + this.contrastLevel
    const shiftBrightness: number = this.brightnessLevel * 255.0
    const shiftTotal: number = 128.0 * (1.0 - c) + shiftBrightness

    const clamp = (v: number): number => {
      if (v < 0) {
        return 0
      }
      if (v > 255) {
        return 255
      }
      return v
    }

    for (let i: number = 0; i < data.length; i += 4) {
      const rIndex: number = i + rOffset
      const gIndex: number = i + gOffset
      const bIndex: number = i + bOffset
      const aIndex: number = i + aOffset

      const r = data[rIndex]
      const g = data[gIndex]
      const b = data[bIndex]

      data[rIndex] = clamp(c * r + shiftTotal)
      data[gIndex] = clamp(c * g + shiftTotal)
      data[bIndex] = clamp(c * b + shiftTotal)
      data[aIndex] = data[aIndex] // alpha ä¸å˜
    }

    await pm.writeBufferToPixels(buffer)
  }

  // æŠŠã€Œå±å¹•ç²—ç»†ã€strokeWidth æ¢ç®—æˆã€Œå›¾åƒåƒç´ åŠå¾„ã€
  // imgW / imgH æ˜¯å½“å‰å›¾ç‰‡ï¼ˆæˆ–ç»˜åˆ¶å±‚ï¼‰çš„åƒç´ å°ºå¯¸
  // æŠŠâ€œå±å¹•ä¸Šç²—ç»†â€ strokeWidth æ¢ç®—æˆâ€œå›¾åƒé‡Œçš„åƒç´ åŠå¾„â€
  // imgW / imgH æ˜¯å½“å‰å›¾åƒï¼ˆæˆ–ç»˜åˆ¶å±‚ï¼‰çš„åƒç´ å°ºå¯¸
  private computeStrokeRadiusPixel(imgW: number, imgH: number): number {
    const MIN_RADIUS: number = 1

    if (this.canvasWidth <= 0 || this.canvasHeight <= 0) {
      // å…œåº•ï¼šç”»å¸ƒå°ºå¯¸å¼‚å¸¸æ—¶ï¼Œç›´æ¥ç”¨ strokeWidth å½“åƒç´ åŠå¾„
      return Math.max(MIN_RADIUS, Math.floor(this.strokeWidth))
    }

    // å’Œ UIâ†’åƒç´ æ˜ å°„ä¿æŒåŒä¸€å¥—ç¼©æ”¾ï¼šcontain ç¼©æ”¾ * å½“å‰ç¼©æ”¾å› å­
    const scaleBase: number = Math.min(
      this.canvasWidth / imgW,
      this.canvasHeight / imgH
    )
    const realScale: number = scaleBase * this.zoom

    if (realScale <= 0) {
      return Math.max(MIN_RADIUS, Math.floor(this.strokeWidth))
    }

    // strokeWidth æ˜¯â€œå±å¹•ä¸Šçš„åŠå¾„ï¼ˆpxï¼‰â€ï¼Œé™¤ä»¥ realScale å¾—åˆ°â€œå›¾åƒåƒç´ åŠå¾„â€
    let r: number = this.strokeWidth / realScale

    if (r < MIN_RADIUS) {
      r = MIN_RADIUS
    }

    return Math.floor(r)
  }

  private ensureRemoteUser(clientId: string): void {
    // å·²ç»å­˜åœ¨å°±ä¸é‡å¤æ·»åŠ 
    const existed: OnlineUserInfo | undefined = this.onlineUsers
      .find((u: OnlineUserInfo) => u.clientId === clientId);
    if (existed) {
      return;
    }

    // ğŸ¨ å…³é”®ï¼šé¢œè‰²ç”± clientId å†³å®š
    const color: string = this.pickColorForClient(clientId);

    const remoteUser: OnlineUserInfo = {
      clientId: clientId,
      displayColor: color,
      isSelf: false
    };

    this.onlineUsers = [...this.onlineUsers, remoteUser];
  }

  // æ ¹æ® clientId ç®—ä¸€ä¸ªç¨³å®šçš„é¢œè‰²ç´¢å¼•ï¼ŒåŒä¸€ä¸ª clientId åœ¨ä»»ä½•è®¾å¤‡ä¸Šéƒ½ä¸€æ ·
  // æ ¹æ® clientId é€‰æ‹©ä¸€ä¸ªç¨³å®šçš„é¢œè‰²ï¼šåŒä¸€ä¸ª clientId â†’ åŒä¸€ä¸ªé¢œè‰²
  private pickColorForClient(clientId: string): string {
    let hash: number = 0;
    for (let i = 0; i < clientId.length; i++) {
      hash = (hash * 31 + clientId.charCodeAt(i)) >>> 0; // æ— ç¬¦å· 32bit
    }

    const paletteSize: number = this.userColorPalette.length;
    if (paletteSize === 0) {
      return '#000000'; // å…œåº•
    }

    const idx: number = hash % paletteSize;
    return this.userColorPalette[idx];
  }

  // æŠŠå½“å‰ PixelMap æ‰“åŒ…æˆ PNG + base64ï¼Œé€šè¿‡ WebSocket å‘ç»™æ‰€æœ‰äºº
  private async broadcastImageToPeers(pm: image.PixelMap): Promise<void> {
    // 1) pack æˆ PNG çš„ ArrayBuffer
    const packer = image.createImagePacker()
    const packOpts: image.PackingOption = {
      format: 'image/png',
      quality: 100
    }
    const pngBuffer: ArrayBuffer = await packer.packToData(pm, packOpts)
    packer.release?.()

    // 2) ArrayBuffer -> base64ï¼ˆè¿™é‡Œå†™æˆè¾…åŠ©å‡½æ•°ï¼Œä½ å¯ä»¥æŒ‰ HarmonyOS 6.0 å¯ç”¨çš„ Base64 API å®ç°ï¼‰
    const pngBase64: string = this.arrayBufferToBase64(pngBuffer)

    // 3) ç»„è£…åä½œæ¶ˆæ¯
    const msg: CollabMessage = {
      type: 'imageSync',
      clientId: this.clientId, // æˆ– this.localClientIdï¼Œçœ‹ä½ å“ªä¸€ä¸ªæœ€ç»ˆä½œä¸ºâ€œè‡ªå·±â€çš„ id
      payload: {
        format: 'image/png',
        dataBase64: pngBase64
      } as CollabImageSyncPayload
    }

    this.collabClient.send(msg)
    console.info('[Collab] broadcast image-sync, size(base64)=', pngBase64.length)
  }

  // æŠŠ ArrayBuffer è½¬æˆ base64 å­—ç¬¦ä¸²
  // ArrayBuffer -> base64 å­—ç¬¦ä¸²
  // ArrayBuffer -> base64 string
  private arrayBufferToBase64(buf: ArrayBuffer): string {
    // æ˜¾å¼ç±»å‹ï¼šUint8Array
    const uint8: Uint8Array = new Uint8Array(buf)
    const base64Helper: util.Base64Helper = new util.Base64Helper()
    const base64Str: string = base64Helper.encodeToStringSync(uint8)
    return base64Str
  }

  // base64 string -> ArrayBuffer
  private base64ToArrayBuffer(b64: string): ArrayBuffer {
    const base64Helper: util.Base64Helper = new util.Base64Helper()
    // decodeSync è¿”å› Uint8Array
    const uint8: Uint8Array = base64Helper.decodeSync(b64)
    // Uint8Array è‡ªå¸¦ bufferï¼Œå°±æ˜¯ ArrayBuffer
    const buf: ArrayBuffer = uint8.buffer as ArrayBuffer
    return buf
  }

  // æŠŠè¿œç«¯å‘æ¥çš„ base64 PNG è½¬æˆ PixelMap å¹¶åº”ç”¨åˆ°æœ¬åœ°
  private async applyRemoteImage(payload: CollabImageSyncPayload): Promise<void> {
    // 1) base64 -> ArrayBuffer
    const buf: ArrayBuffer = this.base64ToArrayBuffer(payload.dataBase64)

    // 2) decode æˆ PixelMap
    const imgSource = image.createImageSource(buf)
    const pm: image.PixelMap = await imgSource.createPixelMap({ editable: true })
    imgSource.release?.()

    // 3) å’Œ pickImage é‡Œä¸€æ ·çš„åˆå§‹åŒ–é€»è¾‘
    //    ï¼ˆæ³¨æ„ï¼šè¿™é‡Œä¸èƒ½ç”¨ photoAccessHelperï¼Œé‚£åªåœ¨æœ¬åœ°é€‰å›¾æ—¶ç”¨ï¼‰
    if (this.originalPixelMap) {
      this.originalPixelMap.release?.()
    }
    this.originalPixelMap = await this.clonePixelMap(pm)

    if (this.pixelMap) {
      this.pixelMap.release?.()
    }
    this.pixelMap = pm

    this.zoom = 1.0
    this.offsetX = 0
    this.offsetY = 0
    this.brightnessLevel = 0.0
    this.contrastLevel = 0.0
    this.accumulatedRotate = 0
    this.pixelVersion++

    const info: image.ImageInfo = await pm.getImageInfo()
    const w = info.size.width
    const h = info.size.height
    this.imageDiag = Math.hypot(w, h)

    // é‡å»ºç»˜åˆ¶å±‚
    if (this.drawPixelMap) {
      this.drawPixelMap.release?.()
    }
    this.drawPixelMap = await this.createEmptyDrawLayerLike(pm)
    this.drawPixelVersion++

    // æ¸…ç©ºå†å²æ ˆï¼Œè§†ä¸ºâ€œæ–°æ‰“å¼€ä¸€å¼ å›¾â€
    this.history = []
    this.historyIndex = -1
  }
}
