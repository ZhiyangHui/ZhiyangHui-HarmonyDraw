// entry/src/main/ets/common/collab/CollabClient.ets
import { webSocket } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';

// ========== åä½œæ¶ˆæ¯ç±»å‹å®šä¹‰ ==========
export interface CollabImageSyncPayload {
  format: string; // 'image/png'
  dataBase64: string; // æ•´å¼ å›¾ç‰‡çš„ PNG çš„ base64
  opDesc?: string;
}


// ==== æ–°å¢ï¼šæœåŠ¡å™¨ç»™å®¢æˆ·ç«¯åˆ†é…èº«ä»½çš„ payload ====
export interface CollabAssignIdPayload {
  displayColor: string; // ä¾‹å¦‚ '#EF4444'
  opDesc?: string;
}

export interface OnlineUserItem {
  clientId: string;
  displayColor: string;
}

export interface OnlineUsersPayload {
  users: Array<OnlineUserItem>;
}


// æ‰€æœ‰æ¶ˆæ¯ç±»å‹ï¼ˆåŠ ä¸Š 'assignId'ï¼‰
export type CollabMessageType =
  | 'assignId'
    | 'clear'
    | 'imageSync'
    | 'onlineUsers'; // â† æ–°å¢


export interface CollabMessage {
  type: CollabMessageType;
  clientId: string;
  payload:
    | CollabAssignIdPayload
    | CollabClearPayload
    | CollabImageSyncPayload
    | OnlineUsersPayload; // âœ… ä¸€å®šè¦åŠ è¿™ä¸€è¡Œ
}


// å•ä¸ªç¬”è¿¹ç‚¹
export interface StrokePoint {
  x: number;
  y: number;
  pressure: number; // 0~1
  color: string; // '#RRGGBB'
  width: number; // ç”»ç¬”å®½åº¦ï¼ˆå±å¹•åƒç´ ï¼‰
}

// ç¬”è¿¹æ¶ˆæ¯çš„ payload
export interface CollabStrokePayload {
  layerId: string;
  points: Array<StrokePoint>;
  color: string;
  width: number;
}

// æ¸…ç©ºå›¾å±‚æ¶ˆæ¯çš„ payload
export interface CollabClearPayload {
  layerId: string;
  opDesc?: string; // ğŸ”µ æ–°å¢ï¼Œå¯é€‰è¯´æ˜æ–‡å­—
}


// æ‰€æœ‰ payload çš„è”åˆç±»å‹
export type CollabPayload =
  CollabStrokePayload
    | CollabClearPayload
    | CollabImageSyncPayload
    | CollabAssignIdPayload
    | OnlineUsersPayload; // â† æ–°åŠ å…¥è¿™ä¸ª


// ==== å·¥å…·å‡½æ•°ï¼šæ„é€  â€œæ¸…ç©ºå›¾å±‚â€ æ¶ˆæ¯ ====

// æ³¨æ„ï¼šè¿™é‡Œç”¨æ˜¾å¼çš„ interface ç±»å‹ï¼ŒArkTS è®¤å¯ï¼Œä¸ä¼šæŠ¥ untyped object literal
export function buildClearMessage(
  clientId: string,
  layerId: string,
  opDesc?: string
): CollabMessage {
  const payload: CollabClearPayload = {
    layerId: layerId,
    opDesc: opDesc
  };

  // ğŸš¨ ä¸èƒ½å†™æˆå­—é¢é‡ï¼Œè¦ç”¨â€œåˆ›å»ºç©ºå¯¹è±¡ + èµ‹å€¼â€çš„æ–¹å¼
  const msg = {} as CollabMessage;
  msg.type = 'clear';
  msg.clientId = clientId;
  msg.payload = payload;

  return msg;
}


// ========== å›è°ƒç±»å‹å®šä¹‰ ==========

export type CollabMsgCallback = (msg: CollabMessage) => void;

export type CollabErrorCallback = (msg: string) => void;

export type CollabStateCallback = () => void;

// ========== WebSocket å®¢æˆ·ç«¯å°è£… ==========

export class CollabClient {
  private url: string;
  private ws: webSocket.WebSocket | null = null;
  private isConnected: boolean = false;
  private onOpen?: CollabStateCallback;
  private onClose?: CollabStateCallback;
  private onMsg?: CollabMsgCallback;
  private onErr?: CollabErrorCallback;

  constructor(url: string) {
    this.url = url; // ä¾‹å¦‚ "ws://192.168.0.10:8080/collab"
  }

  /**
   * è®¾ç½®å›è°ƒ
   */
  setCallbacks(
    onOpen?: CollabStateCallback,
    onClose?: CollabStateCallback,
    onMsg?: CollabMsgCallback,
    onErr?: CollabErrorCallback
  ): void {
    this.onOpen = onOpen;
    this.onClose = onClose;
    this.onMsg = onMsg;
    this.onErr = onErr;
  }

  /**
   * å»ºç«‹è¿æ¥
   */
  connect(): void {
    // å·²æœ‰è¿æ¥å…ˆå…³é—­
    if (this.ws !== null) {
      this.safeCloseInner();
      this.ws = null;
    }

    const socket: webSocket.WebSocket = webSocket.createWebSocket();
    this.ws = socket;

    // --- open äº‹ä»¶ ---
    socket.on('open', (err: BusinessError, _value: Object) => {
      if (err) {
        this.reportError('WebSocket open error: ' + JSON.stringify(err));
        return;
      }
      this.isConnected = true;
      if (this.onOpen) {
        this.onOpen();
      }
    });

    // --- message äº‹ä»¶ ---
    socket.on('message', (err: BusinessError, data: string | ArrayBuffer) => {
      if (err) {
        this.reportError('WebSocket message error: ' + JSON.stringify(err));
        return;
      }

      if (typeof data === 'string') {
        this.handleTextMessage(data);
      } else {
        // åé¢ä½ è¦æ”¯æŒäºŒè¿›åˆ¶å†æ‰©å±•
        this.reportError('Unsupported binary message from server');
      }
    });

    // --- close äº‹ä»¶ ---
    socket.on('close', (err: BusinessError, _result: webSocket.CloseResult) => {
      this.isConnected = false;
      if (err) {
        this.reportError('WebSocket close error: ' + JSON.stringify(err));
      }
      if (this.onClose) {
        this.onClose();
      }
    });

    // --- error äº‹ä»¶ ---
    socket.on('error', (err: BusinessError) => {
      this.isConnected = false;
      this.reportError('WebSocket error: ' + JSON.stringify(err));
    });

    // --- å‘èµ·è¿æ¥ ---
    socket.connect(this.url, (err: BusinessError, value: boolean) => {
      if (err) {
        this.reportError('WebSocket connect error: ' + JSON.stringify(err));
        return;
      }
      if (!value) {
        this.reportError('WebSocket connect failed, value=false');
      }
      // çœŸæ­£ ready è¿˜æ˜¯çœ‹ on('open')
    });
  }

  /**
   * å‘é€åä½œæ¶ˆæ¯
   */
  send(msg: CollabMessage): void {
    if (this.ws === null || !this.isConnected) {
      this.reportError('WebSocket not connected, cannot send');
      return;
    }

    const text: string = JSON.stringify(msg);
    const promise: Promise<boolean> = this.ws.send(text);
    promise.then((ok: boolean) => {
      if (!ok) {
        this.reportError('WebSocket send returned false');
      }
    }).catch((err: string) => {
      this.reportError('WebSocket send error: ' + err);
    });
  }

  /**
   * ä¸»åŠ¨å…³é—­è¿æ¥
   */
  close(): void {
    this.safeCloseInner();
    this.ws = null;
    this.isConnected = false;
  }

  /**
   * å†…éƒ¨å®‰å…¨å…³é—­
   */
  private safeCloseInner(): void {
    if (this.ws === null) {
      return;
    }
    const socket: webSocket.WebSocket = this.ws;
    const promise: Promise<boolean> = socket.close();
    promise.then((_value: boolean) => {
      // ignore
    }).catch((err: string) => {
      this.reportError('WebSocket close error: ' + err);
    });
  }

  /**
   * å¤„ç†æ–‡æœ¬æ¶ˆæ¯ï¼šJSON -> CollabMessage
   */
  private handleTextMessage(text: string): void {
    let parsed: CollabMessage;
    try {
      parsed = JSON.parse(text) as CollabMessage;
    } catch (_e) {
      this.reportError('JSON parse error: ' + text);
      return;
    }

    if (!parsed || !parsed.type || !parsed.clientId) {
      this.reportError('Invalid collab message: ' + text);
      return;
    }

    if (this.onMsg) {
      this.onMsg(parsed);
    }
  }

  /**
   * ç»Ÿä¸€é”™è¯¯ä¸ŠæŠ¥
   */
  private reportError(msg: string): void {
    console.error('[CollabClient] ' + msg);
    if (this.onErr) {
      this.onErr(msg);
    }
  }

  /**
   * å¯¹å¤–æä¾›è¿æ¥çŠ¶æ€
   */
  get connected(): boolean {
    return this.isConnected;
  }
}
